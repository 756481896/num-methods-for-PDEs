<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Nonlinear differential equation problems">
<meta name="keywords" content="linearization explicit time integration,Picard iteration,successive substitutions,linearization Picard iteration,fixed-point iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems)">

<title>Study guide: Nonlinear differential equation problems</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' What makes a differential equations nonlinear? ',
               2,
               None,
               '___sec0'),
              (' examples on linear and nonlinear differential equations ',
               2,
               None,
               '___sec1'),
              (' Introduction of basic concepts ',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              (' The scaled logistic ODE ', 2, None, '___sec3'),
              (' Linearization by explicit time discretization ',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              (' An implicit method: Backward Euler discretization ',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              (' Detour: new notation ', 2, None, '___sec6'),
              (' Exact solution of quadratic nonlinear equations ',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              (' How do we pick the right solution in this case? ',
               2,
               None,
               '___sec8'),
              (' Linearization ', 2, None, '___sec9'),
              (' Picard iteration ',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              (' The algorithm of Picard iteration ', 2, None, '___sec11'),
              (' The algorithm of Picard iteration with classical math notation ',
               2,
               None,
               '___sec12'),
              (' Stopping criteria ', 2, None, '___sec13'),
              (' A single Picard iteration ', 2, None, '___sec14'),
              (' Implicit Crank-Nicolson discretization ',
               2,
               None,
               '___sec15'),
              (' Linearization by a geometric mean ',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              (" Newton's method ",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              (" Newton's method with an iteration index ",
               2,
               None,
               '___sec18'),
              (" Using Newton's method on the logistic ODE ",
               2,
               None,
               '___sec19'),
              (" Using Newton's method on the logistic ODE with typical math notation ",
               2,
               None,
               '___sec20'),
              (' Relaxation may improve the convergence ',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              (' Implementation; part 1 ',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              (' Implementation; part 2 ', 2, None, '___sec23'),
              (' Implementation; part 3 ', 2, None, '___sec24'),
              (' Experiments: accuracy of iteration methods ',
               2,
               None,
               '___sec25'),
              (' Experiments: number of iterations ', 2, None, '___sec26'),
              (' The effect of relaxation can potentially be great! ',
               2,
               None,
               '___sec27'),
              (' Generalization to a general nonlinear ODE ',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              (' Explicit time discretization ', 2, None, '___sec29'),
              (' Backward Euler discretization ', 2, None, '___sec30'),
              (' Picard iteration for Backward Euler scheme ',
               2,
               None,
               '___sec31'),
              (' Manual linearization for a given $f(u,t)$ ',
               2,
               None,
               '___sec32'),
              (' Computational experiments with partially implicit treatment of $f$ ',
               2,
               None,
               '___sec33'),
              (" Newton's method for Backward Euler scheme ",
               2,
               None,
               '___sec34'),
              (' Crank-Nicolson discretization ', 2, None, '___sec35'),
              (' Picard and Newton iteration in the Crank-Nicolson case ',
               2,
               None,
               '___sec36'),
              (' Systems of nonlinear algebraic equations ',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              (' Notation for general systems of algebraic equations ',
               2,
               None,
               '___sec38'),
              (' Picard iteration ',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              (' Algorithm for relaxed Picard iteration ',
               2,
               None,
               '___sec40'),
              (" Newton's method for $F(u)=0$ ",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              (" Algorithm for Newton's method ", 2, None, '___sec42'),
              (" Newton's method for $A(u)u=b(u)$ ",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              (' Combined Picard-Newton algorithm ', 2, None, '___sec44'),
              (' Stopping criteria ',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              (' Combination of absolute and relative stopping criteria ',
               2,
               None,
               '___sec46'),
              (' Example: A nonlinear ODE model from epidemiology ',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              (' Implicit time discretization ', 2, None, '___sec48'),
              (' A Picard iteration ', 2, None, '___sec49'),
              (" Newton's method ", 2, None, '___sec50'),
              (' Actually no need to bother with nonlinear algebraic equations for this particular model... ',
               2,
               None,
               '___sec51'),
              (' Linearization at the differential equation level ',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              (' PDE problem ', 2, None, '___sec53'),
              (' Explicit time integration ',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              (' Backward Euler scheme ',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              (' Picard iteration for Backward Euler scheme ',
               2,
               None,
               '___sec56'),
              (' Picard iteration with alternative notation ',
               2,
               None,
               '___sec57'),
              (" Backward Euler scheme and Newton's method ",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              (" Calculation details of Newton's method at the PDE level ",
               2,
               None,
               '___sec59'),
              (" Calculation details of Newton's method at the PDE level ",
               2,
               None,
               '___sec60'),
              (" Result of Newton's method at the PDE level ",
               2,
               None,
               '___sec61'),
              (' Similarity with Picard iteration ', 2, None, '___sec62'),
              (' Using new notation for implementation ',
               2,
               None,
               '___sec63'),
              (' Combined Picard and Newton formulation ',
               2,
               None,
               '___sec64'),
              (' Crank-Nicolson discretization ',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              (' Solution of nonlinear equations ', 2, None, '___sec66')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Nonlinear differential equation problems</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Nov 6, 2014</h4></center> <!-- date -->
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
&nbsp; &nbsp; &nbsp; <a href="#___sec0"> What makes a differential equations nonlinear? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> examples on linear and nonlinear differential equations </a><br>
<a href="#nonlin:timediscrete:logistic"> Introduction of basic concepts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> The scaled logistic ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:FE"> Linearization by explicit time discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:roots"> An implicit method: Backward Euler discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> Detour: new notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:roots"> Exact solution of quadratic nonlinear equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> How do we pick the right solution in this case? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Linearization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:Picard"> Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> The algorithm of Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> The algorithm of Picard iteration with classical math notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Stopping criteria </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> A single Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Implicit Crank-Nicolson discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:geometric:mean"> Linearization by a geometric mean </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:Newton"> Newton's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Newton's method with an iteration index </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Using Newton's method on the logistic ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Using Newton's method on the logistic ODE with typical math notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:relaxation"> Relaxation may improve the convergence </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:timediscrete:logistic:impl"> Implementation; part 1 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Implementation; part 2 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Implementation; part 3 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Experiments: accuracy of iteration methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Experiments: number of iterations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> The effect of relaxation can potentially be great! </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:ode:generic"> Generalization to a general nonlinear ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Explicit time discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Backward Euler discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Picard iteration for Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Manual linearization for a given \( f(u,t) \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> Computational experiments with partially implicit treatment of \( f \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> Newton's method for Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Crank-Nicolson discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Picard and Newton iteration in the Crank-Nicolson case </a><br>
<a href="#nonlin:systems:alg"> Systems of nonlinear algebraic equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> Notation for general systems of algebraic equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:systems:alg:Picard"> Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Algorithm for relaxed Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:systems:alg:Newton"> Newton's method for \( F(u)=0 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Algorithm for Newton's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:systems:alg:Newton"> Newton's method for \( A(u)u=b(u) \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Combined Picard-Newton algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:systems:alg:terminate"> Stopping criteria </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Combination of absolute and relative stopping criteria </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:systems:alg:SI"> Example: A nonlinear ODE model from epidemiology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Implicit time discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> A Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Newton's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Actually no need to bother with nonlinear algebraic equations for this particular model... </a><br>
<a href="#nonlin:pdelevel"> Linearization at the differential equation level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> PDE problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:pdelevel:explicit"> Explicit time integration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:pdelevel:Picard"> Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> Picard iteration for Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec57"> Picard iteration with alternative notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:pdelevel:Newton"> Backward Euler scheme and Newton's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> Calculation details of Newton's method at the PDE level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Calculation details of Newton's method at the PDE level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Result of Newton's method at the PDE level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Similarity with Picard iteration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec63"> Using new notation for implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec64"> Combined Picard and Newton formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#nonlin:pdelevel:Picard:CN"> Crank-Nicolson discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Solution of nonlinear equations </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>What makes a differential equations nonlinear?  <a name="___sec0"></a></h2>

<ul>
 <p><li> In linear differential equations, the unknown \( u \) or its derivatives
   appear in linear terms \( au(t) \), \( au'(t) \), \( a\nabla^2u \),
   where \( a \) is independent of \( u \).</li>
 <p><li> All other types of terms containing \( u \) are <em>nonlinear</em> and contain
   <font color="red">products of \( u \) or its derivatives</font>.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>examples on linear and nonlinear differential equations  <a name="___sec1"></a></h2>

<p>
Linear ODE:

$$ u^{\prime} (t) = a(t)u(t) + b(t)$$


<p>
Nonlinear ODE:

$$ u^{\prime}(t) = u(t)(1 - u(t)) = u(t) - {\color{red}u(t)^2}$$


<p>
This (pendulum) ODE is also nonlinear:

$$ u^{\prime\prime} + \gamma\sin u = 0$$

because

$$ \sin u = u - \frac{1}{6}u^3 + \Oof{u^5},$$

contains products of \( u \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1>Introduction of basic concepts <a name="nonlin:timediscrete:logistic"></a></h1>

<ul>
 <p><li> Logistic ODE as simple model for a nonlinear problem</li>
 <p><li> Introduction of basic techniques:</li>

<ul>
   <p><li> Explicit time integration (no nonlinearities)</li>
   <p><li> Implicit time integration (nonlinearities)</li>
   <p><li> Linearization and Picard iteration</li>
   <p><li> Linearization via Newton's method</li>
   <p><li> Linearization via a trick like geometric mean</li>
</ul>

 <p><li> Numerical illustration of the performance</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>The scaled logistic ODE  <a name="___sec3"></a></h2>

$$ u^{\prime}(t) = u(t)(1 - u(t)) = u - {\color{red}u^2}$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Linearization by explicit time discretization <a name="nonlin:timediscrete:logistic:FE"></a></h2>

<p>
Forward Euler method:

$$ \frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n)$$


<p>
gives a <em>linear</em> algebraic
equation for the unknown value \( u^{n+1} \)!

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Explicit time integration methods will (normally) linearize
a nonlinear problem.
</div>


<p>
Another example: 2nd-order Runge-Kutta method

$$
\begin{align*}
u^* &= u^n + \Delta t u^n(1 - u^n),\\ 
u^{n+1} &= u^n + \Delta t \half \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right)\tp
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>An implicit method: Backward Euler discretization  <a name="___sec5"></a></h2>
<a name="nonlin:timediscrete:logistic:roots"></a>

<p>
A backward time difference

$$ \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n) $$


<p>
gives a <em>nonlinear</em> algebraic equation for the unknown \( u^n \).
The equation is of quadratic type (which can easily be solved exactly):

$$ \Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0 $$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Detour: new notation  <a name="___sec6"></a></h2>

<p>
To make formulas less overloaded and the mathematics as close as
possible to computer code, a new notation is introduced:

<ul>
 <p><li> \( u^{(1)} \) means \( u^{n-1} \)</li>
 <p><li> In general: \( u^{(\ell)} \) means \( u^{n-\ell} \)</li>
 <p><li> \( u \) is the unknown (\( u^n \))</li>
</ul>

Nonlinear equation to solve in new notation:

$$
F(u) = \Delta t u^2 + (1-\Delta t)u - u^{(1)} = 0
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Exact solution of quadratic nonlinear equations <a name="nonlin:timediscrete:logistic:roots"></a></h2>

<p>
Solution of \( F(u)=0 \):

$$
u = \frac{1}{2\Delta t}
\left(-1-\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u^{(1)}}\right)
$$


<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Observation:</b>
<p>
Nonlinear algebraic equations may have multiple solutions!
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>How do we pick the right solution in this case?  <a name="___sec8"></a></h2>

<p>
Let's investigate the nature of the two roots:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sp</span>
&gt;&gt;&gt; dt, u_1, u = sp.symbols(<span style="color: #CD5555">&#39;dt u_1 u&#39;</span>)
&gt;&gt;&gt; r1, r2 = sp.solve(dt*u**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>-dt)*u - u_1, u)  <span style="color: #228B22"># find roots</span>
&gt;&gt;&gt; r1
(dt - sqrt(dt**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">4</span>*dt*u_1 - <span style="color: #B452CD">2</span>*dt + <span style="color: #B452CD">1</span>) - <span style="color: #B452CD">1</span>)/(<span style="color: #B452CD">2</span>*dt)
&gt;&gt;&gt; r2
(dt + sqrt(dt**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">4</span>*dt*u_1 - <span style="color: #B452CD">2</span>*dt + <span style="color: #B452CD">1</span>) - <span style="color: #B452CD">1</span>)/(<span style="color: #B452CD">2</span>*dt)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> r1.series(dt, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>)
-<span style="color: #B452CD">1</span>/dt + <span style="color: #B452CD">1</span> - u_1 + dt*(u_1**<span style="color: #B452CD">2</span> - u_1) + O(dt**<span style="color: #B452CD">2</span>)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> r2.series(dt, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>)
u_1 + dt*(-u_1**<span style="color: #B452CD">2</span> + u_1) + O(dt**<span style="color: #B452CD">2</span>)
</pre></div>
</td></tr></table><p>
The <code>r1</code> root behaves as \( 1/\Delta t\rightarrow\infty \)
as \( \Delta t\rightarrow 0 \)! Therefore, only the <code>r2</code> root is of
relevance.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Linearization  <a name="___sec9"></a></h2>

<ul>
 <p><li> In general, we cannot solve nonlinear algebraic equations
   with formulas</li>
 <p><li> We must <em>linearize</em> the equation, or create a recursive set
   of <em>linearized</em> equations whose solutions hopefully converge
   to the solution of the nonlinear equation</li>
 <p><li> Manual linearization may be an art</li>
 <p><li> Automatic linearization is possible (cf. Newton's method)</li>
</ul>

Examples will illustrate the points!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard iteration <a name="nonlin:timediscrete:logistic:Picard"></a></h2>

<p>
Nonliner equation from Backward Euler scheme for logistic ODE:

$$ F(u) = au^2 + bu + c = 0$$


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Let \( u^{-} \) be an available approximation of the unknown \( u \).
</div>


<p>
Linearization of \( u^2 \): \( u^{-}u \)

$$ F(u)\approx\hat F(u) = au^{-}u + bu + c = 0$$


<p>
But

<ul>
 <p><li> Problem: the solution \( u \) of \( \hat F(u)=0 \) is not the exact solution
   of \( F(u)=0 \)</li>
 <p><li> Solution: set \( u^{-}=u \) and repeat the procedure</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>The algorithm of Picard iteration  <a name="___sec11"></a></h2>

<p>
At a time level, set \( u^{-}=u^{(1)} \) (solution at previous time level)
and iterate:

$$ u = -\frac{c}{au^{-} + b},\quad u^{-}\ \leftarrow\ u$$


<p>
This technique is known as

<ul>
 <p><li> fixed-point iteration</li>
 <p><li> successive substitutions</li>
 <p><li> nonlinear Richardson iteration</li>
 <p><li> <font color="red">Picard iteration</font></li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>The algorithm of Picard iteration with classical math notation  <a name="___sec12"></a></h2>

<ul>
 <p><li> \( u^k \): computed approximation in iteration \( k \)</li>
 <p><li> \( u^{k+1} \) is the next approximation (unknown)</li>
</ul>

$$ au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots$$


<p>
Or with a time level \( n \) too:

$$ au^{n,k} u^{n,k+1} + bu^{n,k+1} - u^{n-1} = 0\quad\Rightarrow\quad u^{n,k+1}
= \frac{u^n}{au^{n,k} + b},\quad k=0,1,\ldots$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Stopping criteria  <a name="___sec13"></a></h2>

<p>
Using change in solution:

$$ |u - u^{-}| \leq\epsilon_u$$


<p>
or change in residual:

$$ |F(u)|= |au^2+bu + c| < \epsilon_r$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>A single Picard iteration  <a name="___sec14"></a></h2>

<p>
Common simple and cheap technique: perform 1 single Picard iteration

$$
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - {\color{red}u^{n-1}})
$$


<p>
Inconsistent time discretization (\( u(1-u) \) must be evaluated for
\( n \), \( n-1 \), or \( n-\frac{1}{2} \)) - can produce quite inaccurate results, but
is very popular.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Implicit Crank-Nicolson discretization  <a name="___sec15"></a></h2>

<p>
Crank-Nicolson discretization:

$$ [D_t u = u(1-u)]^{n+\half}$$


$$
\frac{u^{n+1}-u^n}{\Delta t} = u^{n+\half} -
(u^{n+\half})^2
$$


<p>
Approximate \( u^{n+\half} \) as usual by an arithmetic
mean,

$$ u^{n+\half}\approx \half(u^n + u^{n+1})$$


$$ (u^{n+\half})^2\approx \frac{1}{4}(u^n + u^{n+1})^2\quad\hbox{(nonlinear term)}$$


<p>
which is nonlinear in the unknown \( u^{n+1} \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Linearization by a geometric mean <a name="nonlin:timediscrete:logistic:geometric:mean"></a></h2>

<p>
Using a <em>geometric mean</em> for \( (u^{n+\half})^2 \) linearizes
the nonlinear term \( (u^{n+\half})^2 \) (error \( \Oof{\Delta t^2} \) as
in the discretization of \( u^{\prime} \)):

$$ (u^{n+\half})^2\approx u^nu^{n+1}$$


<p>
Arithmetic mean on the linear \( u^{n+\frac{1}{2}} \) term and a geometric
mean for \( (u^{n+\half})^2 \) gives a linear equation
for \( u^{n+1} \):

$$ \frac{{\color{red}u^{n+1}}-u^n}{\Delta t} =
\half(u^n + {\color{red}u^{n+1}}) + u^n{\color{red}u^{n+1}}$$


<p>
Note: Here we turned a nonlinear algebraic equation into a linear
one. No need for iteration! (Consistent \( \Oof{\Delta t^2} \) approx.)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method <a name="nonlin:timediscrete:logistic:Newton"></a></h2>

<p>
Write the nonlinear algebraic equation as

$$ F(u) = 0 $$


<p>
Newton's method: linearize \( F(u) \) by two terms from the Taylor series,

$$
\begin{align*}
F(u) &= F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) + {\half}F^{\prime\prime}(u^{-})(u-u^{-})^2
+\cdots\\ 
& \approx F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) = \hat F(u)\tp
\end{align*}
$$


<p>
The linear equation \( \hat F(u)=0 \) has the solution

$$ u = u^{-} - \frac{F(u^{-})}{F^{\prime}(u^{-})}\tp$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method with an iteration index  <a name="___sec18"></a></h2>

$$ u^{k+1} = u^k - \frac{F(u^k)}{F^{\prime}(u^k)},\quad k=0,1,\ldots$$


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Newton's method exhibits <em>quadratic convergence</em> if
\( u^k \) is sufficiently close to the solution. Otherwise, the method
may diverge.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Using Newton's method on the logistic ODE  <a name="___sec19"></a></h2>

$$ F(u) = au^2 + bu + c$$


$$ F^{\prime}(u) = 2au + b$$


<p>
The iteration method becomes

$$
u = u^{-} + \frac{a(u^{-})^2 + bu^{-} + c}{2au^{-} + b},\quad
u^{-}\ \leftarrow u
$$


<p>
Start of iteration: \( u^{-}=u^{(1)} \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Using Newton's method on the logistic ODE with typical math notation  <a name="___sec20"></a></h2>

<p>
Set iteration start as \( u^{n,0}= u^{n-1} \) and iterate
with explicit indices for time (\( n \)) and
Newton iteration (\( k \)):

$$
u^{n,k+1} = u^{n,k} +
\frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
{2\Delta t u^{n,k} + 1 - \Delta t}
$$


<p>
Compare notation with

$$
u = u^{-} +
\frac{\Delta t (u^{-})^2 + (1-\Delta t)u^{-} - u^{(1)}}
{2\Delta t u^{-} + 1 - \Delta t}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Relaxation may improve the convergence <a name="nonlin:timediscrete:logistic:relaxation"></a></h2>

<ul>
 <p><li> Problem: Picard and Newton iteration may change the solution too much</li>
 <p><li> Remedy: relaxation (less change in the solution)</li>
 <p><li> Let \( u^* \) be the suggested new value from Picard or Newton iteration</li>
</ul>

Relaxation with <em>relaxation parameter</em> \( \omega \) (weight old and new value):

$$ u = \omega u^* + (1-\omega) u^{-},\quad \omega \leq 1$$


<p>
Simple formula when used in Newton's method:

$$
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Implementation; part 1 <a name="nonlin:timediscrete:logistic:impl"></a></h2>

<p>
Program <a href="http://tinyurl.com/nm5587k/nonlin/logistic.py" target="_self"><tt>logistic.py</tt></a>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">BE_logistic</span>(u0, dt, Nt, choice=<span style="color: #CD5555">&#39;Picard&#39;</span>,
                eps_r=<span style="color: #B452CD">1E-3</span>, omega=<span style="color: #B452CD">1</span>, max_iter=<span style="color: #B452CD">1000</span>):
    <span style="color: #8B008B; font-weight: bold">if</span> choice == <span style="color: #CD5555">&#39;Picard1&#39;</span>:
        choice = <span style="color: #CD5555">&#39;Picard&#39;</span>;  max_iter = <span style="color: #B452CD">1</span>

    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)
    iterations = []
    u[<span style="color: #B452CD">0</span>] = u0
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt+<span style="color: #B452CD">1</span>):
        a = dt
        b = <span style="color: #B452CD">1</span> - dt
        c = -u[n-<span style="color: #B452CD">1</span>]

        <span style="color: #8B008B; font-weight: bold">if</span> choice == <span style="color: #CD5555">&#39;Picard&#39;</span>:

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">F</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> a*u**<span style="color: #B452CD">2</span> + b*u + c

            u_ = u[n-<span style="color: #B452CD">1</span>]
            k = <span style="color: #B452CD">0</span>
            <span style="color: #8B008B; font-weight: bold">while</span> <span style="color: #658b00">abs</span>(F(u_)) &gt; eps_r <span style="color: #8B008B">and</span> k &lt; max_iter:
                u_ = omega*(-c/(a*u_ + b)) + (<span style="color: #B452CD">1</span>-omega)*u_
                k += <span style="color: #B452CD">1</span>
            u[n] = u_
            iterations.append(k)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Implementation; part 2  <a name="___sec23"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">BE_logistic</span>(u0, dt, Nt, choice=<span style="color: #CD5555">&#39;Picard&#39;</span>,
                eps_r=<span style="color: #B452CD">1E-3</span>, omega=<span style="color: #B452CD">1</span>, max_iter=<span style="color: #B452CD">1000</span>):
    ...
        <span style="color: #8B008B; font-weight: bold">elif</span> choice == <span style="color: #CD5555">&#39;Newton&#39;</span>:

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">F</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> a*u**<span style="color: #B452CD">2</span> + b*u + c

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dF</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*a*u + b

            u_ = u[n-<span style="color: #B452CD">1</span>]
            k = <span style="color: #B452CD">0</span>
            <span style="color: #8B008B; font-weight: bold">while</span> <span style="color: #658b00">abs</span>(F(u_)) &gt; eps_r <span style="color: #8B008B">and</span> k &lt; max_iter:
                u_ = u_ - F(u_)/dF(u_)
                k += <span style="color: #B452CD">1</span>
            u[n] = u_
            iterations.append(k)
    <span style="color: #8B008B; font-weight: bold">return</span> u, iterations
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Implementation; part 3  <a name="___sec24"></a></h2>

<p>
The Crank-Nicolson method with a geometric mean:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">CN_logistic</span>(u0, dt, Nt):
    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)
    u[<span style="color: #B452CD">0</span>] = u0
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*dt)/(<span style="color: #B452CD">1</span> + dt*u[n] - <span style="color: #B452CD">0.5</span>*dt)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Experiments: accuracy of iteration methods  <a name="___sec25"></a></h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  The impact of solution strategies and for four different time step lengths on the solution. <a name="nonlin:timediscrete:logistic:impl:fig:u"></a> </p></center>
<p><img src="fig-nonlin/logistic_u.png" align="bottom" width=800></p>
</center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Experiments: number of iterations  <a name="___sec26"></a></h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Comparison of the number of iterations at various time levels for Picard and Newton iteration. <a name="nonlin:timediscrete:logistic:impl:fig:iter"></a> </p></center>
<p><img src="fig-nonlin/logistic_iter.png" align="bottom" width=800></p>
</center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>The effect of relaxation can potentially be great!  <a name="___sec27"></a></h2>

<ul>
 <p><li> \( \Delta t=0.9 \): Picard required 32 iterations on average</li>
 <p><li> \( \omega =0.8 \): 7 iterations</li>
 <p><li> \( \omega =0.5 \): 2 iterations (!) - optimal choice</li>
</ul>

Other \( \omega=1 \) experiments:

<p>
<table border="1">
<thead>
<tr><td align="center">\( \Delta t \)</td> <td align="center">\( \epsilon_r \)</td> <th align="center">Picard</th> <th align="center">Newton</th> </tr>
</thead>
<tbody>
<tr><td align="left">   \( 0.2 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   5         </td> <td align="right">   2         </td> </tr>
<tr><td align="left">   \( 0.2 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   2         </td> <td align="right">   1         </td> </tr>
<tr><td align="left">   \( 0.4 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   12        </td> <td align="right">   3         </td> </tr>
<tr><td align="left">   \( 0.4 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   4         </td> <td align="right">   2         </td> </tr>
<tr><td align="left">   \( 0.8 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   58        </td> <td align="right">   3         </td> </tr>
<tr><td align="left">   \( 0.8 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   4         </td> <td align="right">   2         </td> </tr>
</tbody>
</table>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Generalization to a general nonlinear ODE <a name="nonlin:ode:generic"></a></h2>

$$
u^{\prime} = f(u, t)
$$


<p>
Note: \( f \) is in general nonlinear in \( u \) so the ODE is nonlinear

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Explicit time discretization  <a name="___sec29"></a></h2>

<p>
Forward Euler and all explicit methods sample \( f \) with known
values and all nonlinearities are gone:

$$ \frac{{\color{red}u^{n+1}}-u^n}{\Delta t} = f(u^n, t_n) $$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Backward Euler discretization  <a name="___sec30"></a></h2>

<p>
Backward Euler \( [D_t^- u = f]^n \) leads to nonlinear algebraic equations:

$$ F(u^n) = u^{n} - \Delta t\, f(u^n, t_n) - u^{n-1}=0,$$


<p>
Alternative notation:

$$ F(u) = u - \Delta t\, f(u, t_n) - u^{(1)} = 0\tp$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard iteration for Backward Euler scheme  <a name="___sec31"></a></h2>

<p>
A simple Picard iteration, not knowing anything about the nonlinear
structure of \( f \), must approximate \( f(u,t_n) \) by \( f(u^{-},t_n) \):

$$ \hat F(u) = u - \Delta t\, f(u^{-},t_n) - u^{(1)}\tp$$


<p>
The iteration starts with \( u^{-}=u^{(1)} \) and proceeds with repeating

$$ u^* = \Delta t\, f(u^{-},t_n) + u^{(1)},\quad
   u = \omega u^* + (1-\omega)u^{-},
\quad u^{-}\ \leftarrow\ u,$$

until a stopping criterion is fulfilled.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Manual linearization for a given \( f(u,t) \)  <a name="___sec32"></a></h2>

<ul>
 <p><li> \( f(u^{-},t) \): <em>explicit</em> treatment of \( f \)<br />
   (as in time-discretization)</li>
 <p><li> \( f(u,t) \): <em>fully implicit</em> treatment of \( f \)</li>
 <p><li> If \( f \) has some structure, say \( f(u,t)=u^3 \), we may
   think of a <em>partially implicit</em> treatment: \( (u^{-})^2u \)</li>
 <p><li> More implicit treatment of \( f \) often gives faster
   convergence<br />
   (as it gives more stable time discretizations)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Computational experiments with partially implicit treatment of \( f \)  <a name="___sec33"></a></h2>

<ul>
 <p><li> \( f(u,t)=-u^3 \):</li>

<ul>
   <p><li> \( (u^{-})^3 \) linearization: 22, 9, 6 iterations</li>
   <p><li> \( (u^{-})^2u \) linearization: 8, 5, 4 iterations</li>
</ul>

 <p><li> \( f(u,t)=e^{-u} \): a trick \( f(u^{-},t)u/u^{-} \) has no effect</li>
 <p><li> \( f(u,t)=\sin(2(u+1)) \): a trick \( f(u^{-},t)u/u^{-} \) has effect<br />
   (7, 9, 11 iterations vs 17, 21, 20)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method for Backward Euler scheme  <a name="___sec34"></a></h2>

<p>
Newton's method requires the computation of the derivative

$$ F^{\prime}(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n)$$


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Algorithm for Newton's method for \( u^{\prime}=f(u,t) \).</b>
<p>
Start with \( u^{-}=u^{(1)} \), then iterate

$$
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
= u^{-} - \omega \frac{u^{(1)} + \Delta t\, f(u^{-},t_{n})}{1 - \Delta t
\frac{\partial}{\partial u}f(u^{-},t_n)}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Crank-Nicolson discretization  <a name="___sec35"></a></h2>

<p>
The standard Crank-Nicolson scheme with arithmetic mean approximation of
\( f \) reads

$$ \frac{u^{n+1} - u^n}{\Delta t} = \half(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n))$$


<p>
Nonlinear algebraic equation:

$$
F(u) = u - u^{(1)} - \Delta t{\half}f(u,t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}) = 0
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard and Newton iteration in the Crank-Nicolson case  <a name="___sec36"></a></h2>

<p>
Picard iteration (for a general \( f \)):

$$ \hat F(u) = u - u^{(1)} - \Delta t{\half}f(u^{-},t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n})$$


<p>
Newton's method:

$$ F^{\prime}(u)= 1 - \half\Delta t\frac{\partial f}{\partial u}(u,t_{n+1})$$


<p>
<!-- see ODE_Picard_tricks.py for testing -->

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1>Systems of nonlinear algebraic equations <a name="nonlin:systems:alg"></a></h1>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
$$
\begin{align*}
x\cos y + y^3 & = 0\\ 
y^2e^x + xy &= 2
\end{align*}
$$
</div>
<!-- end box -->


<p>
Systems of nonlinear algebraic equations arise from solving
<em>systems of ODEs</em> or solving <em>PDEs</em>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Notation for general systems of algebraic equations  <a name="___sec38"></a></h2>

$$ F(u) = 0,$$


<p>
where

$$ u=(u_0,\ldots,u_N),\quad F=(F_0,\ldots,F_N)$$


<p>
Special linear system-type structure <br />
(arises frequently in PDE problems):

$$ A(u)u = b(u)$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard iteration <a name="nonlin:systems:alg:Picard"></a></h2>

<p>
Picard iteration for \( F(u)=0 \) is meaningless unless there is
some structure so we can linearize. For \( A(u)u=b(u) \) we can
linearize

$$ A(u^{-})u = b(u^{-})$$


<p>
Note: we solve a system of nonlinear algebraic equations as
a sequence of linear systems.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Algorithm for relaxed Picard iteration  <a name="___sec40"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Given \( A(u)u=b(u) \) and an initial guess \( u^{-} \), iterate until convergence:

<ol>
<p><li> solve \( A(u^{-})u^* = b(u^{-}) \) with respect to \( u^* \)</li>
<p><li> \( u = \omega u^* + (1-\omega) u^{-} \)</li>
<p><li> \( u^{-}\ \leftarrow\ u \)</li>
</ol>
</div>


<p>
&quot;Until convergence&quot;: \( ||u - u^{-}|| \leq \epsilon_u \) or
\( ||A(u)u-b|| \leq\epsilon_r \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method for \( F(u)=0 \)  <a name="___sec41"></a></h2>
<a name="nonlin:systems:alg:Newton"></a>

<p>
Linearization of \( F(u)=0 \) equation:

$$ F(u^{-}) + J(u^{-}) \cdot (u - u^{-})$$


<p>
where \( J \) is the <em>Jacobian</em> of \( F \), defined by

$$ J_{i,j} = \frac{\partial F_i}{\partial u_j}\]
e$$


Approximate the original nonlinear system $F(u)=0$ by

$$ \hat F(u) = F(u^{-}) + J(u^{-}) \cdot (u - u^{-})=0,$$


<p>
which is linear in \( u \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Algorithm for Newton's method  <a name="___sec42"></a></h2>

$$ \hat F(u) = F(u^{-}) + J(u^{-}) \cdot (u - u^{-})=0,$$


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Solution by a two-step procedure:

<ol>
<p><li> solve linear system \( J\delta u = -F(u^{-}) \) wrt \( \delta u \)</li>
<p><li> update \( u = u^{-} + \delta u \)</li>
</ol>

Relaxed update:

$$ u = \omega(u^{-} +\delta u)
+ (1-\omega)u^{-} = u^{-}  + \omega\delta u
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method for \( A(u)u=b(u) \) <a name="nonlin:systems:alg:Newton"></a></h2>

<p>
For

$$ F_i = \sum_k A_{i,k}(u)u_k - b_i(u)$$


<p>
one gets

$$
J_{i,j} = \frac{\partial F_i}{\partial u_j}
= \sum_k \frac{\partial A_{i,k}}{\partial u_j}u_k
+ A_{i,j} -
\frac{\partial b_i}{\partial u_j}
$$


<p>
Matrix form:

$$ (A + A^{\prime}u + b^{\prime})\delta u = -Au + b$$


$$ (A(u^{-}) + A^{\prime}(u^{-})u^{-} + b^{\prime}(u^{-}))\delta u
= -A(u^{-})u^{-} + b(u^{-})$$


<p>
Compare with Picard iteration:

$$ \underbrace{A(u^{-})(u^{-}+\delta u) - b(u^{-})}_{\hbox{Picard system}}
+\, \gamma (A^{\prime}(u^{-})u^{-} + b^{\prime}(u^{-}))\delta u
= 0$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Combined Picard-Newton algorithm  <a name="___sec44"></a></h2>

<p>
Observation: Newton's method contains all the terms in Picard iteration

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
Given \( A(u) \), \( b(u) \), and an initial guess \( u^{-} \), iterate until convergence:

<ol>
<p><li> solve \( (A + \gamma(A^{\prime}(u^{-})u^{-} +
   b^{\prime}(u^{-})))\delta u = -A(u^{-})u^{-} + b(u^{-}) \)
   with respect to \( \delta u \)</li>
<p><li> \( u = u^{-} + \omega\delta u \)</li>
<p><li> \( u^{-}\ \leftarrow\ u \)</li>
</ol>

Note:

<ul>
  <p><li> \( \gamma =1 \): Newton's method</li>
  <p><li> \( \gamma =0 \): Picard iteration</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Stopping criteria <a name="nonlin:systems:alg:terminate"></a></h2>

<p>
Let \( ||\cdot|| \) be the standard Eucledian vector norm. Several termination
criteria are much in use:

<ul>
 <p><li> Absolute change in solution: \( ||u - u^{-}||\leq \epsilon_u \)</li>
 <p><li> Relative change in solution: \( ||u - u^{-}||\leq \epsilon_u ||u_0|| \),
   where \( u_0 \) denotes the start value of \( u^{-} \) in the iteration</li>
 <p><li> Absolute residual: \( ||F(u)|| \leq \epsilon_r \)</li>
 <p><li> Relative residual: \( ||F(u)|| \leq \epsilon_r ||F(u_0)|| \)</li>
 <p><li> Max no of iterations: stop when \( k > k_{\max} \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Combination of absolute and relative stopping criteria  <a name="___sec46"></a></h2>

<p>
Problem with relative criterion: a small
\( ||F(u_0)|| \) (because \( u_0\approx u \), perhaps because of small \( \Delta t \))
must be significantly reduced. Better with absolute criterion.

<ul>
 <p><li> Can make combined absolute-relative criterion</li>
 <p><li> \( \epsilon_{rr} \): tolerance for relative part</li>
 <p><li> \( \epsilon_{ra} \): tolerance for absolute part</li>
</ul>

$$
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
$$


$$
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
\quad\hbox{or}\quad
||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua}
\quad\hbox{or}\quad
k>k_{\max}\tp
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Example: A nonlinear ODE model from epidemiology <a name="nonlin:systems:alg:SI"></a></h2>

<p>
Spreading of a disease (e.g., a flu) can be modeled by
a \( 2\times 2 \) ODE system

$$
\begin{align*}
S^{\prime} &= -\beta SI\\ 
I^{\prime} &= \beta SI - \nu I
\end{align*}
$$


<p>
Here:

<ul>
 <p><li> \( S(t) \) is the number of people who can get ill (susceptibles)</li>
 <p><li> \( I(t) \) is the number of people who are ill (infected)</li>
 <p><li> Must know \( \beta >0 \) (danger of getting ill) and <br />
   \( \nu >0 \) (\( 1/\nu \): expected recovery time)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Implicit time discretization  <a name="___sec48"></a></h2>

<p>
A Crank-Nicolson scheme:

$$
\begin{align*}
\frac{S^{n+1}-S^n}{\Delta t} &= -\beta [SI]^{n+\half}
\approx -\frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1})\\ 
\frac{I^{n+1}-I^n}{\Delta t} &= \beta [SI]^{n+\half} -
\nu I^{n+\half}
\approx \frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}) -
\frac{\nu}{2}(I^n + I^{n+1})
\end{align*}
$$


<p>
New notation: \( S \) for \( S^{n+1} \), \( S^{(1)} \) for \( S^n \), \( I \) for \( I^{n+1} \),
\( I^{(1)} \) for \( I^n \)

$$
\begin{align*}
F_S(S,I) &= S - S^{(1)} +
\half\Delta t\beta(S^{(1)}I^{(1)} + SI) = 0\\ 
F_I(S,I) &= I - I^{(1)} -
\half\Delta t\beta(S^{(1)}I^{(1)} + SI) -
\half\Delta t\nu(I^{(1)} + I) =0
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>A Picard iteration  <a name="___sec49"></a></h2>

<ul>
 <p><li> We have approximations \( S^{-} \) and \( I^{-} \) to \( S \) and \( I \).</li>
 <p><li> Linearize \( SI \) in \( S \) ODE as \( I^{-}S \) (linear equation in \( S \)!)</li>
 <p><li> Linearize \( SI \) in \( I \) ODE as \( S^{-}I \) (linear equation in \( I \)!)</li>
</ul>

$$
\begin{align*}
S &= \frac{S^{(1)} - \half\Delta t\beta S^{(1)}I^{(1)}}
{1 + \half\Delta t\beta I^{-}}
\\ 
I &= \frac{I^{(1)} + \half\Delta t\beta S^{(1)}I^{(1)}}
{1 - \half\Delta t\beta S^{-} + \nu}
\end{align*}
$$

Before a new iteration: \( S^{-}\ \leftarrow\ S \) and
\( I^{-}\ \leftarrow\ I \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Newton's method  <a name="___sec50"></a></h2>

$$ F(u)=0,\quad F=(F_S,F_I),\  u=(S,I) $$


<p>
Jacobian:

$$
\renewcommand*{\arraystretch}{2}
J = \left(\begin{array}{cc}
\frac{\partial}{\partial S} F_S & \frac{\partial}{\partial I}F_S\\ 
\frac{\partial}{\partial S} F_I & \frac{\partial}{\partial I}F_I
\end{array}\right)
= \left(\begin{array}{cc}
1 + \half\Delta t\beta I & \half\Delta t\beta\\ 
- \half\Delta t\beta S & 1 - \half\Delta t\beta I -
\half\Delta t\nu
\end{array}\right)
$$


<p>
Newton system: \( J(u^{-})\delta u = -F(u^{-}) \)

$$
\begin{align*}
\renewcommand*{\arraystretch}{1.5}
&
\left(\begin{array}{cc}
1 + \half\Delta t\beta I^{-} & \half\Delta t\beta S^{-}\\ 
- \half\Delta t\beta S^{-} & 1 - \half\Delta t\beta I^{-} -
\half\Delta t\nu
\end{array}\right)
\left(\begin{array}{c}
\delta S\\ 
\delta I
\end{array}\right)
=\\ 
& \qquad\qquad
\left(\begin{array}{c}
S^{-} - S^{(1)} + \half\Delta t\beta(S^{(1)}I^{(1)} + S^{-}I^{-})\\ 
I^{-} - I^{(1)} - \half\Delta t\beta(S^{(1)}I^{(1)} + S^{-}I^{-}) -
\half\Delta t\nu(I^{(1)} + I^{-})
\end{array}\right)
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Actually no need to bother with nonlinear algebraic equations for this particular model...  <a name="___sec51"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Remark:</b>
<p>
For this particular system of ODEs, explicit time integration methods work very
well. Even a Forward Euler scheme is fine, but
the 4-th order Runge-Kutta method is an excellent
balance between high accuracy, high efficiency, and simplicity.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1>Linearization at the differential equation level <a name="nonlin:pdelevel"></a></h1>

<p>
Goal: linearize a PDE like

$$
\frac{\partial u}{\partial t} = \nabla\cdot ({\color{red}\dfc(u)\nabla u})
+ {\color{red}f(u)}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>PDE problem  <a name="___sec53"></a></h2>

$$
\begin{align*}
\frac{\partial u}{\partial t} &= \nabla\cdot (\dfc(u)\nabla u) + f(u),\quad
&\x\in\Omega,\ t\in (0,T]
\\ 
-\dfc(u)\frac{\partial u}{\partial n} &= g,\quad &\x\in\partial\Omega_N,\ 
t\in (0,T]
\\ 
u &= u_0,\quad &\x\in\partial\Omega_D,\ t\in (0,T]
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Explicit time integration <a name="nonlin:pdelevel:explicit"></a></h2>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Explicit time integration methods remove the nonlinearity
</div>
<!-- end box -->


<p>
Forward Euler method:

$$ [D_t^+ u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^n$$


<p>
Written out:

$$ \frac{u^{n+1} - u^n}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)$$


<p>
This is a <em>linear equation</em> in the unknown \( u^{n+1} \), with solution

$$ u^{n+1} = u^n + \Delta t\nabla\cdot (\dfc(u^n)\nabla u^n) +
\Delta t f(u^n)$$


<p>
Disadvantage: \( \Delta t \leq (\max\alpha)^{-1}(\Delta x^2 + \Delta y^2 + \Delta z^2) \)
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Backward Euler scheme <a name="nonlin:pdelevel:Picard"></a></h2>

<p>
Backward Euler scheme:

$$ [D_t^- u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^n$$


<p>
Written out:

$$
\frac{u^{n} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)
$$


<p>
This is a nonlinear, stationary PDE for the unknown function \( u^n(\x) \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard iteration for Backward Euler scheme  <a name="___sec56"></a></h2>

<p>
We have

$$
\frac{u^{n} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)
$$


<p>
Picard iteration:

$$
\frac{u^{n,k+1} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^{n,k})
\nabla u^{n,k+1})
+ f(u^{n,k})
$$


<p>
Start iteration with \( u^{n,0}=u^{n-1} \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Picard iteration with alternative notation  <a name="___sec57"></a></h2>

$$
\frac{u^{n,k+1} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^{n,k})
\nabla u^{n,k+1})
+ f(u^{n,k})
$$


<ul>
 <p><li> Let's rewrite with a simplified, implementation-friendly notation</li>
 <p><li> \( u \) means the unknown \( u^{n,k+1} \)</li>
 <p><li> \( u^{-} \) means the most recent approximation to \( u \)</li>
 <p><li> \( u^{(1)} \) means \( u^{n-1} \) (\( u^{(\ell)} \) means \( u^{n-\ell} \))</li>
</ul>

$$
\frac{u - u^{(1)}}{\Delta t} = \nabla\cdot (\dfc(u^{-})
\nabla u)
+ f(u^{-})
$$


<p>
Start iteration with \( u^{-}=u^{(1)} \);
update with \( u^{-} \) to \( u \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Backward Euler scheme and Newton's method <a name="nonlin:pdelevel:Newton"></a></h2>

<ul>
 <p><li> Normally, Newton's method is defined for systems of <em>algebraic equations</em>,
   but the idea of the method can be applied at the PDE level too</li>
 <p><li> Let \( u^{n,k} \) be an approximation to the unknown \( u^n \)</li>
</ul>

We seek a better approximation

$$
u^{n} \approx u^{n,k+1} = u^{n,k} + \delta u
$$


<ul>
 <p><li> Insert \( u^{n} = u^{n,k} + \delta u \) in the PDE</li>
 <p><li> Taylor expand the nonlinearities
   and keep only terms that are linear in \( \delta u \)</li>
</ul>

Result: linear PDE for the correction \( \delta u \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Calculation details of Newton's method at the PDE level  <a name="___sec59"></a></h2>

<p>
Insert \( u^{n,k} +\delta u \) for \( u^n \) in PDE:

$$
\frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} =
\nabla\cdot (\dfc(u^{n,k} + \delta u)\nabla (u^{n,k}+\delta u))
+ f(u^{n,k}+\delta u)
$$


<p>
Taylor expand \( \dfc(u^{n,k} + \delta u) \) and
\( f(u^{n,k}+\delta u) \):

$$
\begin{align*}
\dfc(u^{n,k} + \delta u) & = \dfc(u^{n,k}) + \frac{d\dfc}{du}(u^{n,k})
\delta u + \Oof{\delta u^2}\approx \dfc(u^{n,k}) + \dfc^{\prime}(u^{n,k})\delta u\\ 
f(u^{n,k}+\delta u) &=  f(u^{n,k}) + \frac{df}{du}(u^{n,k})\delta u
+ \Oof{\delta u^2}\approx f(u^{n,k}) + f^{\prime}(u^{n,k})\delta u
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Calculation details of Newton's method at the PDE level  <a name="___sec60"></a></h2>

<p>
Inserting linear approximations of \( \dfc \) and \( f \):

$$
\begin{align*}
\frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} &=
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k}) + f(u^{m,k}) + \\ 
&\quad \nabla\cdot (\dfc(u^{n,k})\nabla \delta u)
+ \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k}) + \\ 
&\quad \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla \delta u)
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$


<p>
Note: \( \dfc^{\prime}(u^{n,k})\delta u\nabla \delta u \) is \( \Oof{\delta u^2} \)
and therefore omitted.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Result of Newton's method at the PDE level  <a name="___sec61"></a></h2>

$$ \delta F(\delta u; u^{n,k}) = -F(u^{n,k})$$


<p>
with

$$
\begin{align*}
F(u^{n,k}) &= \frac{u^{n,k} - u^{n-1}}{\Delta t} -
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k}) + f(u^{n,k})
\\ 
\delta F(\delta u; u^{n,k}) &=
- \frac{1}{\Delta t}\delta u +
\nabla\cdot (\dfc(u^{n,k})\nabla \delta u) + \\ 
&\qquad \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k})
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$


<p>
Note:

<ul>
 <p><li> \( \delta F \) is linear in \( \delta u \)</li>
 <p><li> \( F \) contains only known terms</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Similarity with Picard iteration  <a name="___sec62"></a></h2>

<p>
Rewrite the PDE for \( \delta u \) using
\( u^{n,k} + \delta u =u^{n,k+1} \):

$$
\begin{align*}
& \frac{u^{n,k+1} - u^{n-1}}{\Delta t} =
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k+1}) + f(u^{n,k})\\ 
&\qquad  + \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k})
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$


<p>
Note:

<ul>
 <p><li> The first line is the same PDE as arise in the Picard iteration</li>
 <p><li> The remaining terms arise from the differentiations in Newton's method</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Using new notation for implementation  <a name="___sec63"></a></h2>

<ul>
 <p><li> \( u \) for \( u^n \)</li>
 <p><li> \( u^{-} \) for \( u^{n,k} \)</li>
 <p><li> \( u^{(1)} \) for \( u^{n-1} \)</li>
</ul>

$$
\begin{align*}
F(u^{-}) &= \frac{u^{-} - u^{(1)}}{\Delta t} -
\nabla\cdot (\dfc(u^{-})\nabla u^{-}) + f(u^{-})
\\ 
\delta F(\delta u; u^{-}) &=
- \frac{1}{\Delta t}\delta u +
\nabla\cdot (\dfc(u^{-})\nabla \delta u) + \nonumber\\ 
&\quad \nabla\cdot (\dfc^{\prime}(u^{-})\delta u\nabla u^{-})
+ f^{\prime}(u^{-})\delta u
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Combined Picard and Newton formulation  <a name="___sec64"></a></h2>

$$
\begin{align*}
& \frac{u - u^{(1)}}{\Delta t} =
\nabla\cdot (\dfc(u^{-})\nabla u) + f(u^{-}) + \\ 
&\qquad  \gamma(\nabla\cdot (\dfc^{\prime}(u^{-})(u - u^{-})\nabla u^{-})
+ f^{\prime}(u^{-})(u - u^{-}))
\end{align*}
$$


<p>
Observe:

<ul>
 <p><li> \( \gamma=0 \): Picard iteration</li>
 <p><li> \( \gamma=1 \): Newton's method</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Crank-Nicolson discretization <a name="nonlin:pdelevel:Picard:CN"></a></h2>

<p>
Crank-Nicolson discretization applies a centered difference
at \( t_{n+\frac{1}{2}} \):

$$ [D_t u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^{n+\frac{1}{2}}\tp$$


<p>
Many choices of formulating an arithmetic means:

$$
\begin{align*}
[f(u)]^{n+\frac{1}{2}} &\approx f(\frac{1}{2}(u^n + u^{n+1}))
= [f(\overline{u}^t)]^{n+\frac{1}{2}},\\ 
[f(u)]^{n+\frac{1}{2}} &\approx \frac{1}{2}(f(u^n) + f(u^{n+1}))
=[\overline{f(u)}^t]^{n+\frac{1}{2}},\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\dfc(\frac{1}{2}(u^n + u^{n+1}))\nabla (\frac{1}{2}(u^n + u^{n+1}))
= \dfc(\overline{u}^t)\nabla \overline{u}^t]^{n+\frac{1}{2}},\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\frac{1}{2}(\dfc(u^n) + \dfc(u^{n+1}))\nabla (\frac{1}{2}(u^n + u^{n+1}))
= [\overline{\dfc(u)}^t\nabla\overline{u}^t]^{n+\frac{1}{2}},\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\frac{1}{2}(\dfc(u^n)\nabla u^n + \dfc(u^{n+1})\nabla u^{n+1})
= [\overline{\dfc(u)\nabla u}^t]^{n+\frac{1}{2}}\tp
\end{align*}
$$


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Solution of nonlinear equations  <a name="___sec66"></a></h2>

<ul>
 <p><li> Identify the \( F(u)=0 \) for the unknown \( u^{n+1} \)</li>
 <p><li> Apply Picard iteration or Newton's method to the PDE</li>
 <p><li> Identify the sequence of linearized PDEs and iterate</li>
</ul>


<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

