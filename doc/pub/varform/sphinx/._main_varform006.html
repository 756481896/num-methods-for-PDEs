
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Stationary variational forms" href="index.html" />
    <link rel="next" title="Variational formulations in 2D and 3D" href="._main_varform007.html" />
    <link rel="prev" title="Boundary conditions: specified derivative" href="._main_varform005.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_varform007.html" title="Variational formulations in 2D and 3D"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_varform005.html" title="Boundary conditions: specified derivative"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Stationary variational forms</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementation">
<span id="fem-deq-1d-code"></span><h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<p>At this point, it is sensible to create a
program with symbolic calculations to perform all the steps in the
computational machinery,
both for automating the work and for documenting the complete algorithms.
As we have seen, there are quite many details involved with
finite element computations and incorporation of boundary conditions.
An implementation will also act as a structured summary of all these details.</p>
<div class="section" id="global-basis-functions">
<span id="fem-deq-1d-code-global"></span><h2>Global basis functions<a class="headerlink" href="#global-basis-functions" title="Permalink to this headline">¶</a></h2>
<p>We first consider implementations when <span class="math">\({\psi}_i\)</span> are global functions
are hence different from zero on most of <span class="math">\(\Omega =[0,L]\)</span> so all integrals
need integration over the entire domain. (Finite element basis functions,
where we utilize their local support and perform integrations over
cells, will be treated later.) Since the expressions for
the entries in the linear system depend on the differential equation
problem being solved, the user must supply the necessary formulas via
Python functions. The implementations here attempt to perform symbolic
calculations, but fall back on numerical computations if the symbolic
ones fail.</p>
<p>The user must prepare a function
<code class="docutils literal"><span class="pre">integrand_lhs(psi,</span> <span class="pre">i,</span> <span class="pre">j)</span></code> for returning the integrand of the
integral that contributes to matrix entry <span class="math">\((i,j)\)</span>.
The <code class="docutils literal"><span class="pre">psi</span></code> variable is a Python dictionary holding the basis
functions and their derivatives in symbolic form. More precisely,
<code class="docutils literal"><span class="pre">psi[q]</span></code> is a list of</p>
<div class="math">
\[\{\frac{d^q{\psi}_0}{dx^q},\ldots,\frac{d^q{\psi}_{N_n-1}}{dx^q}\}
{\thinspace .}\]</div>
<p>Similarly, <code class="docutils literal"><span class="pre">integrand_rhs(psi,</span> <span class="pre">i)</span></code> returns the integrand
for entry number <span class="math">\(i\)</span> in the right-hand side vector.</p>
<p>Since we also have contributions to the right-hand side vector
(and potentially also the
matrix) from boundary terms without any integral, we introduce two
additional functions, <code class="docutils literal"><span class="pre">boundary_lhs(psi,</span> <span class="pre">i,</span> <span class="pre">j)</span></code> and
<code class="docutils literal"><span class="pre">boundary_rhs(psi,</span> <span class="pre">i)</span></code> for returning terms in the variational
formulation that are not to be integrated over the domain <span class="math">\(\Omega\)</span>.
Examples, to be shown later, will explain in more detail how these
user-supplied function may look like.</p>
<p>The linear system can be computed and solved symbolically by
the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
           <span class="n">boundary_lhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">boundary_rhs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">boundary_lhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>   <span class="c"># assume symmetry</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">boundary_rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>Not surprisingly, symbolic solution of differential
equations, discretized by a Galerkin or least squares method
with global basis functions,
is of limited interest beyond the simplest problems, because
symbolic integration might be very time consuming or impossible, not
only in <code class="docutils literal"><span class="pre">sympy</span></code> but also in
<a class="reference external" href="http://wolframalpha.com">WolframAlpha</a>
(which applies the perhaps most powerful symbolic integration
software available today: Mathematica). Numerical integration
as an option is therefore desirable.</p>
<p>The extended <code class="docutils literal"><span class="pre">solver</span></code> function below tries to combine symbolic and
numerical integration.  The latter can be enforced by the user, or it
can be invoked after a non-successful symbolic integration (being
detected by an <code class="docutils literal"><span class="pre">Integral</span></code> object as the result of the integration
in <code class="docutils literal"><span class="pre">sympy</span></code>).</p>
<p>Note that for a
numerical integration, symbolic expressions must be converted to
Python functions (using <code class="docutils literal"><span class="pre">lambdify</span></code>), and the expressions cannot contain
other symbols than <code class="docutils literal"><span class="pre">x</span></code>. The real <code class="docutils literal"><span class="pre">solver</span></code> routine in the
<a class="reference external" href="http://tinyurl.com/nm5587k/varform/varform1D.py">varform1D.py</a>
file has error checking and meaningful error messages in such cases.
The <code class="docutils literal"><span class="pre">solver</span></code> code below is a condensed version of the real one, with
the purpose of showing how to automate the Galerkin or least squares
method for solving differential equations in 1D with global basis functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
           <span class="n">boundary_lhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">boundary_rhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                    <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># force num.int. hereafter</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">boundary_lhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="n">symbolic</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">boundary_rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">boundary_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
</div>
<div class="section" id="example-constant-right-hand-side">
<h2>Example: constant right-hand side<a class="headerlink" href="#example-constant-right-hand-side" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate the code above, we address</p>
<div class="math">
\[-u''(x)=b,\quad x\in\Omega=[0,1],\quad u(0)=1,\ u(1)=0,\]</div>
<p>with <span class="math">\(b\)</span> as a (symbolic) constant. A possible basis for the space <span class="math">\(V\)</span>
is <span class="math">\({\psi}_i(x) = x^{i+1}(1-x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>. Note that
<span class="math">\({\psi}_i(0)={\psi}_i(1)=0\)</span> as required by the Dirichlet conditions.
We need a <span class="math">\(B(x)\)</span> function to take care of the known boundary
values of <span class="math">\(u\)</span>. Any function <span class="math">\(B(x)=1-x^p\)</span>, <span class="math">\(p\in\mathbb{R}\)</span>, is a candidate,
and one arbitrary choice from this family
is <span class="math">\(B(x)=1-x^3\)</span>. The unknown function is then written as</p>
<div class="math">
\[u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x){\thinspace .}\]</div>
<p>Let us use the Galerkin method to derive the variational formulation.
Multiplying the differential
equation by <span class="math">\(v\)</span> and integrating by parts yield</p>
<div class="math">
\[\int_0^1 u'v' {\, \mathrm{d}x} = \int_0^1 fv {\, \mathrm{d}x}\quad\forall v\in V,\]</div>
<p>and with <span class="math">\(u=B + \sum_jc_j{\psi}_j\)</span> we get the linear system</p>
<div class="math" id="eq-auto33">
\[\tag{81}
\sum_{j\in{\mathcal{I}_s}}\left(\int_0^1{\psi}_i'{\psi}_j' {\, \mathrm{d}x}\right)c_j =
    \int_0^1(f{\psi}_i-B'{\psi}_i') {\, \mathrm{d}x},
    \quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The application can be coded as follows with <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x b&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span>
<span class="n">dBdx</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c"># Compute basis functions and their derivatives</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]}</span>
<span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">psi_i</span> <span class="ow">in</span> <span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">integrand_lhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">integrand_rhs</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dBdx</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">varform1D</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="n">u_bar</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">integrand_lhs</span><span class="p">,</span> <span class="n">integrand_rhs</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">u_bar</span>
<span class="k">print</span> <span class="s">&#39;solution u:&#39;</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
</pre></div>
</div>
<p>The printout of <code class="docutils literal"><span class="pre">u</span></code> reads <code class="docutils literal"><span class="pre">-b*x**2/2</span> <span class="pre">+</span> <span class="pre">b*x/2</span> <span class="pre">-</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>.
Note that expanding <code class="docutils literal"><span class="pre">u</span></code>, before simplifying, is necessary
in the present case
to get a compact, final expression with <code class="docutils literal"><span class="pre">sympy</span></code>. Doing <code class="docutils literal"><span class="pre">expand</span></code> before
<code class="docutils literal"><span class="pre">simplify</span></code> is a common strategy for simplifying expressions in
<code class="docutils literal"><span class="pre">sympy</span></code>. However,
a non-expanded <code class="docutils literal"><span class="pre">u</span></code> might be preferable in other cases - this depends on
the problem in question.</p>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}(x)\)</span> can be derived by
some <code class="docutils literal"><span class="pre">sympy</span></code> code that closely follows the examples in
the section <a class="reference internal" href="._main_varform001.html#fem-deq-1d-models-simple"><span>Simple model problems and their solutions</span></a>. The idea is to integrate
<span class="math">\(-u''=b\)</span> twice and determine the integration constants from
the boundary conditions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C1 C2&#39;</span><span class="p">)</span>    <span class="c"># integration constants</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C2</span>
<span class="c"># Find C1 and C2 from the boundary conditions u(0)=0, u(1)=1</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">u_e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u_e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">])</span>
<span class="c"># Form the exact solution</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="o">-</span><span class="n">f2</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">C1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">C2</span><span class="p">]</span>
<span class="k">print</span> <span class="s">&#39;analytical solution:&#39;</span><span class="p">,</span> <span class="n">u_e</span>
<span class="k">print</span> <span class="s">&#39;error:&#39;</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">))</span>
</pre></div>
</div>
<p>The last line prints <code class="docutils literal"><span class="pre">0</span></code>, which is not surprising when
<span class="math">\({u_{\small\mbox{e}}}(x)\)</span> is a parabola and our approximate <span class="math">\(u\)</span> contains polynomials up to
degree 4. It suffices to have <span class="math">\(N=1\)</span>, i.e., polynomials of degree
2, to recover the exact solution.</p>
<p>We can play around with the code and test that with <span class="math">\(f=Kx^p\)</span>, for
some constants <span class="math">\(K\)</span> and <span class="math">\(p\)</span>,
the solution is a polynomial of degree <span class="math">\(p+2\)</span>, and <span class="math">\(N=p+1\)</span> guarantees
that the approximate solution is exact.</p>
<p>Although the symbolic code is capable of integrating many choices of <span class="math">\(f(x)\)</span>,
the symbolic expressions for <span class="math">\(u\)</span> quickly become lengthy and non-informative,
so numerical integration in the code, and hence numerical answers,
have the greatest application potential.</p>
</div>
<div class="section" id="finite-elements">
<span id="fem-deq-1d-code-fe"></span><h2>Finite elements<a class="headerlink" href="#finite-elements" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the finite element algorithms for differential
equations follows closely the algorithm for approximation of functions.
The new additional ingredients are</p>
<ol class="arabic simple">
<li>other types of integrands (as implied by the variational formulation)</li>
<li>additional boundary terms in the variational formulation for
Neumann boundary conditions</li>
<li>modification of element matrices and vectors due to Dirichlet
boundary conditions</li>
</ol>
<p>Point 1 and 2 can be taken care of by letting the user supply
functions defining the integrands and boundary terms on the
left- and right-hand side of the equation system:</p>
<blockquote>
<div><ul class="simple">
<li>Integrand on the left-hand side: <code class="docutils literal"><span class="pre">ilhs(e,</span> <span class="pre">phi,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">X,</span> <span class="pre">x,</span> <span class="pre">h)</span></code></li>
<li>Integrand on the right-hand side: <code class="docutils literal"><span class="pre">irhs(e,</span> <span class="pre">phi,</span> <span class="pre">r,</span> <span class="pre">X,</span> <span class="pre">x,</span> <span class="pre">h)</span></code></li>
<li>Boundary term on the left-hand side: <code class="docutils literal"><span class="pre">blhs</span> <span class="pre">(e,</span> <span class="pre">phi,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">X,</span> <span class="pre">x,</span> <span class="pre">h)</span></code></li>
<li>Boundary term on the right-hand side: <code class="docutils literal"><span class="pre">brhs</span> <span class="pre">(e,</span> <span class="pre">phi,</span> <span class="pre">r,</span> <span class="pre">s,</span> <span class="pre">X,</span> <span class="pre">x,</span> <span class="pre">h)</span></code></li>
</ul>
</div></blockquote>
<p>Here, <code class="docutils literal"><span class="pre">phi</span></code> is a dictionary where <code class="docutils literal"><span class="pre">phi[q]</span></code> holds a list of the
derivatives of order <code class="docutils literal"><span class="pre">q</span></code> of the basis functions with respect to the
physical coordinate <span class="math">\(x\)</span>.  The derivatives are available as Python
functions of <code class="docutils literal"><span class="pre">X</span></code>.  For example, <code class="docutils literal"><span class="pre">phi[0][r](X)</span></code> means <span class="math">\({\tilde{\varphi}}_r(X)\)</span>,
and <code class="docutils literal"><span class="pre">phi[1][s](X,</span> <span class="pre">h)</span></code> means <span class="math">\(d{\tilde{\varphi}}_s (X)/dx\)</span> (we refer to
the file <a class="reference external" href="http://tinyurl.com/nm5587k/varform/fe1D.py">fe1D.py</a> for details
regarding the function <code class="docutils literal"><span class="pre">basis</span></code> that computes the <code class="docutils literal"><span class="pre">phi</span></code>
dictionary).  The <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code>
arguments in the above functions correspond to the index in the
integrand contribution from an integration point to <span class="math">\(\tilde
A^{(e)}_{r,s}\)</span> and <span class="math">\(\tilde b^{(e)}_r\)</span>. The variables <code class="docutils literal"><span class="pre">e</span></code> and <code class="docutils literal"><span class="pre">h</span></code> are
the current element number and the length of the cell, respectively.
Specific examples below will make it clear how to construction these
Python functions.</p>
<p>Given a mesh represented by <code class="docutils literal"><span class="pre">vertices</span></code>, <code class="docutils literal"><span class="pre">cells</span></code>, and <code class="docutils literal"><span class="pre">dof_map</span></code> as
explained before, we can write a pseudo Python code to list all
the steps in the computational algorithm for finite element solution
of a differential equation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">Declare</span> <span class="k">global</span> <span class="n">matrix</span> <span class="ow">and</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">&gt;</span>

<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)):</span>

    <span class="c"># Compute element matrix and vector</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>  <span class="c"># no of dofs in this element</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="o">&lt;</span><span class="n">Initialize</span> <span class="n">element</span> <span class="n">matrix</span> <span class="ow">and</span> <span class="n">vector</span><span class="p">:</span> <span class="n">A_e</span><span class="p">,</span> <span class="n">b_e</span><span class="o">&gt;</span>

    <span class="c"># Integrate over the reference cell</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">numerical</span> <span class="n">integration</span> <span class="n">rule</span><span class="o">&gt;</span>
    <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">basis</span> <span class="n">functions</span> <span class="ow">and</span> <span class="n">derivatives</span> <span class="n">at</span> <span class="n">X</span><span class="o">&gt;</span>
        <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">detJ</span><span class="o">*</span><span class="n">w</span>

        <span class="n">x</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">affine</span> <span class="n">mapping</span> <span class="kn">from</span> <span class="nn">X</span><span class="o">&gt;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ilhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>
            <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">irhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>

    <span class="c"># Add boundary terms</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">blhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>
        <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">brhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>

    <span class="c"># Incorporate essential boundary conditions</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">global_dof</span> <span class="o">=</span> <span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">global_dof</span> <span class="ow">in</span> <span class="n">essbc</span><span class="p">:</span>
            <span class="c"># local dof r is subject to an essential condition</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">essbc</span><span class="p">[</span><span class="n">global_dof</span><span class="p">]</span>
            <span class="c"># Symmetric modification</span>
            <span class="n">b_e</span> <span class="o">-=</span> <span class="n">value</span><span class="o">*</span><span class="n">A_e</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">A_e</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># Assemble</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>

<span class="o">&lt;</span><span class="n">solve</span> <span class="n">linear</span> <span class="n">system</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>A complete function <code class="docutils literal"><span class="pre">finite_element1D_naive</span></code>
for the 1D finite algorithm above, is found in the file
<a class="reference external" href="http://tinyurl.com/nm5587k/varform/fe1D.py">fe1D.py</a>. The term &#8220;naive&#8221; refers
to a version of the algorithm where we use a standard dense square matrix
as global matrix <code class="docutils literal"><span class="pre">A</span></code>. The implementation also has a verbose mode for
printing out the element matrices and vectors as they are computed.
Below is the complete function without the print statements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">finite_element1D_naive</span><span class="p">(</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">dof_map</span><span class="p">,</span>     <span class="c"># mesh</span>
    <span class="n">essbc</span><span class="p">,</span>                        <span class="c"># essbc[globdof]=value</span>
    <span class="n">ilhs</span><span class="p">,</span>                         <span class="c"># integrand left-hand side</span>
    <span class="n">irhs</span><span class="p">,</span>                         <span class="c"># integrand right-hand side</span>
    <span class="n">blhs</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">brhs</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">intrule</span><span class="o">=</span><span class="s">&#39;GaussLegendre&#39;</span><span class="p">,</span>      <span class="c"># integration rule class</span>
    <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>                <span class="c"># print intermediate results?</span>
    <span class="p">):</span>
    <span class="n">N_e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="n">N_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dof_map</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="n">N_n</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_e</span><span class="p">):</span>
        <span class="n">Omega_e</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># Polynomial degree</span>
        <span class="c"># Compute all element basis functions and their derivatives</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c"># Element matrix and vector</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span>  <span class="c"># No of dofs per element</span>
        <span class="n">A_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">b_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c"># Integrate over the reference cell</span>
        <span class="k">if</span> <span class="n">intrule</span> <span class="o">==</span> <span class="s">&#39;GaussLegendre&#39;</span><span class="p">:</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">GaussLegendre</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">intrule</span> <span class="o">==</span> <span class="s">&#39;NewtonCotes&#39;</span><span class="p">:</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">NewtonCotes</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">X</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">affine_mapping</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">)</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="n">detJ</span><span class="o">*</span><span class="n">w</span>

            <span class="c"># Compute contribution to element matrix and vector</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ilhs</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>
                <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">irhs</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">dX</span>

        <span class="c"># Add boundary terms</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">blhs</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">brhs</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

        <span class="c"># Incorporate essential boundary conditions</span>
        <span class="n">modified</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">global_dof</span> <span class="o">=</span> <span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">global_dof</span> <span class="ow">in</span> <span class="n">essbc</span><span class="p">:</span>
                <span class="c"># dof r is subject to an essential condition</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">essbc</span><span class="p">[</span><span class="n">global_dof</span><span class="p">]</span>
                <span class="c"># Symmetric modification</span>
                <span class="n">b_e</span> <span class="o">-=</span> <span class="n">value</span><span class="o">*</span><span class="n">A_e</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span>
                <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">A_e</span><span class="p">[:,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">modified</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Assemble</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
            <span class="n">b</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">timing</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">timing</span></code> object is a dictionary holding the CPU spent on computing
<code class="docutils literal"><span class="pre">A</span></code> and the CPU time spent on solving the linear system. (We have
left out the timing statements.)</p>
</div>
<div class="section" id="utilizing-a-sparse-matrix">
<span id="fem-deq-1d-code-fe-sparse"></span><h2>Utilizing a sparse matrix<a class="headerlink" href="#utilizing-a-sparse-matrix" title="Permalink to this headline">¶</a></h2>
<p>A potential efficiency problem with the <code class="docutils literal"><span class="pre">finite_element1D_naive</span></code> function
is that it uses dense <span class="math">\((N+1)\times (N+1)\)</span> matrices, while we know that
only <span class="math">\(2d+1\)</span> diagonals around the main diagonal are different from zero.
Switching to a sparse matrix is very easy. Using the DOK (dictionary of
keys) format, we declare <code class="docutils literal"><span class="pre">A</span></code> as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">((</span><span class="n">N_n</span><span class="p">,</span> <span class="n">N_n</span><span class="p">))</span>
</pre></div>
</div>
<p>Assignments or in-place arithmetics are done as for a dense matrix,</p>
<div class="highlight-text"><div class="highlight"><pre>A[i,j] += term
A[i,j]  = term
</pre></div>
</div>
<p>but only the index pairs <code class="docutils literal"><span class="pre">(i,j)</span></code> we have used in assignments or
in-place arithmetics are actually stored.
A tailored solution algorithm is needed. The most reliable is
sparse Gaussian elimination:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="n">use_umfpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The declaration of <code class="docutils literal"><span class="pre">A</span></code> and the solve statement are the only
changes needed in the <code class="docutils literal"><span class="pre">finite_element1D_naive</span></code> to utilize
sparse matrices. The resulting modification is found in the
function <code class="docutils literal"><span class="pre">finite_element1D</span></code>.</p>
<div class="section" id="example-2">
<h3>Example<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h3>
<p>Let us demonstrate the finite element software on</p>
<div class="math">
\[-u''(x)=f(x),\quad x\in (0,L),\quad u'(0)=C,\ u(L)=D{\thinspace .}\]</div>
<p>This problem can be analytically solved by the
<code class="docutils literal"><span class="pre">model2</span></code> function from the section <a class="reference internal" href="._main_varform001.html#fem-deq-1d-models-simple"><span>Simple model problems and their solutions</span></a>.
Let <span class="math">\(f(x)=x^2\)</span>. Calling <code class="docutils literal"><span class="pre">model2(x**2,</span> <span class="pre">L,</span> <span class="pre">C,</span> <span class="pre">D)</span></code> gives</p>
<div class="math">
\[u(x) = D + C(x-L) + \frac{1}{12}(L^4 - x^4)\]</div>
<p>The variational formulation reads</p>
<div class="math">
\[(u', v) = (x^2, v) - Cv(0){\thinspace .}\]</div>
<p>The entries in the element matrix and vector,
which we need to set up the <code class="docutils literal"><span class="pre">ilhs</span></code>, <code class="docutils literal"><span class="pre">irhs</span></code>,
<code class="docutils literal"><span class="pre">blhs</span></code>, and <code class="docutils literal"><span class="pre">brhs</span></code> functions, becomes</p>
<div class="math">
\[\begin{split}A^{(e)}_{r,s} &amp;= \int_{-1}^1 \frac{d{\tilde{\varphi}}_r}{dx}\frac{{\tilde{\varphi}}_s}{dx}(\det J{\, \mathrm{d}X}),\\
b^{(e)} &amp;= \int_{-1}^1 x^2{\tilde{\varphi}}_r\det J{\, \mathrm{d}X} - C{\tilde{\varphi}}_r(-1)I(e,0),\end{split}\]</div>
<p>where <span class="math">\(I(e)\)</span> is an indicator function: <span class="math">\(I(e,q)=1\)</span> if <span class="math">\(e=q\)</span>, otherwise <span class="math">\(I(e)=0\)</span>.
We use this indicator function to formulate that the boundary term
<span class="math">\(Cv(0)\)</span>, which in the local element coordinate system becomes <span class="math">\(C{\tilde{\varphi}}_r(-1)\)</span>,
is only included for the element <span class="math">\(e=0\)</span>.</p>
<p>The functions for specifying the element matrix and vector entries
must contain the integrand, but without the <span class="math">\(\det J{\, \mathrm{d}X}\)</span> term, and
the derivatives <span class="math">\(d{\tilde{\varphi}}_r(X)/dx\)</span>
with respect to the physical <span class="math">\(x\)</span> coordinates are
contained in <code class="docutils literal"><span class="pre">phi[1][r](X)</span></code>, computed by the function <code class="docutils literal"><span class="pre">basis</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">ilhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">](</span><span class="n">X</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">](</span><span class="n">X</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">irhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">](</span><span class="n">X</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">blhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">brhs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">C</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">](</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</pre></div>
</div>
<p>We can then make the call to <code class="docutils literal"><span class="pre">finite_element1D_naive</span></code> or <code class="docutils literal"><span class="pre">finite_element1D</span></code>
to solve the problem with two P1 elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fe1D</span> <span class="kn">import</span> <span class="n">finite_element1D_naive</span><span class="p">,</span> <span class="n">mesh_uniform</span>
<span class="n">C</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>  <span class="n">D</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">L</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">vertices</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">dof_map</span> <span class="o">=</span> <span class="n">mesh_uniform</span><span class="p">(</span>
    <span class="n">N_e</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="p">],</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">essbc</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">essbc</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">D</span>

<span class="n">c</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">timing</span> <span class="o">=</span> <span class="n">finite_element1D</span><span class="p">(</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">dof_map</span><span class="p">,</span> <span class="n">essbc</span><span class="p">,</span>
    <span class="n">ilhs</span><span class="o">=</span><span class="n">ilhs</span><span class="p">,</span> <span class="n">irhs</span><span class="o">=</span><span class="n">irhs</span><span class="p">,</span> <span class="n">blhs</span><span class="o">=</span><span class="n">blhs</span><span class="p">,</span> <span class="n">brhs</span><span class="o">=</span><span class="n">brhs</span><span class="p">,</span>
    <span class="n">intrule</span><span class="o">=</span><span class="s">&#39;GaussLegendre&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It remains to plot the solution (with high resolution in each element).
To this end, we use the <code class="docutils literal"><span class="pre">u_glob</span></code> function imported from
<code class="docutils literal"><span class="pre">fe1D</span></code>, which imports it from <code class="docutils literal"><span class="pre">fe_approx1D_numit</span></code> (the
<code class="docutils literal"><span class="pre">u_glob</span></code> function in <code class="docutils literal"><span class="pre">fe_approx1D.py</span></code>
works with <code class="docutils literal"><span class="pre">elements</span></code> and <code class="docutils literal"><span class="pre">nodes</span></code>, while <code class="docutils literal"><span class="pre">u_glob</span></code> in
<code class="docutils literal"><span class="pre">fe_approx1D_numint</span></code> works with <code class="docutils literal"><span class="pre">cells</span></code>, <code class="docutils literal"><span class="pre">vertices</span></code>,
and <code class="docutils literal"><span class="pre">dof_map</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">D</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">fe1D</span> <span class="kn">import</span> <span class="n">u_glob</span>
<span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">u_glob</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">dof_map</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="k">print</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span>  <span class="c"># difference at the nodes</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;r--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;finite elements, d=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is shown in Figure <a class="reference internal" href="#fem-deq-1d-code-fe-fig1"><span>Finite element and exact solution using two cells</span></a>. We see
that the solution using P1 elements is exact at the nodes, but
feature considerable discrepancy between the nodes.
<a class="reference internal" href="._main_varform009.html#fem-deq-exer-1d-exact-numerics"><span>Exercise 10: Investigate exact finite element solutions</span></a> asks you to explore
this problem further using other <span class="math">\(m\)</span> and <span class="math">\(d\)</span> values.</p>
<div class="figure" id="id1">
<span id="fem-deq-1d-code-fe-fig1"></span><a class="reference internal image-reference" href="_images/uxx_x2.png"><img alt="_images/uxx_x2.png" src="_images/uxx_x2.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Finite element and exact solution using two cells</em></span></p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation</a><ul>
<li><a class="reference internal" href="#global-basis-functions">Global basis functions</a></li>
<li><a class="reference internal" href="#example-constant-right-hand-side">Example: constant right-hand side</a></li>
<li><a class="reference internal" href="#finite-elements">Finite elements</a></li>
<li><a class="reference internal" href="#utilizing-a-sparse-matrix">Utilizing a sparse matrix</a><ul>
<li><a class="reference internal" href="#example-2">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_varform005.html"
                        title="previous chapter">Boundary conditions: specified derivative</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_varform007.html"
                        title="next chapter">Variational formulations in 2D and 3D</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_varform006.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_varform007.html" title="Variational formulations in 2D and 3D"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_varform005.html" title="Boundary conditions: specified derivative"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Stationary variational forms</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>