<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Computing with variational forms">
<meta name="keywords" content="trial function,test function,trial space,test space,integration by parts">

<title>Study guide: Computing with variational forms</title>


<style type="text/css">
/* bloodish style */

body {
  font-family: Helvetica, Verdana, Arial, Sans-serif;
  color: #404040;
  background: #ffffff;
}
h1 { font-size: 1.8em;  color: #8A0808; }
h2 { font-size: 1.6em;  color: #8A0808; }
h3 { font-size: 1.4em;  color: #8A0808; }
h4 { color: #8A0808; }
a { color: #8A0808; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('We shall apply least squares, Galerkin/projection, and collocation to differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Abstract differential equation', 2, None, '___sec2'),
              ('Abstract boundary conditions', 2, None, '___sec3'),
              ('Reminder about notation', 2, None, '___sec4'),
              ('New topics: variational formulation and boundary conditions',
               2,
               None,
               '___sec5'),
              ('Residual-minimizing principles',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec7'),
              ('The Galerkin method', 2, None, '___sec8'),
              ('The Method of Weighted Residuals', 2, None, '___sec9'),
              ('New terminology: test and trial functions',
               2,
               None,
               '___sec10'),
              ('The collocation method', 2, None, '___sec11'),
              ('Examples on using the principles',
               1,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The first model problem', 2, None, '___sec13'),
              ('Boundary conditions', 2, None, '___sec14'),
              ('The least squares method; principle', 2, None, '___sec15'),
              ('The least squares method; equation system',
               2,
               None,
               '___sec16'),
              ('The least squares method; matrix and right-hand side expressions',
               2,
               None,
               '___sec17'),
              ('Orthogonality of the basis functions gives diagonal matrix',
               2,
               None,
               '___sec18'),
              ('Least squares method; solution', 2, None, '___sec19'),
              ('The Galerkin method; principle', 2, None, '___sec20'),
              ('The Galerkin method; solution', 2, None, '___sec21'),
              ('The collocation method', 2, None, '___sec22'),
              ('Comparison of the methods', 2, None, '___sec23'),
              ('Useful techniques', 1, None, '___sec24'),
              ('Integration by parts has many advantages',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('We use a boundary function to deal with non-zero Dirichlet boundary conditions',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Example on constructing a boundary function for two Dirichlet conditions',
               2,
               None,
               '___sec27'),
              ('Example on constructing a boundary function for one Dirichlet conditions',
               2,
               None,
               '___sec28'),
              ('With a $B(x)$, $u\\not\\in V$, but $\\sum_{j}c_j\\baspsi_j\\in V$',
               2,
               None,
               '___sec29'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Example on abstract notation', 2, None, '___sec31'),
              ('Bilinear and linear forms', 2, None, '___sec32'),
              ('The linear system associated with the abstract form',
               2,
               None,
               '___sec33'),
              ('Equivalence with minimization problem', 2, None, '___sec34'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient; problem', 2, None, '___sec36'),
              ('Variable coefficient; Galerkin principle',
               2,
               None,
               '___sec37'),
              ('Variable coefficient; integration by parts',
               2,
               None,
               '___sec38'),
              ('Variable coefficient; variational formulation',
               2,
               None,
               '___sec39'),
              ('Variable coefficient; linear system (the easy way)',
               2,
               None,
               '___sec40'),
              ('Variable coefficient; linear system (full derivation)',
               2,
               None,
               '___sec41'),
              ('First-order derivative in the equation and boundary condition; problem',
               2,
               None,
               '___sec42'),
              ('First-order derivative in the equation and boundary condition; details',
               2,
               None,
               '___sec43'),
              ('First-order derivative in the equation and boundary condition; observations',
               2,
               None,
               '___sec44'),
              ('First-order derivative in the equation and boundary condition; abstract notation (optional)',
               2,
               None,
               '___sec45'),
              ('First-order derivative in the equation and boundary condition; linear system',
               2,
               None,
               '___sec46'),
              ('Terminology: natural and essential boundary conditions',
               2,
               None,
               '___sec47'),
              ('Nonlinear coefficient; problem', 2, None, '___sec48'),
              ('Nonlinear coefficient; variational formulation',
               2,
               None,
               '___sec49'),
              ('Nonlinear coefficient; where does the nonlinearity cause challenges?',
               2,
               None,
               '___sec50'),
              ('Examples on detailed computations by hand',
               1,
               None,
               '___sec51'),
              ('Dirichlet and Neumann conditions; problem',
               2,
               None,
               '___sec52'),
              ('Dirichlet and Neumann conditions; linear system',
               2,
               None,
               '___sec53'),
              ('Dirichlet and Neumann conditions; integration',
               2,
               None,
               '___sec54'),
              ('Dirichlet and Neumann conditions; $2\\times 2$ system',
               2,
               None,
               '___sec55'),
              ('When is the numerical method is exact?', 2, None, '___sec56'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Variational formulation', 2, None, '___sec58'),
              ('How to deal with the boundary conditions?',
               2,
               None,
               '___sec59'),
              ('Computation in the global physical domain; formulas',
               2,
               None,
               '___sec60'),
              ('Computation in the global physical domain; details',
               2,
               None,
               '___sec61'),
              ('Computation in the global physical domain; linear system',
               2,
               None,
               '___sec62'),
              ('Write out the corresponding difference equation',
               2,
               None,
               '___sec63'),
              ('Comparison with a finite difference discretization',
               2,
               None,
               '___sec64'),
              ('Cellwise computations; formulas',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('Cellwise computations; details', 2, None, '___sec66'),
              ('Cellwise computations; details of boundary cells',
               2,
               None,
               '___sec67'),
              ('Cellwise computations; assembly', 2, None, '___sec68'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Explanation', 2, None, '___sec70'),
              ('Example with two *nonzero* Dirichlet values; variational formulation',
               2,
               'fem:deq:1D:essBC:ex',
               'fem:deq:1D:essBC:ex'),
              ('Example with two Dirichlet values; boundary function',
               2,
               None,
               '___sec72'),
              ('Example with two Dirichlet values; details',
               2,
               None,
               '___sec73'),
              ('Example with two Dirichlet values; cellwise computations',
               2,
               None,
               '___sec74'),
              ('Modification of the linear system; ideas',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Modification of the linear system; original system',
               2,
               None,
               '___sec76'),
              ('Modification of the linear system; row replacement',
               2,
               None,
               '___sec77'),
              ('Modification of the linear system; element matrix/vector',
               2,
               None,
               '___sec78'),
              ('Symmetric modification of the linear system; algorithm',
               2,
               None,
               '___sec79'),
              ('Symmetric modification of the linear system; example',
               2,
               None,
               '___sec80'),
              ('Symmetric modification of the linear system; element level',
               2,
               None,
               '___sec81'),
              ('Boundary conditions: specified derivative',
               2,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec83'),
              ('Method 1: Boundary function and exclusion of Dirichlet degrees of freedom',
               2,
               None,
               '___sec84'),
              ('Method 2: Use all $\\basphi_i$ and insert the Dirichlet condition in the linear system',
               2,
               None,
               '___sec85'),
              ('How the Neumann condition impacts the element matrix and vector',
               2,
               None,
               '___sec86'),
              ('The finite element algorithm', 2, None, '___sec87'),
              ('Python pseudo code; the element matrix and vector',
               2,
               None,
               '___sec88'),
              ('Python pseudo code; boundary conditions and assembly',
               2,
               None,
               '___sec89'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec91'),
              ('Example on integration by parts; problem',
               2,
               None,
               '___sec92'),
              ('Example on integration by parts in 1D/2D/3D',
               2,
               None,
               '___sec93'),
              ('Incorporation of the Neumann condition in the variational formulation',
               2,
               None,
               '___sec94'),
              ('Derivation of the linear system', 2, None, '___sec95'),
              ('Transformation to a reference cell in 2D/3D (1)',
               2,
               None,
               '___sec96'),
              ('Transformation to a reference cell in 2D/3D (2)',
               2,
               None,
               '___sec97'),
              ('Transformation to a reference cell in 2D/3D (3)',
               2,
               None,
               '___sec98'),
              ('Numerical integration', 2, None, '___sec99')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Computing with variational forms</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><h4>Sep 10, 2015</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#fem:deq:1D:principles"> Basic principles for approximating differential equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:models"> We shall apply least squares, Galerkin/projection, and collocation to differential equation models </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Abstract differential equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Abstract boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Reminder about notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> New topics: variational formulation and boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:residual:min"> Residual-minimizing principles </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> The least squares method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> The Galerkin method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> The Method of Weighted Residuals </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> New terminology: test and trial functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> The collocation method </a><br>
<a href="#fem:deq:1D:ex:sines"> Examples on using the principles </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> The first model problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> The least squares method; principle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> The least squares method; equation system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> The least squares method; matrix and right-hand side expressions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Orthogonality of the basis functions gives diagonal matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Least squares method; solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> The Galerkin method; principle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> The Galerkin method; solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> The collocation method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Comparison of the methods </a><br>
<a href="#___sec24"> Useful techniques </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:varform"> Integration by parts has many advantages </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:essBC:Bfunc"> We use a boundary function to deal with non-zero Dirichlet boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Example on constructing a boundary function for two Dirichlet conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Example on constructing a boundary function for one Dirichlet conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> With a \( B(x) \), \( u\not\in V \), but \( \sum_{j}c_j\baspsi_j\in V \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:varform:abstract"> Abstract notation for variational formulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Example on abstract notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Bilinear and linear forms </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> The linear system associated with the abstract form </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> Equivalence with minimization problem </a><br>
<a href="#fem:deq:1D:varform:ex"> Examples on variational formulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Variable coefficient; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> Variable coefficient; Galerkin principle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> Variable coefficient; integration by parts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> Variable coefficient; variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Variable coefficient; linear system (the easy way) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Variable coefficient; linear system (full derivation) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> First-order derivative in the equation and boundary condition; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> First-order derivative in the equation and boundary condition; details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> First-order derivative in the equation and boundary condition; observations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> First-order derivative in the equation and boundary condition; abstract notation (optional) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> First-order derivative in the equation and boundary condition; linear system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Terminology: natural and essential boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Nonlinear coefficient; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Nonlinear coefficient; variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Nonlinear coefficient; where does the nonlinearity cause challenges? </a><br>
<a href="#___sec51"> Examples on detailed computations by hand </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Dirichlet and Neumann conditions; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Dirichlet and Neumann conditions; linear system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Dirichlet and Neumann conditions; integration </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Dirichlet and Neumann conditions; \( 2\times 2 \) system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> When is the numerical method is exact? </a><br>
<a href="#fem:deq:1D:fem1"> Computing with finite elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec58"> Variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> How to deal with the boundary conditions? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Computation in the global physical domain; formulas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Computation in the global physical domain; details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Computation in the global physical domain; linear system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec63"> Write out the corresponding difference equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec64"> Comparison with a finite difference discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:comp:elmwise"> Cellwise computations; formulas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Cellwise computations; details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec67"> Cellwise computations; details of boundary cells </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec68"> Cellwise computations; assembly </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:essBC:Bfunc"> General construction of a boundary function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec70"> Explanation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:essBC:ex"> Example with two <em>nonzero</em> Dirichlet values; variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec72"> Example with two Dirichlet values; boundary function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec73"> Example with two Dirichlet values; details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec74"> Example with two Dirichlet values; cellwise computations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:fem:essBC:Bfunc:modsys"> Modification of the linear system; ideas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec76"> Modification of the linear system; original system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec77"> Modification of the linear system; row replacement </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec78"> Modification of the linear system; element matrix/vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec79"> Symmetric modification of the linear system; algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec80"> Symmetric modification of the linear system; example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec81"> Symmetric modification of the linear system; element level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:deq:1D:BC:nat"> Boundary conditions: specified derivative </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec83"> The variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec84"> Method 1: Boundary function and exclusion of Dirichlet degrees of freedom </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec85"> Method 2: Use all \( \basphi_i \) and insert the Dirichlet condition in the linear system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec86"> How the Neumann condition impacts the element matrix and vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec87"> The finite element algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec88"> Python pseudo code; the element matrix and vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec89"> Python pseudo code; boundary conditions and assembly </a><br>
<a href="#fem:deq:2D:varform"> Variational formulations in 2D and 3D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec91"> Integration by parts </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec92"> Example on integration by parts; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec93"> Example on integration by parts in 1D/2D/3D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec94"> Incorporation of the Neumann condition in the variational formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec95"> Derivation of the linear system </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec96"> Transformation to a reference cell in 2D/3D (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec97"> Transformation to a reference cell in 2D/3D (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec98"> Transformation to a reference cell in 2D/3D (3) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec99"> Numerical integration </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="fem:deq:1D:principles">Basic principles for approximating differential equations</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:models">We shall apply least squares, Galerkin/projection, and collocation to differential equation models</h2>

<p>
Our aim is to extend the ideas for approximating \( f \) by \( u \), or solving

$$ u = f $$

<p>
to real, <em>spatial</em> differential equations like

$$ -u'' + bu = f,\quad u(0)=C,\ u'(L)=D $$

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Emphasis will be on the Galerkin/projection method
</div>
<!-- end box -->


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Abstract differential equation </h2>

$$
\begin{equation*}
\mathcal{L}(u) = 0,\quad x\in\Omega  \end{equation*}
$$

<p>
Examples (1D problems):

$$
\begin{align*}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(x)\frac{du}{dx}\right) + f(x),\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) - au + f(x),\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) + f(u,x)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Abstract boundary conditions </h2>

$$
\begin{equation*}
\mathcal{B}_0(u)=0,\ x=0,\quad \mathcal{B}_1(u)=0,\ x=L
\end{equation*}
$$

<p>
Examples:

$$
\begin{align*}
\mathcal{B}_i(u) &= u - g,\quad &\hbox{Dirichlet condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - g,\quad &\hbox{Neumann condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - h(u-g),\quad &\hbox{Robin condition}
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Reminder about notation </h2>

<ul>
 <p><li> \( \uex(x) \) is the symbol for the <em>exact</em> solution
   of \( \mathcal{L}(\uex)=0 \) + \( \mathcal{B}_i=0 \)</li>
 <p><li> \( u(x) \) denotes an <em>approximate</em> solution</li>
 <p><li> \( V = \hbox{span}\{ \baspsi_0(x),\ldots,\baspsi_N(x)\} \), \( V \) has basis \( \sequencei{\baspsi} \)</li>
 <p><li> We seek \( u\in V \)</li>
 <p><li> \( \If =\{0,\ldots,N\} \) is an index set</li>
 <p><li> \( u(x) = \sum_{j\in\If} c_j\baspsi_j(x) \)</li>
 <p><li> Inner product: \( (u,v) = \int_\Omega uv\dx \)</li>
 <p><li> Norm: \( ||u||=\sqrt{(u,u)} \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec5">New topics: variational formulation and boundary conditions </h2>

<p>
Much is similar to approximating a function (solving \( u=f \)), but
two new topics are needed:

<ul>
 <p><li> Variational formulation of the differential equation problem
   (including integration by parts)</li>
 <p><li> Handling of boundary conditions</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:residual:min">Residual-minimizing principles</h2>

<ul>
 <p><li> When solving \( u=f \) we knew the error \( e=f-u \) and could
   use principles for minimizing the error</li>
 <p><li> When solving \( \mathcal{L}(\uex)=0 \) we do not know \( \uex \) and
   cannot work with the error \( e=\uex - u \)</li>
 <p><li> We can only know the <em>error in the equation</em>: the residual \( R \)</li>
</ul>

Inserting \( u=\sum_jc_j\baspsi_j \) in \( \mathcal{L}=0 \) gives
a residual \( R \)

$$
\begin{equation*}
\mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j) = R \neq 0
\end{equation*}
$$

<p>
Goal: minimize \( R \) with respect to \( \sequencei{c} \) (and hope it makes a small \( e \) too)

$$ R=R(c_0,\ldots,c_N; x)$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">The least squares method </h2>

<p>
Idea: minimize

$$
\begin{equation*}
E = ||R||^2 = (R,R) = \int_{\Omega} R^2 dx
\end{equation*}
$$

<p>
Minimization wrt \( \sequencei{c} \) implies

$$
\frac{\partial E}{\partial c_i} =
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If
$$

<p>
\( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">The Galerkin method </h2>

<p>
Idea: make \( R \) orthogonal to \( V \),

$$
(R,v)=0,\quad \forall v\in V
$$

<p>
This implies

$$
(R,\baspsi_i)=0,\quad i\in\If
$$

<p>
\( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec9">The Method of Weighted Residuals </h2>

<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

$$
(R,v)=0,\quad \forall v\in W
$$

<p>
If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \):

$$
(R,w_i)=0,\quad i\in\If
$$


<ul>
 <p><li> \( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)</li>
 <p><li> Weighted residual with \( w_i = \partial R/\partial c_i \) gives
   least squares</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec10">New terminology: test and trial functions </h2>

<ul>
 <p><li> \( \baspsi_j \) used in \( \sum_jc_j\baspsi_j \) is called <em>trial function</em></li>
 <p><li> \( \baspsi_i \) or \( w_i \) used as weight in Galerkin's method is called <em>test function</em></li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">The collocation method </h2>

<p>
Idea: demand \( R=0 \) at \( N+1 \) points in space

$$ R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If$$

<p>
The collocation method is a weighted residual method with
delta functions as weights

$$ 0 = \int_\Omega R(x;c_0,\ldots,c_N)
\delta(x-\xno{i})\dx = R(\xno{i}; c_0,\ldots,c_N)$$


$$
\hbox{property of } \delta(x):\quad
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega
$$

<p>
<center><p><img src="fig-varform/delta_func_weight.png" align="bottom" width=200></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="fem:deq:1D:ex:sines">Examples on using the principles</h1>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Goal.</b>
<p>
Exemplify the least squares, Galerkin, and collocation methods
in a simple 1D problem with global basis functions.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">The first model problem </h2>

$$ -u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0$$

<p>
Basis functions:

$$ \baspsi_i(x) = \sinL{i},\quad i\in\If$$

<p>
Residual:

$$
\begin{align*}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= -\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Boundary conditions </h2>

<p>
Since \( u(0)=u(L)=0 \) we must ensure that
all \( \baspsi_i(0)=\baspsi_i(L)=0 \), because then

$$ u(0) = \sum_jc_j{\color{red}\baspsi_j(0)} = 0,\quad
u(L) = \sum_jc_j{\color{red}\baspsi_j(L)} =0 $$


<ul>
 <p><li> \( u \) known: Dirichlet boundary condition</li>
 <p><li> \( u' \) known: Neumann boundary condition</li>
 <p><li> Must have \( \baspsi_i=0 \) where Dirichlet conditions apply</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec15">The least squares method; principle </h2>

$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i\in\If
$$


$$
\begin{equation*}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \baspsi_i''(x)
\end{equation*}
$$

<p>
Because:
$$
\frac{\partial}{\partial c_i}\left(c_0\baspsi_0'' + c_1\baspsi_1'' + \cdots +
c_{i-1}\baspsi_{i-1}'' + {\color{red}c_i\baspsi_{i}''} + c_{i+1}\baspsi_{i+1}''
+ \cdots + c_N\baspsi_N'' \right) = \baspsi_{i}''
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">The least squares method; equation system </h2>

$$
\begin{equation*}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If
\end{equation*}
$$

<p>
Rearrangement:

$$
\begin{equation*}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If  \end{equation*}
$$

<p>
This is a linear system

$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec17">The least squares method; matrix and right-hand side expressions </h2>

$$
\begin{align*}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">Orthogonality of the basis functions gives diagonal matrix </h2>

<p>
Useful property of the chosen basis functions:

$$
\begin{equation*}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \delta_{ij},\quad
\quad\delta_{ij} = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation*}
$$

<p>
\( \Rightarrow\ (\baspsi_i'',\baspsi_j'') = \delta_{ij} \), i.e.,
diagonal \( A_{i,j} \), and we can easily solve for \( c_i \):

$$
\begin{equation*}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">Least squares method; solution </h2>

<p>
Let <code>sympy</code> do the work (\( f(x)=2 \)):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

i, j <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;i j&#39;</span>, integer<span style="color: #666666">=</span><span style="color: #008000">True</span>)
x, L <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;x L&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">2</span>
a <span style="color: #666666">=</span> <span style="color: #666666">2*</span>L<span style="color: #666666">/</span>(pi<span style="color: #666666">**2*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">**2</span>)
c_i <span style="color: #666666">=</span> a<span style="color: #666666">*</span>integrate(f<span style="color: #666666">*</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L), (x, <span style="color: #666666">0</span>, L))
c_i <span style="color: #666666">=</span> simplify(c_i)
<span style="color: #008000; font-weight: bold">print</span> c_i
</pre></div>
$$
\begin{equation*}
c_i = 4 \frac{L^{2} \left(\left(-1\right)^{i} + 1\right)}{\pi^{3}
\left(i^{3} + 3 i^{2} + 3 i + 1\right)},\quad
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}
\end{equation*}
$$

<p>
Fast decay: \( c_2 = c_0/27 \), \( c_4=c_0/125 \) - only one term might be good enough:

$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right) \end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec20">The Galerkin method; principle </h2>

<p>
\( R=u''+f \):

$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$

or rearranged,

$$
\begin{equation*}
(u'',v) = -(f,v),\quad\forall v\in V  \end{equation*}
$$

<p>
This is a <em>variational formulation</em> of the differential equation problem.

<p>
\( \forall v\in V \) is equivalent with \( \forall v\in\baspsi_i \), \( i\in\If \),
resulting in

$$
\begin{equation*}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If  \end{equation*}
$$


$$
\begin{equation*}
\sum_{j\in\If}(\baspsi_j'', \baspsi_i) c_j=-(f,\baspsi_i),\quad i\in\If  \end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">The Galerkin method; solution </h2>

<p>
Since \( \baspsi_i''\propto -\baspsi_i \),
Galerkin's method gives the same linear system and the same solution
as the least squares method (in this particular example).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">The collocation method </h2>

<p>
\( R=0 \) (i.e.,the differential equation) must be satisfied at \( N+1 \) points:

$$
\begin{equation*}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If
\end{equation*}
$$

<p>
This is a linear system \( \sum_j A_{i,j}=b_i \) with entries

$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),
\quad b_i=2
\end{equation*}
$$

<p>
Choose: \( N=0 \), \( x_0=L/2 \)

$$ c_0=2L^2/\pi^2 $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec23">Comparison of the methods </h2>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)</li>
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)</li>
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).</li>
</ul>

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Computing with Dirichlet conditions: -u&#39;&#39;=2 and sines</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, L <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x L&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> e_Galerkin <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x) <span style="color: #666666">-</span> <span style="color: #666666">8*</span>L<span style="color: #666666">**2*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">**</span>(<span style="color: #666666">-3</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L)
<span style="color: #666666">&gt;&gt;&gt;</span> e_colloc <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x) <span style="color: #666666">-</span> <span style="color: #666666">2*</span>L<span style="color: #666666">**2*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">**</span>(<span style="color: #666666">-2</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L)

<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Verify max error for x=L/2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_Galerkin <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(e_Galerkin, x)
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_Galerkin<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)
<span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_colloc <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(e_colloc, x)
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_colloc<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)
<span style="color: #666666">0</span>

<span style="color: #408080; font-style: italic"># Compute max error: x=L/2, evaluate numerical, and simplify</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sym<span style="color: #666666">.</span>simplify(e_Galerkin<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)<span style="color: #666666">.</span>evalf(n<span style="color: #666666">=3</span>))
<span style="color: #666666">-0.00812*</span>L<span style="color: #666666">**2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sym<span style="color: #666666">.</span>simplify(e_colloc<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)<span style="color: #666666">.</span>evalf(n<span style="color: #666666">=3</span>))
<span style="color: #666666">0.0473*</span>L<span style="color: #666666">**2</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec24">Useful techniques </h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:varform">Integration by parts has many advantages</h2>

<p>
Second-order derivatives will hereafter be integrated by parts

$$
\begin{align*}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)
\end{align*}
$$

<p>
Motivation:

<ul>
 <p><li> Lowers the order of derivatives</li>
 <p><li> Gives more symmetric forms (incl. matrices)</li>
 <p><li> Enables easy handling of Neumann boundary conditions</li>
 <p><li> Finite element basis functions \( \basphi_i \) have discontinuous
   derivatives (at cell boundaries) and are not suited for
   terms with \( \basphi_i'' \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">We use a boundary function to deal with non-zero Dirichlet boundary conditions </h2>
<div id="fem:deq:1D:essBC:Bfunc"></div>

<ul>
 <p><li> What about nonzero Dirichlet conditions? Say \( u(L)=D \)</li>
 <p><li> We always require \( \baspsi_i(L)=0 \) (i.e., \( \baspsi_i=0 \) where Dirichlet conditions applies)</li>
 <p><li> Problem: \( u(L) = \sum_j c_j\baspsi_j(L)=\sum_j c_j\cdot 0=0\neq D \) - always!</li>
 <p><li> Solution: \( u(x) = B(x) + \sum_j c_j\baspsi_j(x) \)</li>
 <p><li> \( B(x) \): user-constructed boundary function that fulfills the Dirichlet
   conditions</li>
 <p><li> If \( u(L)=D \), make sure \( B(L)=D \)</li>
 <p><li> No restrictions of how \( B(x) \) varies in the interior of \( \Omega \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Example on constructing a boundary function for two Dirichlet conditions </h2>

<p>
Dirichlet conditions: \( u(0)=C \) and \( u(L)=D \). Choose for example

$$ B(x) = \frac{1}{L}(C(L-x) + Dx):\qquad B(0)=C,\ B(L)=D  $$


$$
\begin{equation*}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
\end{equation*}
$$


$$ u(0) = B(0)= C,\quad u(L) = B(L) = D $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Example on constructing a boundary function for one Dirichlet conditions </h2>

<p>
Dirichlet condition: \( u(L)=D \). Choose for example

$$ B(x) = D:\qquad B(L)=D  $$


$$
\begin{equation*}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
\end{equation*}
$$


$$ u(L) = B(L) = D $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec29">With a \( B(x) \), \( u\not\in V \), but \( \sum_{j}c_j\baspsi_j\in V \) </h2>

<ul>
 <p><li> \( \sequencei{\baspsi} \) is a basis for \( V \)</li>
 <p><li> \( \sum_{j\in\If}c_j\baspsi_j(x)\in V \)</li>
 <p><li> But \( u\not\in V \)!</li>
 <p><li> Reason: say \( u(0)=C \) and \( u\in V \); any \( v\in V \) has \( v(0)=C \), then
   \( 2u\not\in V \) because \( 2u(0)=2C \) (wrong value)</li>
 <p><li> When \( u(x) = B(x) + \sum_{j\in\If}c_j\baspsi_j(x) \),
   \( B\not\in V \) (in general) and
   \( u\not\in V \), but \( (u-B)\in V \) since \( \sum_{j}c_j\baspsi_j\in V \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:varform:abstract">Abstract notation for variational formulations</h2>

<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Find \( (u-B)\in V \) such that

$$ a(u,v) = L(v)\quad \forall v\in V $$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec31">Example on abstract notation </h2>

$$ -u''=f, \quad u'(0)=C,\ u(L)=D,\quad u=D + \sum_jc_j\baspsi_j$$

<p>
Variational formulation:

$$
\int_{\Omega} u' v'dx = \int_{\Omega} fvdx - v(0)C
\quad\hbox{or}\quad (u',v') = (f,v) - v(0)C
\quad\forall v\in V
$$

<p>
Abstract formulation: find \( (u-B)\in V \) such that

$$ a(u,v) = L(v)\quad \forall v\in V$$

<p>
We identify

$$ a(u,v) = (u',v'),\quad L(v) = (f,v) -v(0)C  $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec32">Bilinear and linear forms </h2>

<ul>
 <p><li> \( a(u,v) \) is a <em>bilinear form</em></li>
 <p><li> \( L(v) \) is a <em>linear form</em></li>
</ul>

Linear form means

$$ L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2),
$$

<p>
Bilinear form means
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\end{align*}
$$

<p>
In nonlinear problems: Find \( (u-B)\in V \) such that \( F(u;v)=0\ \forall v\in V \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec33">The linear system associated with the abstract form </h2>

$$ a(u,v) = L(v)\quad \forall v\in V\quad\Leftrightarrow\quad
a(u,\baspsi_i) = L(\baspsi_i)\quad i\in\If$$

<p>
We can now derive the corresponding linear system once and for all by inserting \( u = B + \sum_jc_j\baspsi_j \):

$$  a(B + \sum_{j\in\If} c_j \baspsi_j,\baspsi_i)c_j = L(\baspsi_i)\quad i\in\If$$

<p>
Because of linearity,

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
$$ \sum_{j\in\If} \underbrace{a(\baspsi_j,\baspsi_i)}_{A_{i,j}}c_j =
\underbrace{L(\baspsi_i) - a(B,\baspsi_i)}_{b_i}\quad i\in\If$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec34">Equivalence with minimization problem </h2>

<p>
If \( a \) is symmetric: \( a(u,v)=a(v,u) \),

$$ a(u,v)=L(v)\quad\forall v\in V$$

<p>
is equivalent to minimizing the functional

$$ F(v) = {\half}a(v,v) - L(v) $$

over all functions \( v\in V \). That is,

$$ F(u)\leq F(v)\quad \forall v\in V $$


<ul>
 <p><li> Much used in the early days of finite elements</li>
 <p><li> Still much used in structural analysis and elasticity</li>
 <p><li> Not as general as Galerkin's method (since we require \( a(u,v)=a(v,u) \))</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="fem:deq:1D:varform:ex">Examples on variational formulations</h1>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Goal.</b>
<p>
Derive variational formulations for some prototype differential
equations in 1D that include

<ul>
 <p><li> variable coefficients</li>
 <p><li> mixed Dirichlet and Neumann conditions</li>
 <p><li> nonlinear coefficients</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Variable coefficient; problem </h2>

$$
\begin{equation*}
-\frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D
\end{equation*}
$$


<ul>
 <p><li> Variable coefficient \( \dfc(x) \)</li>
 <p><li> \( V = \hbox{span}\{\baspsi_0,\ldots,\baspsi_N\} \)</li>
 <p><li> <em>Nonzero</em> Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)</li>
 <p><li> Must have \( \baspsi_i(0)=\baspsi_i(L)=0 \)</li>
 <p><li> Any \( v\in V \) has then \( v(0)=v(L)=0 \)</li>
 <p><li> \( B(x) = C + \frac{1}{L}(D-C)x \)</li>
</ul>

$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x),\quad
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec37">Variable coefficient; Galerkin principle </h2>

$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f $$

<p>
Galerkin's method:

$$
(R, v) = 0,\quad \forall v\in V
$$

<p>
or with integrals:

$$
\int_{\Omega} \left(-\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\right)v \dx = 0,\quad \forall v\in V
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec38">Variable coefficient; integration by parts </h2>

$$ -\int_{\Omega} \frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) v \dx
= \int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx -
\left[\dfc\frac{du}{dx}v\right]_0^L
$$

<p>
Boundary terms vanish since \( v(0)=v(L)=0 \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec39">Variable coefficient; variational formulation </h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Variational formulation.</b>
<p>

<p>
Find \( (u-B)\in V \) such that

$$
\int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V
$$

<p>
Compact notation:

$$ \underbrace{(\dfc u',v')}_{a(u,v)} = \underbrace{(f,v)}_{L(v)},
\quad \forall v\in V $$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec40">Variable coefficient; linear system (the easy way) </h2>

<p>
With

$$ a(u,v) = (\dfc u', v'),\quad L(v) = (f,v) $$

<p>
we can just use the formula for the linear system:

$$
\begin{align*}
A_{i,j} &= a(\baspsi_j,\baspsi_i) = (\dfc \baspsi_j', \baspsi_i')
= \int_\Omega \dfc \baspsi_j' \baspsi_i'\dx =
\int_\Omega \baspsi_i' \dfc \baspsi_j'\dx \quad (= a(\baspsi_i,\baspsi_j) = A_{j,i}\\ 
b_i &= (f,\baspsi_i) - (\dfc B',\baspsi_i) = \int_\Omega (f\baspsi_i -
\dfc L^{-1}(D-C)\baspsi_i')\dx
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec41">Variable coefficient; linear system (full derivation) </h2>

<p>
\( v=\baspsi_i \) and \( u=B + \sum_jc_j\baspsi_j \):

$$
(\dfc B' + \dfc \sum_{j\in\If} c_j \baspsi_j', \baspsi_i') =
(f,\baspsi_i), \quad i\in\If
$$

<p>
Reorder to form linear system:

$$ \sum_{j\in\If} (\dfc\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (aL^{-1}(D-C), \baspsi_i'), \quad i\in\If
$$

<p>
This is \( \sum_j A_{i,j}c_j=b_i \) with

$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} \dfc(x)\baspsi_j'(x)
\baspsi_i'(x)\dx\\ 
b_i &= (f,\baspsi_i) + (aL^{-1}(D-C),\baspsi_i')=
\int_{\Omega} \left(f\baspsi_i + \dfc\frac{D-C}{L}\baspsi_i'\right) \dx
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec42">First-order derivative in the equation and boundary condition; problem </h2>

$$
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E
$$

<p>
New features:

<ul>
 <p><li> first-order derivative \( u' \) in the equation</li>
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)</li>
</ul>

Initial steps:

<ul>
 <p><li> Must force \( \baspsi_i(0)=0 \) because of Dirichlet condition at \( x=0 \)</li>
 <p><li> Boundary function: \( B(x)=C(L-x) \) or just \( B(x)=C \)</li>
 <p><li> No requirements on \( \baspsi_i(L) \) (no Dirichlet condition at \( x=L \))</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec43">First-order derivative in the equation and boundary condition; details </h2>

$$ u = C + \sum_{j\in\If} c_j \baspsi_i(x)$$

<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V$$


$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V$$

<p>
\( [u' v]_0^L = u'(L)v(L) - u'(0)v(0)= E v(L) \) since \( v(0)=0 \) and \( u'(L)=E \)

$$ (u',v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec44">First-order derivative in the equation and boundary condition; observations </h2>

$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V$$

<p>
Important observations:

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions</li>
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \) (!)</li>
  <p><li> Such conditions are called <em>natural boundary conditions</em></li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec45">First-order derivative in the equation and boundary condition; abstract notation (optional) </h2>

<p>
Abstract notation:

$$ a(u,v)=L(v)\quad\forall v\in V$$

<p>
With

$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V$$

<p>
we have

$$
\begin{align*}
a(u,v)&=(u',v') + (bu',v)\\ 
L(v)&= (f,v) + E v(L)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec46">First-order derivative in the equation and boundary condition; linear system </h2>

<p>
Insert \( u=C+\sum_jc_j\baspsi_j \) and \( v=\baspsi_i \) in

$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V$$

and manipulate to get

$$
\sum_{j\in\If}
\underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}}
c_j =
\underbrace{(f,\baspsi_i) + E \baspsi_i(L)}_{b_i},\quad i\in\If
$$

<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_jdx = (\baspsi_i',b\baspsi_j)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Terminology: natural and essential boundary conditions </h2>

$$ (u',v') + (bu',v) = (f,v) + u'(L)v(L) - u'(0)v(0)$$


<ul>
 <p><li> Note: forgetting the boundary terms implies \( u'(L)=u'(0)=0 \)
   (unless prescribe a Dirichlet condition)</li>
 <p><li> Conditions on \( u' \) are simply inserted in the variational form
   and called <em>natural conditions</em></li>
 <p><li> Conditions on \( u \) at \( x=0 \) requires modifying \( V \) (through \( \baspsi_i(0)=0 \))
   and are known as <em>essential conditions</em></li>
</ul>

<div class="alert alert-block alert-notice alert-text-normal">
<b>Lesson learned.</b>
<p>
It is easy to forget the boundary term when integrating by parts.
That mistake may prescribe a condition on \( u' \)!
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Nonlinear coefficient; problem </h2>

<p>
Problem:

$$
\begin{equation*}
-(\dfc(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\end{equation*}
$$


<ul>
 <p><li> \( V \): basis \( \sequencei{\baspsi} \) with \( \baspsi_i(0)=0 \) because of \( u(0)=0 \)</li>
 <p><li> How does the nonlinear coefficients \( \dfc(u) \) and \( f(u) \)
   impact the variational formulation? <br />
   (Not much!)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec49">Nonlinear coefficient; variational formulation </h2>

<p>
Galerkin: multiply by \( v \), integrate, integrate by parts

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + [\dfc(u)vu']_0^L\quad\forall v\in V
$$


<ul>
 <p><li> \( \dfc(u(0))v(0)u'(0)=0 \) since \( v(0) \)</li>
 <p><li> \( \dfc(u(L))v(L)u'(L) = \dfc(u(L))v(L)E \) since \( u'(L)=E \)</li>
</ul>

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}v\dx =
\int_0^L f(u)v\dx + \dfc(u(L))v(L)E\quad\forall v\in V
$$

<p>
or

$$ (\dfc(u)u', v') = (f(u),v) + \dfc(u(L))v(L)E\quad\forall v\in V
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec50">Nonlinear coefficient; where does the nonlinearity cause challenges? </h2>

<ul>
 <p><li> Abstract notation: no \( a(u,v) \) and \( L(v) \) because \( a \) and \( L \) get nonlinear</li>
 <p><li> Abstract notation for nonlinear problems: \( F(u;v)=0\ \forall v\in V \)</li>
 <p><li> What about forming a linear system? We get a <em>nonlinear</em> system of
   algebraic equations</li>
 <p><li> Must use methods like Picard iteration or Newton's method to solve
   nonlinear algebraic equations</li>
 <p><li> But: the variational formulation was not much affected by nonlinearities</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec51">Examples on detailed computations by hand </h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec52">Dirichlet and Neumann conditions; problem </h2>

$$
\begin{equation*}
-u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D
\end{equation*}
$$


<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \baspsi_i\sim x^i \) on \( [0,1] \)</li>
 <p><li> Because of \( u(1)=D \): \( \baspsi_i(1)=0 \)</li>
 <p><li> Basis: \( \baspsi_i(x)=(1-x)^{i+1},\quad i\in\If \)</li>
 <p><li> Boundary function: \( B(x)=Dx \)</li>
 <p><li> \( u(x) = B(x) + \sum_{j\in\If}c_j\basphi_j = Dx + \sum_{j\in\If} c_j(1-x)^{i+1} \)</li>
</ul>

Variational formulation: find \( (u-B)\in V \) such that

$$
(u,\baspsi_i') = (f,\baspsi_i)-(B',\baspsi_i) - C\baspsi_i(0),\ i\in\If
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec53">Dirichlet and Neumann conditions; linear system </h2>

<p>
Insert \( u(x) = B(x) + \sum_{j\in\If}c_j\basphi_j \) and derive

$$ \sum_{j\in\If} A_{i,j}c_j = b_i,\quad i\in\If$$

<p>
with

$$ A_{i,j} = (\baspsi_j',\baspsi_i')
$$

$$ b_i = (f,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0) $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Dirichlet and Neumann conditions; integration </h2>

$$ A_{i,j} = (\baspsi_j',\baspsi_i') = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j} dx
$$

<p>
Choose \( f(x)=2 \):

$$
\begin{align*}
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\baspsi_i(0)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec55">Dirichlet and Neumann conditions; \( 2\times 2 \) system </h2>

<p>
Can easily do the integrals with <code>sympy</code>. \( N=1 \) and \( \If = \{0,1\} \):

$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$


$$ c_0=-C+D+2, \quad c_1=-1,$$


$$ u(x) = 1 -x^2 + D + C(x-1)\quad\hbox{(exact solution)} $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec56">When is the numerical method is exact? </h2>

<p>
Assume that apart from boundary conditions,
\( \uex \) lies in the same space \( V \) as where we seek \( u \):

$$
\begin{align*}
u &= B + {\color{red}F},\quad F\in V\\ 
a(B+F, v) &= L(v),\quad\forall v\in V\\ 
\uex & = B + {\color{red}E},\quad E\in V\\ 
a(B+E, v) &= L(v),\quad\forall v\in V
\end{align*}
$$

<p>
Subtract: \( a(F-E,v)=0\ \Rightarrow\ E=F \) and \( u = \uex \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="fem:deq:1D:fem1">Computing with finite elements</h1>

<p>
Tasks:

<ul>
 <p><li> Address the model problem \( -u''(x)=2 \), \( u(0)=u(L)=0 \)</li>
 <p><li> Uniform finite element mesh with P1 elements</li>
 <p><li> Show all finite element computations in detail</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Variational formulation </h2>

$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$

<p>
Variational formulation:

$$ (u',v') = (2,v)\quad\forall v\in V  $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec59">How to deal with the boundary conditions? </h2>

<p>
Since \( u(0)=0 \) and \( u(L)=0 \), we must force

$$ v(0)=v(L)=0,\quad \baspsi_i(0)=\baspsi_i(L)=0$$

<p>
Let's choose the obvious finite element basis: \( \baspsi_i=\basphi_i \), \( i=0,\ldots,N_n-1 \)

<p>
Problem: \( \basphi_0(0)\neq 0 \) and \( \basphi_{N_n-1}(L)\neq 0 \)

<p>
Solution: we just exclude \( \basphi_0 \) and \( \basphi_{N_n-1} \)
from the basis and work with

$$ \baspsi_i=\basphi_{i+1},\quad i=0,\ldots,N=N_n-3$$

<p>
Introduce index mapping \( \nu(i) \): \( \baspsi_i = \basphi_{\nu(i)} \)

$$ u = \sum_{j\in\If}c_j\basphi_{\nu(j)},\quad i=0,\ldots,N,\quad \nu(j) = j+1$$

<p>
Irregular numbering: more complicated \( \nu(j) \) table

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec60">Computation in the global physical domain; formulas </h2>

$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_{i+1}'(x)\basphi_{j+1}'(x) dx,\quad
b_i=\int_0^L2\basphi_{i+1}(x) dx
\end{equation*}
$$

<p>
Many will prefer to change indices to obtain a
\( \basphi_i'\basphi_j' \) product: \( i+1\rightarrow i \), \( j+1\rightarrow j \)

$$
\begin{equation*}
A_{i-1,j-1}=\int_0^L\basphi_{i}'(x)\basphi_{j}'(x) \dx,\quad
b_{i-1}=\int_0^L2\basphi_{i}(x) \dx
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec61">Computation in the global physical domain; details </h2>

<p>
<center><p><img src="fig-varform/fe_mesh1D_dphi_2_3.png" align="bottom" width=500></p></center>

$$ \basphi_i' \sim \pm h^{-1} $$


$$ A_{i-1,i-1} = h^{-2}2h = 2h^{-1},\quad
A_{i-1,i-2} = h^{-1}(-h^{-1})h = -h^{-1}$$

and \( A_{i-1,i}=A_{i-1,i-2} \)

$$ b_{i-1} = 2({\half}h + {\half}h) = 2h$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec62">Computation in the global physical domain; linear system </h2>

$$
\begin{equation*}

\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)

\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec63">Write out the corresponding difference equation </h2>

<p>
General equation at node \( i \):

$$
-\frac{1}{h}c_{i-1} + \frac{2}{h}c_{i} - \frac{1}{h}c_{i+1} = 2h
$$

<p>
Now, \( c_i = u(\xno{i+1})\equiv u_{i+1} \). Writing out the equation
at node \( i-1 \),

$$
-\frac{1}{h}c_{i-2} + \frac{2}{h}c_{i-1} - \frac{1}{h}c_{i} = 2h
$$

<p>
translates directly to

$$
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec64">Comparison with a finite difference discretization </h2>

<p>
The standard finite difference method for \( -u''=2 \) is

$$ -\frac{1}{h^2}u_{i-1} + \frac{2}{h^2}u_{i} - \frac{1}{h^2}u_{i+1} = 2 $$

<p>
Multiply by \( h \)!

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The finite element method and the finite difference method are
identical <em>in this example</em>.
</div>


<p>
(Remains to study the equations at the end points, which involve
boundary values - but these are also the same for the two methods)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:comp:elmwise">Cellwise computations; formulas</h2>

<ul>
 <p><li> Repeat the previous example, but apply the cellwise algorithm</li>
 <p><li> Work with one cell at a time</li>
 <p><li> Transform physical cell to reference cell \( X\in [-1,1] \)</li>
</ul>

$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} \dX,
\end{equation*}
$$


$$ \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X)$$


$$ \frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half $$

<p>
From the chain rule

$$ \frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec66">Cellwise computations; details </h2>

$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} \dX = \tilde A_{r,s}^{(e)}
\end{equation*}
$$


$$
\begin{equation*}
b_{i-1}^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) \dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} \dX = \tilde b_{r}^{(e)},
\quad i=q(e,r),\ r=0,1
\end{equation*}
$$

<p>
Must run through all \( r,s=0,1 \) and \( r=0,1 \) and compute each entry in
the element matrix and vector:

$$
\begin{equation*}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)
\end{equation*}
$$

<p>
Example:

$$ \tilde A^{(e)}_{0,1} =
\int_{-1}^1 \frac{2}{h}\frac{d\refphi_0}{dX}\frac{2}{h}\frac{d\refphi_1}{dX}
\frac{h}{2} \dX
= \frac{2}{h}(-\half)\frac{2}{h}\half\frac{h}{2} \int_{-1}^1\dX
= -\frac{1}{h}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec67">Cellwise computations; details of boundary cells </h2>

<ul>
 <p><li> The boundary cells involve only one unknown</li>
 <p><li> \( \Omega^{(0)} \): left node value known,
   only a contribution from right node</li>
 <p><li> \( \Omega^{(N_e)} \): right node value known,
   only a contribution from left node</li>
</ul>

For \( e=0 \) and \( =N_e \):

$$
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{r}
1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1
\end{array}\right)
$$

<p>
Only one degree of freedom ("node") in these cells (\( r=0 \) counts the only dof)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec68">Cellwise computations; assembly </h2>

<p>
4 P1 elements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.5</span>, <span style="color: #666666">2</span>]
cells <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>]]
dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>]]       <span style="color: #408080; font-style: italic"># only 1 dof in elm 0, 3</span>
</pre></div>
<p>
Python code for the assembly algorithm:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Ae[e][r,s]: element matrix, be[e][r]: element vector</span>
<span style="color: #408080; font-style: italic"># A[i,j]: coefficient matrix, b[i]: right-hand side</span>

<span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(Ae)):
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ae[e]<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ae[e]<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]):
            A[dof_map[e,r],dof_map[e,s]] <span style="color: #666666">+=</span> Ae[e][i,j]
        b[dof_map[e,r]] <span style="color: #666666">+=</span> be[e][i,j]
</pre></div>
<p>
Result: same linear system as arose from computations in the physical domain

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:essBC:Bfunc">General construction of a boundary function</h2>

<ul>
  <p><li> Now we address <em>nonzero Dirichlet conditions</em></li>
  <p><li> \( B(x) \) is not always easy to construct (i.e., extend to the interior of \( \Omega \)),
    especially not in 2D and 3D</li>
  <p><li> With finite element basis functions, \( \basphi_i \), \( B(x) \)
    can be constructed in a completely general way (!)</li>
</ul>

Define

<ul>
  <p><li> \( \Ifb \): set of indices with nodes where \( u \) is known</li>
  <p><li> \( U_i \): Dirichlet value of \( u \) at node \( i \), \( i\in\Ifb \)</li>
</ul>

The general formula for \( B \) is now

$$
\begin{equation*}
B(x) = \sum_{j\in\Ifb} U_j\basphi_j(x)
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec70">Explanation </h2>

<p>
Suppose we have a Dirichlet condition \( u(\xno{k})=U_k \), \( k\in\Ifb \):

$$
u(\xno{k}) = \sum_{j\in\Ifb} U_j\underbrace{\basphi_j(x)}_{\neq 0
\hbox{ only for }j=k} +
\sum_{j\in\If} c_j\underbrace{\basphi_{\nu(j)}(\xno{k})}_{=0,\ k\not\in\If}
= U_k $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:essBC:ex">Example with two <em>nonzero</em> Dirichlet values; variational formulation</h2>

$$ -u''=2, \quad u(0)=C,\ u(L)=D  $$


$$ \int_0^L u'v'\dx = \int_0^L2v\dx\quad\forall v\in V$$


$$ (u',v') = (2,v)\quad\forall v\in V$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec72">Example with two Dirichlet values; boundary function </h2>

$$
\begin{equation*}
B(x) = \sum_{j\in\Ifb} U_j\basphi_j(x)
\end{equation*}
$$

<p>
Here \( \Ifb = \{0,N_n-1\} \), \( U_0=C \), \( U_{N_n-1}=D \); \( \baspsi_i \) are
the internal \( \basphi_i \) functions:

$$ \baspsi_i = \basphi_{\nu(i)}, \quad \nu(i)=i+1,\quad i\in\If =
\{0,\ldots,N=N_n-3\} $$


$$
\begin{align*}
u(x) &= \underbrace{C\cdot\basphi_0 + D\basphi_{N_n-1}}_{B(x)}
+ \sum_{j\in\If} c_j\basphi_{j+1}\\ 
&= C\cdot\basphi_0 + D\basphi_{N_n-1} + c_0\basphi_1 + c_1\basphi_2 +\cdots
+ c_N\basphi_{N_n-2}
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec73">Example with two Dirichlet values; details </h2>

<p>
Insert \( u = B + \sum_j c_j\baspsi_j \) in variational formulation:

$$ (u',v') = (2,v)\quad\Rightarrow\quad (\sum_jc_j\baspsi_j',\baspsi_i')
= (2-B',\baspsi_i)\quad \forall v\in V$$


$$
\begin{align*}
A_{i-1,j-1} &= \int_0^L \basphi_i'(x)\basphi_j'(x) \dx\\ 
b_{i-1} &= \int_0^L (f(x)\basphi_i(x) -
B'(x)\basphi_i'(x))\dx,\quad B'(x)=C\basphi_{0}'(x) + D\basphi_{N_n-1}'(x)
\end{align*}
$$

for \( i,j = 1,\ldots,N+1=N_n-1 \).

<p>
New boundary terms from \( -\int B'\basphi_i'\dx \): add \( C/h \) to \( b_0 \)
and \( D/h \) to \( b_N \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec74">Example with two Dirichlet values; cellwise computations </h2>

<ul>
 <p><li> All element matrices are as in the previous example</li>
 <p><li> New element vector in the first and last cell</li>
</ul>

From the first cell:

$$
\tilde b_0^{(1)} = \int_{-1}^1 \left(f\refphi_1 -
C\frac{2}{h}\frac{d\refphi_0}{dX}\frac{2}{h}\frac{d\refphi_1}{dX}\right)
\frac{h}{2} \dX = \frac{h}{2} 2\int_{-1}^1 \refphi_1  \dX
- C\frac{2}{h}(-\frac{1}{2})\frac{2}{h}\frac{1}{2}\frac{h}{2}\cdot 2
= h + C\frac{1}{h}\tp
$$

<p>
From the last cell:

$$
\tilde b_0^{N_e} = \int_{-1}^1 \left(f\refphi_0 -
D\frac{2}{h}\frac{d\refphi_1}{dX}\frac{2}{h}\frac{d\refphi_0}{dX}\right)
\frac{h}{2} \dX = \frac{h}{2} 2\int_{-1}^1 \refphi_0  \dX
- D\frac{2}{h}\frac{1}{2}\frac{2}{h}(-\frac{1}{2})\frac{h}{2}\cdot 2
= h + D\frac{1}{h}\tp
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:fem:essBC:Bfunc:modsys">Modification of the linear system; ideas</h2>

<ul>
 <p><li> Method 1: incorporate Dirichlet values through a \( B(x) \) function
   and demand \( \baspsi_i=0 \) where Dirichlet values apply</li>
 <p><li> Method 2: drop \( B(x) \), drop demands to \( \baspsi_i \), just assemble
   as if there were no Dirichlet conditions, and modify the linear
   system instead</li>
</ul>

Method 2: always choose \( \baspsi_i = \basphi_i \) for all \( i\in\If \) and set

$$
\begin{equation*}
u(x) = \sum_{j\in\If}c_j\basphi_j(x),\quad \If=\{0,\ldots,N=N_n-1\}
\end{equation*}
$$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Attractive way of incorporating Dirichlet conditions.</b>
<p>
\( u \) is treated as unknown at all boundaries when computing entries
in the linear system
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec76">Modification of the linear system; original system </h2>

$$ -u''=2,\quad u(0)=0,\ u(L)=D$$

<p>
Assemble as if there were no Dirichlet conditions:

$$
\begin{equation*}

\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
h
\end{array}
\right)

\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec77">Modification of the linear system; row replacement </h2>

<ul>
 <p><li> Dirichlet condition \( u(\xno{k})= U_k \) means \( c_k=U_k \) <br />
   (since \( c_k=u(\xno{k}) \))</li>
 <p><li> Replace first row by \( c_0=0 \)</li>
 <p><li> Replace last row by \( c_N=D \)</li>
</ul>

$$
\begin{equation*}

\frac{1}{h}\left(
\begin{array}{ccccccccc}
h & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & h
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
D
\end{array}
\right)

\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec78">Modification of the linear system; element matrix/vector </h2>

<p>
In cell 0 we know \( u \) for local node (degree of freedom) \( r=0 \).
Replace the first cell equation by \( \tilde c_0 = 0 \):

$$
\begin{equation*}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
h & 0\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
0\\ 
h
\end{array}\right)
\end{equation*}
$$

<p>
In cell \( N_e \) we know \( u \) for local node \( r=1 \). Replace the last
equation in the cell system by \( \tilde c_1=D \):

$$
\begin{equation*}
\tilde A^{(N_e)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
0 & h
\end{array}\right),\quad
\tilde b^{(N_e)} = \left(\begin{array}{c}
h\\ 
D
\end{array}\right)
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec79">Symmetric modification of the linear system; algorithm </h2>

<ul>
 <p><li> The modification above destroys symmetry of the matrix:
   e.g., \( A_{0,1}\neq A_{1,0} \)</li>
 <p><li> Symmetry is often important in 2D and 3D<br />
   (faster computations, less storage)</li>
 <p><li> A more complex modification can preserve symmetry!</li>
</ul>

Algorithm for incorporating \( c_i=U_i \) in a symmetric way:

<ol>
<p><li> Subtract column \( i \) times \( U_i \) from the right-hand side</li>
<p><li> Zero out column and row no \( i \)</li>
<p><li> Place 1 on the diagonal</li>
<p><li> Set \( b_i=U_i \)</li>
</ol>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec80">Symmetric modification of the linear system; example </h2>

$$
\begin{equation*}

\frac{1}{h}\left(
\begin{array}{ccccccccc}
h & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & h
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h +\frac{D}{h}\\ 
D
\end{array}
\right)

\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec81">Symmetric modification of the linear system; element level </h2>

<p>
Symmetric modification applied to \( \tilde A^{(N_e)} \):

$$
\begin{equation*}
\tilde A^{(N_e)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 0\\ 
0 & h
\end{array}\right),\quad
\tilde b^{(N_e)} = \left(\begin{array}{c}
h + D/h\\ 
D
\end{array}\right)
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="fem:deq:1D:BC:nat">Boundary conditions: specified derivative</h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Neumann conditions.</b>
<p>
How can we incorporate \( u'(0)=C \) with finite elements?
</div>


$$ -u''=f,\quad u'(0)=C,\ u(L)=D$$


<ul>
 <p><li> \( \baspsi_i(L)=0 \) because of Dirichlet condition \( u(L)=D \)<br />
   (or no demand and modify linear system)</li>
 <p><li> No demand to \( \baspsi_i(0) \)</li>
 <p><li> The condition \( u'(0)=C \) will be handled (as usual) through a
   boundary term arising from integration by parts</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec83">The variational formulation </h2>

<p>
Galerkin's method:

$$
\begin{equation*}
\int_0^L(u''(x)+f(x))\baspsi_i(x) dx = 0,\quad i\in\If
\end{equation*}
$$

<p>
Integration of \( u''\baspsi_i \) by parts:

$$
\begin{equation*}
\int_0^Lu'(x)\baspsi_i'(x) \dx -(u'(L)\baspsi_i(L) - u'(0)\baspsi_i(0)) -
\int_0^L f(x)\baspsi_i(x) \dx =0
\end{equation*}
$$


<ul>
 <p><li> \( u'(L){\baspsi_i(L)}=0 \) since \( \baspsi_i(L)=0 \)</li>
 <p><li> \( u'(0)\baspsi_i(0) = C\baspsi_i(0) \) since \( u'(0)=C \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec84">Method 1: Boundary function and exclusion of Dirichlet degrees of freedom </h2>

<ul>
 <p><li> \( \baspsi_i = \basphi_i \), \( i\in\If =\{0,\ldots,N=N_n-2\} \)</li>
 <p><li> \( B(x)=D\basphi_{N_n-1}(x) \), \( u= B + \sum_{j=0}^N c_j\basphi_j \)</li>
</ul>

$$
\begin{equation*}
\int_0^Lu'(x)\basphi_i'(x) dx  =
\int_0^L f(x)\basphi_i(x) dx - C\basphi_i(0),\quad i\in\If
\end{equation*}
$$


$$
\begin{equation*}
\sum_{j=0}^{N}\left(
\int_0^L \basphi_i'\basphi_j' dx \right)c_j =
\int_0^L\left(f\basphi_i -D\basphi_N'\basphi_i\right) dx
 - C\basphi_i(0)
\end{equation*}
$$

for \( i=0,\ldots,N=N_n-2 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec85">Method 2: Use all \( \basphi_i \) and insert the Dirichlet condition in the linear system </h2>

<ul>
 <p><li> Now \( \baspsi_i=\basphi_i \), \( i=0,\ldots,N=N_n-1 \) (all nodes)</li>
 <p><li> \( \basphi_N(L)\neq 0 \), so \( u'(L)\basphi_N(L)\neq 0 \)</li>
 <p><li> However, the term \( u'(L)\basphi_N(L) \) in \( b_N \) <em>will be erased</em> when
   we insert the Dirichlet value in \( b_N=D \)</li>
</ul>

We can therefore forget about the term \( u'(L)\basphi_i(L) \)!

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Boundary terms \( u'\basphi_i \) at points \( \xno{i} \) where Dirichlet values apply
can always be forgotten.
</div>


$$
\begin{equation*}
u(x) = \sum_{j=0}^{N=N_n-1} c_j\basphi_j(x)
\end{equation*}
$$


$$
\begin{equation*}
\sum_{j=0}^{N=N_n-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L f(x)\basphi_i(x) dx - C\basphi_i(0)
\end{equation*}
$$

<p>
Assemble entries for \( i=0,\ldots,N=N_n-1 \) and then
modify the last equation to \( c_N=D \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec86">How the Neumann condition impacts the element matrix and vector </h2>

<p>
The extra term \( C\basphi_0(0) \) affects only the element vector from the
first cell since \( \basphi_0=0 \) on all other cells.

$$
\begin{equation*}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - C\\ 
h
\end{array}\right)
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec87">The finite element algorithm </h2>

<p>
The differential equation problem defines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</pre></div>
<p>
Must also have a mesh with <code>vertices</code>, <code>cells</code>, and <code>dof_map</code>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec88">Python pseudo code; the element matrix and vector </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&lt;</span>Declare <span style="color: #008000; font-weight: bold">global</span> matrix, <span style="color: #008000; font-weight: bold">global</span> rhs: A, b<span style="color: #666666">&gt;</span>

<span style="color: #408080; font-style: italic"># Loop over all cells</span>
<span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(cells)):

    <span style="color: #408080; font-style: italic"># Compute element matrix and vector</span>
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(dof_map[e])  <span style="color: #408080; font-style: italic"># no of dofs in this element</span>
    h <span style="color: #666666">=</span> vertices[cells[e][<span style="color: #666666">1</span>]] <span style="color: #666666">-</span> vertices[cells[e][<span style="color: #666666">0</span>]]
    <span style="color: #666666">&lt;</span>Declare element matrix, element vector: A_e, b_e<span style="color: #666666">&gt;</span>

    <span style="color: #408080; font-style: italic"># Integrate over the reference cell</span>
    points, weights <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>numerical integration rule<span style="color: #666666">&gt;</span>
    <span style="color: #008000; font-weight: bold">for</span> X, w <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(points, weights):
        phi <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>basis functions <span style="color: #666666">+</span> derivatives at X<span style="color: #666666">&gt;</span>
        detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
        x <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>affine mapping <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">X</span><span style="color: #666666">&gt;</span>
        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
                A_e[r,s] <span style="color: #666666">+=</span> integrand_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
            b_e[r] <span style="color: #666666">+=</span> integrand_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w

    <span style="color: #408080; font-style: italic"># Add boundary terms</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            A_e[r,s] <span style="color: #666666">+=</span> boundary_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
        b_e[r] <span style="color: #666666">+=</span> boundary_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec89">Python pseudo code; boundary conditions and assembly </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(cells)):
    <span style="color: #666666">...</span>

    <span style="color: #408080; font-style: italic"># Incorporate essential boundary conditions</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        global_dof <span style="color: #666666">=</span> dof_map[e][r]
        <span style="color: #008000; font-weight: bold">if</span> global_dof <span style="color: #AA22FF; font-weight: bold">in</span> essbc_dofs:
            <span style="color: #408080; font-style: italic"># dof r is subject to an essential condition</span>
            value <span style="color: #666666">=</span> essbc_docs[global_dof]
            <span style="color: #408080; font-style: italic"># Symmetric modification</span>
            b_e <span style="color: #666666">-=</span> value<span style="color: #666666">*</span>A_e[:,r]
            A_e[r,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[:,r] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[r,r] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
            b_e[r] <span style="color: #666666">=</span> value

    <span style="color: #408080; font-style: italic"># Assemble</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] <span style="color: #666666">+=</span> A_e[r,s]
        b[dof_map[e][r] <span style="color: #666666">+=</span> b_e[r]

<span style="color: #666666">&lt;</span>solve linear system<span style="color: #666666">&gt;</span>
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="fem:deq:2D:varform">Variational formulations in 2D and 3D</h1>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Major differences when going from 1D to 2D/3D.</b>
<p>

<ul>
 <p><li> The integration by part formula is different</li>
 <p><li> Cells have different geometry</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec91">Integration by parts </h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Rule for multi-dimensional integration by parts.</b>
<p>

$$
\begin{equation*}
-\int_{\Omega} \nabla\cdot (\dfc(\x)\nabla u) v\dx =
\int_{\Omega} \dfc(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds
\end{equation*}
$$


<ul>
 <p><li> \( \int_\Omega ()\dx \): area (2D) or volume (3D) integral</li>
 <p><li> \( \int_{\partial\Omega} ()\ds \): line(2D) or surface (3D) integral</li>
</ul>
</div>


<ul>
 <p><li> \( \partial\Omega_N \): Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \)</li>
 <p><li> \( \partial\Omega_D \): Dirichlet conditions
   \( u = u_0 \)</li>
 <p><li> \( v\in V \) must vanish on \( \partial\Omega_D \) (in method 1)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec92">Example on integration by parts; problem </h2>

$$
\begin{align*}
\v\cdot\nabla u + \\beta u &= \nabla\cdot\left( \dfc\nabla u\right) + f,
\quad & \x\in\Omega\\ 
u &= u_0,\quad &\x\in\partial\Omega_D\\ 
-\dfc\frac{\partial u}{\partial n} &= g,\quad &\x\in\partial\Omega_N
\end{align*}
$$


<ul>
 <p><li> Known: \( \dfc \), \( \beta \), \( f \), \( u_0 \), and \( g \).</li>
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em></li>
</ul>

Method 1 with boundary function and \( \baspsi_i=0 \) on \( \partial\Omega_D \)
(ensures \( u=u_0 \) condition):

$$ u(\x) = B(\x) + \sum_{j\in\If} c_j\baspsi_j(\x),\quad B(\x)=u_0(\x)  $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec93">Example on integration by parts in 1D/2D/3D </h2>

<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
\int_{\Omega} \nabla\cdot\left( \dfc\nabla u\right)v\dx + \int_{\Omega}fv \dx
$$

<p>
Integrate the second-order term by parts according to the formula:

$$
\int_{\Omega} \nabla\cdot\left( \dfc\nabla u\right) v \dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds,
$$

<p>
Galerkin's method then gives

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec94">Incorporation of the Neumann condition in the variational formulation </h2>

<p>
Note: \( v\neq 0 \) only on \( \partial\Omega_N \) (since \( v=0 \) on \( \partial\Omega_D \)):

$$ \int_{\partial\Omega} \dfc\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} \underbrace{\dfc\frac{\partial u}{\partial n}}_{-g} v\ds
= -\int_{\partial\Omega_N} gv\ds
$$

<p>
The final variational form:

$$
\int_{\Omega} (\v\cdot\nabla u + \beta u)v\dx =
-\int_{\Omega} \dfc\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega_N} g v\ds
+ \int_{\Omega} fv \dx
$$

<p>
Or with inner product notation:

$$
(\v\cdot\nabla u, v) + (\beta u,v) =
- (\dfc\nabla u,\nabla v) - (g,v)_{N} + (f,v)
$$

<p>
\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec95">Derivation of the linear system </h2>

<ul>
 <p><li> \( \forall v\in V \) is replaced by for all \( \baspsi_i \), \( i\in\If \)</li>
 <p><li> Insert \( u = B + \sum_{j\in\If} c_j\baspsi_j \), \( B = u_0 \), in the
   variational form</li>
 <p><li> Identify \( i,j \) terms (matrix) and \( i \) terms (right-hand side)</li>
 <p><li> Write on form \( \sum_{i\in\If}A_{i,j}c_j = b_i \), \( i\in\If \)</li>
</ul>

$$
A_{i,j} = (\v\cdot\nabla \baspsi_j, \baspsi_i) +
(\beta \baspsi_j ,\baspsi_i) + (\dfc\nabla \baspsi_j,\nabla \baspsi_i)
$$


$$
b_i = (g,\baspsi_i)_{N} + (f,\baspsi_i) -
(\v\cdot\nabla u_0, \baspsi_i) + (\beta u_0 ,\baspsi_i) +
(\dfc\nabla u_0,\nabla \baspsi_i)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec96">Transformation to a reference cell in 2D/3D (1) </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We want to compute an integral in the physical domain
by integrating over the reference cell.
</div>


$$
\begin{equation*}
\int_{{\Omega}^{(e)}} \dfc(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation*}
$$

<p>
Mapping from reference to physical coordinates:

$$ \x(\X) $$

<p>
with Jacobian \( J \),

$$ J_{i,j}=\frac{\partial x_j}{\partial X_i} $$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec97">Transformation to a reference cell in 2D/3D (2) </h2>

<ul>
 <p><li> \( \dx \rightarrow \det J\dX \).</li>
 <p><li> Must express \( \nabla\basphi_i \) by an expression with \( \refphi_r \), \( i=q(e,r) \): \( \nabla\refphi_r(\X) \)</li>
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))</li>
 <p><li> What we readily have is \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))</li>
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec98">Transformation to a reference cell in 2D/3D (3) </h2>

<p>
Can derive

$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i\\ 
\nabla_{\x}\basphi_i &= \nabla_{\x}\refphi_r(\X)
= J^{-1}\cdot\nabla_{\X}\refphi_r(\X)
\end{align*}
$$

<p>
Integral transformation from physical to reference coordinates:

$$
\begin{equation*}
\int_{\Omega^{(e)}} \dfc(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx =
\int_{\tilde\Omega^r} \dfc(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec99">Numerical integration </h2>

<p>
Numerical integration over reference cell triangles and tetrahedra:

$$ \int_{\tilde\Omega^r} g\dX = \sum_{j=0}^{n-1} w_j g(\bar\X_j)$$

<p>
Module <a href="http://tinyurl.com/nm5587k/approx/numint.py" target="_self"><tt>numint.py</tt></a> contains different rules:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numint</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, w <span style="color: #666666">=</span> numint<span style="color: #666666">.</span>quadrature_for_triangles(num_points<span style="color: #666666">=3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x
[(<span style="color: #666666">0.16666666666666666</span>, <span style="color: #666666">0.16666666666666666</span>),
 (<span style="color: #666666">0.66666666666666666</span>, <span style="color: #666666">0.16666666666666666</span>),
 (<span style="color: #666666">0.16666666666666666</span>, <span style="color: #666666">0.66666666666666666</span>)]
<span style="color: #666666">&gt;&gt;&gt;</span> w
[<span style="color: #666666">0.16666666666666666</span>, <span style="color: #666666">0.16666666666666666</span>, <span style="color: #666666">0.16666666666666666</span>]
</pre></div>
<ul>
 <p><li> Triangle: rules with \( n=1,3,4,7 \) integrate exactly polynomials of degree \( 1,2,3,4 \), resp.</li>
 <p><li> Tetrahedron: rules with \( n=1,4,5,11 \) integrate exactly polynomials of degree \( 1,2,3,4 \), resp.</li>
</ul>


<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

