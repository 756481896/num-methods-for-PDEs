<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computing with variational forms">
<meta name="keywords" content="residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition">

<title>Computing with variational forms</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec4'),
              (' The Galerkin method ', 2, None, '___sec5'),
              (' The Method of Weighted Residuals ', 2, None, '___sec6'),
              (' Test and Trial Functions ', 2, None, '___sec7'),
              (' The collocation method ', 2, None, '___sec8'),
              (' The subdomain collocation method ', 3, None, '___sec9'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec11'),
              (' Basis functions ', 3, None, '___sec12'),
              (' The residual ', 3, None, '___sec13'),
              (' The least squares method ', 3, None, '___sec14'),
              (' The Galerkin method ', 3, None, '___sec15'),
              (' The collocation method ', 3, None, '___sec16'),
              (' Comparison ', 3, None, '___sec17'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec19'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec24'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec25'),
              (' Nonlinear coefficient ', 2, None, '___sec26'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec28'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec30'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec32'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec34'),
              (' The integral for the element vector ', 3, None, '___sec35'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec36'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec37'),
              (' Assembly ', 3, None, '___sec38'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec41'),
              (' Computations in physical coordinates ', 3, None, '___sec42'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec43'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec45'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec47'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec49'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec53'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec55'),
              (' Example: constant right-hand side ', 2, None, '___sec56'),
              (' Finite elements ', 2, None, '___sec57'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec59'),
              (' Numerical integration ', 2, None, '___sec60'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec61'),
              (' Summary ', 1, None, '___sec62'),
              (' Exercises ', 1, None, '___sec63'),
              (' Exercise 1: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 2: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 3: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 4: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 5: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 6: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 7: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 8: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 9: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 10: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 11: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 12: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Bibliography ', 1, None, '___sec76')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
$$




    
<a name="part0003"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:deq:1D:varform:ex">Examples on variational formulations</h1>

<p>
The following sections derive variational formulations for some
prototype differential equations in 1D, and demonstrate how we with
ease can handle variable coefficients, mixed Dirichlet and Neumann
boundary conditions, first-order derivatives, and nonlinearities.

<h2 id="___sec24">Variable coefficient </h2>

<p>
Consider the problem

$$
\begin{equation}
-\frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D\tp
\end{equation}
$$

There are two new features of this problem compared with
previous examples: a variable
coefficient \( a(x) \) and nonzero Dirichlet conditions at both boundary points.

<p>
Let us first deal with the boundary conditions. We seek

$$ u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x),$$

with \( \baspsi_i(0)=\baspsi_i(L)=0 \) for \( i\in\If \). The function \( B(x) \)
must then fulfill \( B(0)=C \) and \( B(L)=D \). How \( B \) varies in between
\( x=0 \) and \( x=L \) is not of importance. One possible choice is

$$ B(x) = C + \frac{1}{L}(D-C)x,$$

which follows from <a href="._varform-solarized002.html#mjx-eqn-24">(24)</a> with \( p=1 \).

<p>
We seek \( (u-B)\in V \). As usual,

$$ V = \hbox{span}\{\baspsi_0,\ldots,\baspsi_N\},$$

but the two Dirichlet boundary conditions demand that

$$ \baspsi_i(0)=\baspsi_i(L)=0, \quad i\in\If\tp$$

Note that any \( v\in V \) has the property \( v(0)=v(L)=0 \).

<p>
The residual arises by inserting our \( u \) in the differential equation:

$$ R = -\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\tp $$

Galerkin's method is

$$
(R, v) = 0,\quad \forall v\in V,
$$

or written with explicit integrals,

$$
\int_{\Omega} \left(-\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\right)v \dx = 0,\quad \forall v\in V \tp
$$

We proceed with integration by parts to lower the derivative from
second to first order:

$$ -\int_{\Omega} \frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) v \dx
= \int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx -
\left[\dfc\frac{du}{dx}v\right]_0^L
\tp
$$

<p>
The boundary term vanishes since \( v(0)=v(L)=0 \).
The variational formulation is then

$$
\int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx = \int_{\Omega} f(x)v\dx,\quad
\forall v\in V\tp
$$

The variational formulation can alternatively be written in a more
compact form:

$$
(\dfc u',v') = (f,v),\quad \forall v\in V
\tp
$$

The corresponding abstract notation reads

$$ a(u,v)=L(v)\quad\forall v\in V,$$

with
$$ a(u,v)= (\dfc u',v'),\quad L(v)=(f,v) \tp  $$

Note that the \( a \) in the notation \( a(\cdot,\cdot) \) is not to be mixed with the
variable coefficient \( a(x) \) in the differential equation.

<p>
We may insert \( u=B + \sum_jc_j\baspsi_j \) and \( v=\baspsi_i \) to
derive the linear system:

$$
(\dfc B' + \dfc \sum_{j\in\If} c_j \baspsi_j', \baspsi_i') =
(f,\baspsi_i), \quad i\in\If \tp
$$

Isolating everything with the \( c_j \) coefficients on the left-hand side
and all known terms on the right-hand side
gives

$$ \sum_{j\in\If} (\dfc\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (a(D-C)L^{-1}, \baspsi_i'), \quad i\in\If
\tp
$$

This is nothing but a linear system \( \sum_j A_{i,j}c_j=b_i \)
with

$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} \dfc(x)\baspsi_j'(x),
\baspsi_i'(x)\dx,\\ 
b_i &= (f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + \dfc(x)\frac{D-C}{L}\baspsi_i'(x)\right) \dx
\tp
\end{align*}
$$

<h2 id="___sec25">First-order derivative in the equation and boundary condition </h2>

<p>
The next problem to formulate in variational form reads

$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E\tp
\end{equation}
$$

The new features are a first-order derivative \( u' \) in the equation
and the boundary
condition involving the derivative: \( u'(L)=E \).
Since we have a Dirichlet condition at \( x=0 \),
we must force \( \baspsi_i(0)=0 \) and use a boundary function
to take care of the condition \( u(0)=C \).
Because there is no Dirichlet
condition on \( x=L \) we do not make any requirements to \( \baspsi_i(L) \).
The simplest possible choice of \( B(x) \) is \( B(x)=C \).

<p>
The expansion for \( u \) becomes

$$ u = C + \sum_{j\in\If} c_j \baspsi_i(x)
\tp
$$

<p>
The variational formulation arises from multiplying the equation by
a test function \( v\in V \) and integrating over \( \Omega \):

$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V$$

We apply integration by parts to the \( u''v \) term only. Although we could
also integrate \( u' v \) by parts, this is not common.
The result becomes

$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V \tp $$

Now, \( v(0)=0 \) so

$$ [u' v]_0^L = u'(L)v(L) = E v(L),$$

because \( u'(L)=E \).
Integration by parts allows us to take care of the Neumann condition
in the boundary term.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Natural and essential boundary conditions.</b>
<p>
Omitting a boundary term like \( [u'v]_0^L \)
implies that we actually impose the condition \( u'=0 \) unless there
is a Dirichlet condition (i.e., \( v=0 \)) at that point! This result has great
practical consequences, because it is easy to forget the boundary
term, and this mistake may implicitly
set a boundary condition! Since
homogeneous Neumann conditions can be incorporated
without doing anything, and non-homogeneous Neumann conditions can
just be inserted in the boundary term,
such conditions are known as <em>natural boundary conditions</em>.
Dirichlet conditions requires more essential steps in the mathematical
formulation, such as forcing all \( \basphi_i=0 \) on the boundary
and constructing a \( B(x) \), and are
therefore known as <em>essential boundary conditions</em>.
</div>


<p>
The final variational form reads

$$ (u',v') + (bu',v) = (f,v) + E v(L), \quad\forall v\in V \tp $$

In the abstract notation we have

$$ a(u,v)=L(v)\quad\forall v\in V,$$

with the particular formulas
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f,v) + E v(L)\tp $$

<p>
The associated linear system is derived by inserting \( u=B+\sum_jc_j\baspsi_j \)
and replacing \( v \) by \( \baspsi_i \) for \( i\in\If \). Some algebra results in

$$ \sum_{j\in\If} \underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}} c_j = \underbrace{(f,\baspsi_i) + E \baspsi_i(L)}_{b_i}
\tp
$$

Observe that in this problem, the coefficient matrix is not symmetric,
because of the term

$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i \dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_j \dx = (\baspsi_i',b\baspsi_j)
\tp
$$

<p>
<!-- Too early: -->
<!-- For finite element basis functions, it is worth noticing that the boundary term -->
<!-- \( E\baspsi_i(L) \) is nonzero only in the entry \( b_N \) since all -->
<!-- \( \baspsi_i \), \( i\neq N \), are zero at \( x=L \), provided the degrees of freedom -->
<!-- are numbered from left to right in 1D so that \( \xno{N}=L \). -->

<h2 id="___sec26">Nonlinear coefficient </h2>

<p>
Finally, we show that the techniques used above to derive variational
forms also apply to nonlinear differential equation
problems as well. Here is a model problem with
a nonlinear coefficient and right-hand side:

$$
\begin{equation}
-(\dfc(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\tp
\end{equation}
$$

Our space \( V \) has basis \( \sequencei{\baspsi} \), and because of the
condition \( u(0)=0 \), we must require \( \baspsi_i(0)=0 \), \( i\in\If \).

<p>
Galerkin's method is about inserting the approximate
\( u \), multiplying the differential equation by \( v\in V \), and integrate,

$$ -\int_0^L \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right)v \dx =
\int_0^L f(u)v \dx\quad\forall v\in V
\tp
$$

The integration by parts does not differ from the case where we have
\( \dfc(x) \) instead of \( \dfc(u) \):

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + [\dfc(u)vu']_0^L\quad\forall v\in V
\tp
$$

The term \( \dfc(u(0))v(0)u'(0)=0 \) since \( v(0) \).
The other term, \( \dfc(u(L))v(L)u'(L) \),
is used to impose the other boundary condition \( u'(L)=E \), resulting in

$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + \dfc(u(L))v(L)E\quad\forall v\in V,
$$

or alternatively written more compactly as

$$ (\dfc(u)u', v') = (f(u),v) + \dfc(u(L))v(L)E\quad\forall v\in V
\tp
$$

Since the problem is nonlinear, we cannot identify a bilinear
form \( a(u,v) \) and a linear form \( L(v) \).
An abstract notation is typically <em>find \( u \) such that</em>

$$ F(u;v) = 0\quad\forall v\in V,$$

with
$$ F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
\tp
$$

<p>
By inserting \( u=\sum_j c_j\baspsi_j \) we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_i \), \( i\in\If \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
hopefully converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<h2 id="fem:deq:1D:varform:ex:DN:case">Computing with Dirichlet and Neumann conditions</h2>

<p>
<!-- ex_varform1D.py: case2 -->

<p>
Let us perform the necessary calculations to solve

$$
\begin{equation*}
-u''(x)=2,\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,
\end{equation*}
$$

using a global polynomial basis \( \baspsi_i\sim x^i \).
The requirements on \( \baspsi_i \) is that \( \baspsi_i(1)=0 \), because \( u \) is
specified at \( x=1 \), so a proper set of polynomial basis functions can be

$$ \baspsi_i(x)=(1-x)^{i+1}, \quad i\in\If\tp$$

A suitable \( B(x) \) function
to handle the boundary condition \( u(1)=D \) is \( B(x)=Dx \).
The variational formulation becomes

$$ (u',v') = (2,v) - Cv(0)\quad\forall v\in V\tp $$

From inserting \( u=B + \sum_{j}c_j\baspsi_j \) and choosing \( v=\baspsi_i \) we get

$$ \sum_{j\in\If} (\baspsi_j',\baspsi_i')c_j = (2,\baspsi_i)
- (B',\baspsi_i') - C\baspsi_i(0),\quad i\in\If\tp$$

The entries in the linear system are then

$$
\begin{align*}
A_{i,j} &= (\baspsi_j',\baspsi_i') = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)\dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j}\dx = \frac{(i+1)(j+1)}{i + j + 1},\\ 
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1\left( 2\baspsi_i(x) - D\baspsi_i'(x)\right)\dx -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)\dx  -C\\ 
&= \frac{(D-C)(i+2) + 2}{i+2} = D - C + \frac{2}{i+2}
\tp
\end{align*}
$$

Relevant <code>sympy</code> commands to help calculate these expressions are

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
x, C, D = symbols(<span style="color: #CD5555">&#39;x C D&#39;</span>)
i, j = symbols(<span style="color: #CD5555">&#39;i j&#39;</span>, integer=<span style="color: #658b00">True</span>, positive=<span style="color: #658b00">True</span>)
psi_i = (<span style="color: #B452CD">1</span>-x)**(i+<span style="color: #B452CD">1</span>)
psi_j = psi_i.subs(i, j)
integrand = diff(psi_i, x)*diff(psi_j, x)
integrand = simplify(integrand)
A_ij = integrate(integrand, (x, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>))
A_ij = simplify(A_ij)
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;A_ij:&#39;</span>, A_ij
f = <span style="color: #B452CD">2</span>
b_i = integrate(f*psi_i, (x, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>)) - \ 
      integrate(diff(D*x, x)*diff(psi_i, x), (x, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>)) - \ 
      C*psi_i.subs(x, <span style="color: #B452CD">0</span>)
b_i = simplify(b_i)
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;b_i:&#39;</span>, b_i
</pre></div>
<p>
The output becomes

<p>

<!-- code=text (!bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">A_ij: (i + 1)*(j + 1)/(i + j + 1)
b_i: ((-C + D)*(i + 2) + 2)/(i + 2)
</pre></div>
<p>
We can now choose some \( N \) and form the linear system, say for \( N=1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N = <span style="color: #B452CD">1</span>
A = zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
b = zeros(N+<span style="color: #B452CD">1</span>)
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;fresh b:&#39;</span>, b
<span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
    <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        A[r,s] = A_ij.subs(i, r).subs(j, s)
    b[r,<span style="color: #B452CD">0</span>] = b_i.subs(i, r)
</pre></div>
<p>
The system becomes

$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
1-C+D\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$

The solution (<code>c = A.LUsolve(b)</code>)
becomes \( c_0=2 -C+D \) and \( c_1=-1 \), resulting in

$$
\begin{equation}
u(x) = 1 -x^2 + D + C(x-1),
\end{equation}
$$

We can form this \( u \) in <code>sympy</code> and check that the differential equation
and the boundary conditions are satisfied:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = <span style="color: #658b00">sum</span>(c[r,<span style="color: #B452CD">0</span>]*psi_i.subs(i, r) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)) + D*x
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;u:&#39;</span>, simplify(u)
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&quot;u&#39;&#39;:&quot;</span>, simplify(diff(u, x, x))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;BC x=0:&#39;</span>, simplify(diff(u, x).subs(x, <span style="color: #B452CD">0</span>))
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;BC x=1:&#39;</span>, simplify(u.subs(x, <span style="color: #B452CD">1</span>))
</pre></div>
<p>
The output becomes

<p>

<!-- code=text (!bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u: C*x - C + D - x**2 + 1
u&#39;&#39;: -2
BC x=0: C
BC x=1: D
</pre></div>
<p>
The complete <code>sympy</code> code is found in <a href="http://tinyurl.com/nm5587k/fem/u_xx_2_CD.py" target="_self"><tt>u_xx_2_CD.py</tt></a>.

<p>
The exact solution is found by integrating twice and applying the
boundary conditions, either by hand or using <code>sympy</code> as shown in
the section <a href="._varform-solarized002.html#fem:deq:1D:models:simple">Simple model problems</a>.  It appears that the numerical
solution coincides with the exact one.  This result is to be expected
because if \( (\uex - B)\in V \), \( u = \uex \), as proved next.

<h2 id="___sec28">When the numerical method is exact </h2>

<p>
We have some variational formulation: find \( (u-B)\in V \) such that
\( a(u,v)=L(u)\ \forall V \). The exact solution also fulfills
\( a(\uex,v)=L(v) \), but normally \( (\uex -B) \) lies in a much larger
(infinite-dimensional) space. Suppose, nevertheless, that
\( \uex - B = E \), where \( E\in V \). That is, apart from Dirichlet conditions,
\( \uex \) lies in our finite-dimensional space \( V \) we use to compute \( u \).
Writing also \( u \) on the same form \( u=B+F \), \( F\in V \), we have

$$
\begin{align*}
a(B+E,v) &= L(v)\quad\forall v\in V,\\ 
a(B+F,v) &= L(v)\quad\forall v\in V\tp
\end{align*}
$$

Since these are two variational statements in the same space, we
can subtract them and use the bilinear property of \( a(\cdot,\cdot) \):

$$
\begin{align*}
a(B+E,v) - a(B+F, v) &= L(v) - L(v)\\ 
a(B+E-(B+F),v) &= 0\\ 
a(E-F),v) &= 0
\end{align*}
$$

If \( a(E-F),v) = 0 \) for all \( v \) in \( V \), then \( E-F \) must be zero everywhere
in the domain, i.e., \( E=F \). Or in other words: \( u=\uex \). This proves
that the exact solution is recovered if \( \uex - B \) lies in \( V \)., i.e.,
can expressed as \( \sum_{j\in\If}d_j\baspsi_j \) if \( \{\baspsi_j\}_{j\in\If} \)
is a basis for \( V \). The method will then compute the solution \( c_j=d_j \),
\( j\in\If \).

<p>
The case treated in the section <a href="#fem:deq:1D:varform:ex:DN:case">Computing with Dirichlet and Neumann conditions</a>
is of the type where \( \uex - B \) is a quadratic function that is 0
at \( x=1 \), and therefore \( (\uex -B)\in V \), and the method
finds the exact solution.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

