<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Stationary variational forms">
<meta name="keywords" content="residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition">

<title>Stationary variational forms</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec4'),
              ('The Galerkin method', 2, None, '___sec5'),
              ('The Method of Weighted Residuals', 2, None, '___sec6'),
              ('Test and Trial Functions', 2, None, '___sec7'),
              ('The collocation method', 2, None, '___sec8'),
              ('The subdomain collocation method', 3, None, '___sec9'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec11'),
              ('Basis functions', 3, None, '___sec12'),
              ('The residual', 3, None, '___sec13'),
              ('The least squares method', 3, None, '___sec14'),
              ('The Galerkin method', 3, None, '___sec15'),
              ('The collocation method', 3, None, '___sec16'),
              ('Comparison', 3, None, '___sec17'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec19'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and optimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec24'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec25'),
              ('Nonlinear coefficient', 2, None, '___sec26'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec28'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions',
               2,
               None,
               '___sec30'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               None,
               '___sec32'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec34'),
              ('The integral for the element vector', 3, None, '___sec35'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec36'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec37'),
              ('Assembly', 3, None, '___sec38'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with finite element-based a boundary function',
               2,
               None,
               '___sec41'),
              ('Computations in physical coordinates', 3, None, '___sec42'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec43'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec45'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               None,
               '___sec47'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec49'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec53'),
              ('Implementation',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Global basis functions', 2, None, '___sec55'),
              ('Example: constant right-hand side', 2, None, '___sec56'),
              ('Finite elements', 2, None, '___sec57'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec59'),
              ('Numerical integration', 2, None, '___sec60'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec61'),
              ('Summary', 1, None, '___sec62'),
              ('Exercises', 1, None, '___sec63'),
              ('Exercise 1: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 2: Compute the deflection of a cable with sine functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Exercise 3: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 4: Compute the deflection of a cable with 2 P1 elements',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 5: Compute the deflection of a cable with 1 P2 element',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 6: Compute the deflection of a cable with a step load',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 7: Show equivalence between linear systems',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              ('Exercise 8: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 9: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 10: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 11: Compute with variable coefficients and P1 elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 12: Solve a 2D Poisson equation using polynomials and sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Bibliography', 1, None, '___sec76')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:deq:1D:code:global">Implementation</h1>

<p>
It is tempting to create a
program with symbolic calculations to perform all the steps in the
computational machinery,
both for automating the work and for documenting the complete algorithms.
As we have seen, there are quite many details involved with
finite element computations and incorporation of boundary conditions.
An implementation will also act as a structured summary of all these details.

<h2 id="___sec55">Global basis functions </h2>

<p>
We first consider implementations when \( \baspsi_i \) are global functions
are hence different from zero on most of \( \Omega =[0,L] \) so all integrals
need integration over the entire domain. Since the expressions for
the entries in the linear system depend on the differential equation
problem being solved, the user must supply the necessary formulas via
Python functions. The implementations here attempt to perform symbolic
calculations, but fall back on numerical computations if the symbolic
ones fail.

<p>
The user must prepare a function
<code>integrand_lhs(psi, i, j)</code> for returning the integrand of the
integral that contributes to matrix entry \( (i,j) \).
The <code>psi</code> variable is a Python dictionary holding the basis
functions and their derivatives in symbolic form. More precisely,
<code>psi[q]</code> is a list of

$$
\begin{equation*}
\{\frac{d^q\baspsi_0}{dx^q},\ldots,\frac{d^q\baspsi_{N_n-1}}{dx^q}\}
\tp
\end{equation*}
$$

Similarly, <code>integrand_rhs(psi, i)</code> returns the integrand
for entry number \( i \) in the right-hand side vector.

<p>
Since we also have contributions to the right-hand side vector,
and potentially also the
matrix, from boundary terms without any integral, we introduce two
additional functions, <code>boundary_lhs(psi, i, j)</code> and
<code>boundary_rhs(psi, i)</code> for returning terms in the variational
formulation that are not to be integrated over the domain \( \Omega \).
Examples shown later will explain in more detail how these
user-supplied function may look like.

<p>
The linear system can be computed and solved symbolically by
the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solve</span>(integrand_lhs, integrand_rhs, psi, Omega,
          boundary_lhs=<span style="color: #658b00">None</span>, boundary_rhs=<span style="color: #658b00">None</span>):
    N = <span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>]) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            integrand = integrand_lhs(psi, i, j)
            I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            <span style="color: #8B008B; font-weight: bold">if</span> boundary_lhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I   <span style="color: #228B22"># assume symmetry</span>
        integrand = integrand_rhs(psi, i)
        I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
        <span style="color: #8B008B; font-weight: bold">if</span> boundary_rhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            I += boundary_rhs(psi, i)
        b[i,<span style="color: #B452CD">0</span>] = I
    c = A.LUsolve(b)
    u = <span style="color: #658b00">sum</span>(c[i,<span style="color: #B452CD">0</span>]*psi[<span style="color: #B452CD">0</span>][i] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>])))
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
<p>
Not surprisingly, symbolic solution of differential
equations, discretized by a Galerkin or least squares method
with global basis functions,
is of limited interest beyond the simplest problems, because
symbolic integration might be very time consuming or impossible, not
only in <code>sympy</code> but also in
<a href="http://wolframalpha.com" target="_self">WolframAlpha</a>
(which applies the perhaps most powerful symbolic integration
software available today: Mathematica). Numerical integration
as an option is therefore desirable.

<p>
The extended <code>solve</code> function below tries to combine symbolic and
numerical integration.  The latter can be enforced by the user, or it
can be invoked after a non-successful symbolic integration (being
detected by an <code>Integral</code> object as the result of the integration
in <code>sympy</code>).
<!-- see the section ref{fem:approx:global:Lagrange}). -->
Note that for a
numerical integration, symbolic expressions must be converted to
Python functions (using <code>lambdify</code>), and the expressions cannot contain
other symbols than <code>x</code>. The real <code>solve</code> routine in the
<a href="http://tinyurl.com/nm5587k/fem/varform1D.py" target="_self"><tt>varform1D.py</tt></a>
file has error checking and meaningful error messages in such cases.
The <code>solve</code> code below is a condensed version of the real one, with
the purpose of showing how to automate the Galerkin or least squares
method for solving differential equations in 1D with global basis functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solve</span>(integrand_lhs, integrand_rhs, psi, Omega,
          boundary_lhs=<span style="color: #658b00">None</span>, boundary_rhs=<span style="color: #658b00">None</span>, symbolic=<span style="color: #658b00">True</span>):
    N = <span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>]) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            integrand = integrand_lhs(psi, i, j)
            <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
                I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
                <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
                    symbolic = <span style="color: #658b00">False</span>  <span style="color: #228B22"># force num.int. hereafter</span>
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic:
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
            <span style="color: #8B008B; font-weight: bold">if</span> boundary_lhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I
        integrand = integrand_rhs(psi, i)
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
                symbolic = <span style="color: #658b00">False</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic:
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
        <span style="color: #8B008B; font-weight: bold">if</span> boundary_rhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            I += boundary_rhs(psi, i)
        b[i,<span style="color: #B452CD">0</span>] = I
    c = A.LUsolve(b)
    u = <span style="color: #658b00">sum</span>(c[i,<span style="color: #B452CD">0</span>]*psi[<span style="color: #B452CD">0</span>][i] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>])))
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>

<h2 id="___sec56">Example: constant right-hand side </h2>

<p>
To demonstrate the code above, we address

$$
\begin{equation*} -u''(x)=b,\quad x\in\Omega=[0,1],\quad u(0)=1,\ u(1)=0,\end{equation*}
$$

with \( b \) as a (symbolic) constant. A possible basis for the space \( V \)
is \( \baspsi_i(x) = x^{i+1}(1-x) \), \( i\in\If \). Note that
\( \baspsi_i(0)=\baspsi_i(1)=0 \) as required by the Dirichlet conditions.
We need a \( B(x) \) function to take care of the known boundary
values of \( u \). Any function \( B(x)=1-x^p \), \( p\in\Real \), is a candidate,
and one arbitrary choice from this family
is \( B(x)=1-x^3 \). The unknown function is then written as

$$
\begin{equation*}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x)\tp
\end{equation*}
$$

<p>
Let us use the Galerkin method to derive the variational formulation.
Multiplying the differential
equation by \( v \) and integrate by parts yield

$$
\begin{equation*}
\int_0^1 u'v' \dx = \int_0^1 fv \dx\quad\forall v\in V,
\end{equation*}
$$

and with \( u=B + \sum_jc_j\baspsi_j \) we get the linear system

$$
\begin{equation}
\sum_{j\in\If}\left(\int_0^1\baspsi_i'\baspsi_j' \dx\right)c_j =
\int_0^1(f\baspsi_i-B'\baspsi_i') \dx,
\quad i\in\If\tp
\end{equation}
$$

<p>
The application can be coded as follows in <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x, b = sym.symbols(<span style="color: #CD5555">&#39;x b&#39;</span>)
f = b
B = <span style="color: #B452CD">1</span> - x**<span style="color: #B452CD">3</span>
dBdx = sym.diff(B, x)

<span style="color: #228B22"># Compute basis functions and their derivatives</span>
N = <span style="color: #B452CD">3</span>
psi = {<span style="color: #B452CD">0</span>: [x**(i+<span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">1</span>-x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]}
psi[<span style="color: #B452CD">1</span>] = [sym.diff(psi_i, x) <span style="color: #8B008B; font-weight: bold">for</span> psi_i <span style="color: #8B008B">in</span> psi[<span style="color: #B452CD">0</span>]]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">integrand_lhs</span>(psi, i, j):
    <span style="color: #8B008B; font-weight: bold">return</span> psi[<span style="color: #B452CD">1</span>][i]*psi[<span style="color: #B452CD">1</span>][j]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">integrand_rhs</span>(psi, i):
    <span style="color: #8B008B; font-weight: bold">return</span> f*psi[<span style="color: #B452CD">0</span>][i] - dBdx*psi[<span style="color: #B452CD">1</span>][i]

Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]

u_bar = solve(integrand_lhs, integrand_rhs, psi, Omega,
              verbose=<span style="color: #658b00">True</span>, symbolic=<span style="color: #658b00">True</span>)
u = B + u_bar
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;solution u:&#39;</span>, sym.simplify(sym.expand(u))
</pre></div>
<p>
The printout of <code>u</code> reads <code>-b*x**2/2 + b*x/2 - x + 1</code>.
Note that expanding <code>u</code> and then simplifying is in the present case
necessary to get a compact, final expression with <code>sympy</code>.
A non-expanded <code>u</code> might be preferable in other cases - this depends on
the problem in question.

<p>
The exact solution \( \uex(x) \) can be derived by
some <code>sympy</code> code that closely follows the examples in
the section <a href="._varform-solarized001.html#fem:deq:1D:models:simple">Simple model problems</a>. The idea is to integrate
\( -u''=b \) twice and determine the integration constants from
the boundary conditions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">C1, C2 = sym.symbols(<span style="color: #CD5555">&#39;C1 C2&#39;</span>)    <span style="color: #228B22"># integration constants</span>
f1 = sym.integrate(f, x) + C1
f2 = sym.integrate(f1, x) + C2
<span style="color: #228B22"># Find C1 and C2 from the boundary conditions u(0)=0, u(1)=1</span>
s = sym.solve([u_e.subs(x,<span style="color: #B452CD">0</span>) - <span style="color: #B452CD">1</span>, u_e.subs(x,<span style="color: #B452CD">1</span>) - <span style="color: #B452CD">0</span>], [C1, C2])
<span style="color: #228B22"># Form the exact solution</span>
u_e = -f2 + s[C1]*x + s[C2]
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;analytical solution:&#39;</span>, u_e
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;error:&#39;</span>, sym.simplify(sym.expand(u - u_e))
</pre></div>
<p>
The last line prints <code>0</code>, which is not surprising when
\( \uex(x) \) is a parabola and our approximate \( u \) contains polynomials up to
degree 4. It suffices to have \( N=1 \), i.e., polynomials of degree
2, to recover the exact solution.

<p>
We can play around with the code and test that with \( f\sim x^p \),
the solution is a polynomial of degree \( p+2 \), and \( N=p+1 \) guarantees
that the approximate solution is exact.

<p>
Although the symbolic code is capable of integrating many choices of \( f(x) \),
the symbolic expressions for \( u \) quickly become lengthy and non-informative,
so numerical integration in the code, and hence numerical answers,
have the greatest application potential.

<h2 id="___sec57">Finite elements </h2>

<p>
Implementation of the finite element algorithms for differential
equations follows closely the algorithm for approximation of functions.
The new additional ingredients are

<ol>
<li> other types of integrands (as implied by the variational formulation)</li>
<li> additional boundary terms in the variational formulation for
   Neumann boundary conditions</li>
<li> modification of element matrices and vectors due to Dirichlet
   boundary conditions</li>
</ol>

Point 1 and 2 can be taken care of by letting the user supply
functions defining the integrands and boundary terms on the
left- and right-hand side of the equation system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</pre></div>
<p>
Here, <code>phi</code> is a dictionary where <code>phi[q]</code> holds a list of
the derivatives of order <code>q</code> of the basis functions at the
an evaluation point; <code>r</code> and <code>s</code> are indices for the corresponding
entries in the element matrix and vector, and <code>x</code> is the global
coordinate value corresponding to the current evaluation point.

<p>
Given a mesh represented by <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> as
explained before, we can write a pseudo Python code to list all
the steps in the computational algorithm for finite element solution
of a differential equation.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&lt;Declare <span style="color: #8B008B; font-weight: bold">global</span> matrix <span style="color: #8B008B">and</span> rhs: A, b&gt;

<span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(cells)):

    <span style="color: #228B22"># Compute element matrix and vector</span>
    n = <span style="color: #658b00">len</span>(dof_map[e])  <span style="color: #228B22"># no of dofs in this element</span>
    h = vertices[cells[e][<span style="color: #B452CD">1</span>]] - vertices[cells[e][<span style="color: #B452CD">1</span>]]
    &lt;Declare element matrix <span style="color: #8B008B">and</span> vector: A_e, b_e&gt;

    <span style="color: #228B22"># Integrate over the reference cell</span>
    points, weights = &lt;numerical integration rule&gt;
    <span style="color: #8B008B; font-weight: bold">for</span> X, w <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(points, weights):
        phi = &lt;basis functions <span style="color: #8B008B">and</span> derivatives at X&gt;
        detJ = h/<span style="color: #B452CD">2</span>
        x = &lt;affine mapping <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">X</span>&gt;
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A_e[r,s] += integrand_lhs(phi, r, s, x)*detJ*w
            b_e[r] += integrand_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Add boundary terms</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A_e[r,s] += boundary_lhs(phi, r, s, x)*detJ*w
        b_e[r] += boundary_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Incorporate essential boundary conditions</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        global_dof = dof_map[e][r]
        <span style="color: #8B008B; font-weight: bold">if</span> global_dof <span style="color: #8B008B">in</span> essbc_dofs:
            <span style="color: #228B22"># dof r is subject to an essential condition</span>
            value = essbc_docs[global_dof]
            <span style="color: #228B22"># Symmetric modification</span>
            b_e -= value*A_e[:,r]
            A_e[r,:] = <span style="color: #B452CD">0</span>
            A_e[:,r] = <span style="color: #B452CD">0</span>
            A_e[r,r] = <span style="color: #B452CD">1</span>
            b_e[r] = value

    <span style="color: #228B22"># Assemble</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] += A_e[r,s]
        b[dof_map[e][r] += b_e[r]

&lt;solve linear system&gt;
</pre></div>
<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

