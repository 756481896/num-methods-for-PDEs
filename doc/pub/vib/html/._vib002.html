<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for vibration problems">
<meta name="keywords" content="vibration ODE,oscillations,mechanical vibrations,period (of oscillations),frequency (of oscillations),Hz (unit),mesh finite differences,mesh function,centered difference,finite differences centered,making movies,animation,WebM (video format),Ogg (video format),MP4 (video format),Flash (video format),video formats,HTML5 video tag,error global,stability criterion,phase plane plot,mechanical energy,energy principle,forward-backward Euler-Cromer scheme,nonlinear restoring force,nonlinear spring,forced vibrations,geometric mean,averaging geometric,DOF (degree of freedom)">

<title>Finite difference methods for vibration problems</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Finite difference discretization',
               1,
               'vib:model1',
               'vib:model1'),
              ('A basic model for vibrations', 2, None, '___sec1'),
              ('A centered finite difference scheme',
               2,
               'vib:ode1:fdm',
               'vib:ode1:fdm'),
              ('Step 1: Discretizing the domain', 3, None, '___sec3'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec4'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec5'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec6'),
              ('Computing the first step', 3, None, '___sec7'),
              ('The computational algorithm', 3, None, '___sec8'),
              ('Operator notation', 3, None, '___sec9'),
              ('Implementation', 1, 'vib:impl1', 'vib:impl1'),
              ('Making a solver function',
               2,
               'vib:impl1:solver',
               'vib:impl1:solver'),
              ('Computing $u^{\\prime}$', 3, None, '___sec12'),
              ('Verification', 2, 'vib:ode1:verify', 'vib:ode1:verify'),
              ('Manual calculation', 3, None, '___sec14'),
              ('Testing very simple solutions', 3, None, '___sec15'),
              ('Checking convergence rates', 3, None, '___sec16'),
              ('Scaled model', 2, None, '___sec17'),
              ('Long time simulations',
               1,
               'vib:ode1:longseries',
               'vib:ode1:longseries'),
              ('Using a moving plot window', 2, None, '___sec19'),
              ('Making animations', 2, 'vib:ode1:anim', 'vib:ode1:anim'),
              ('Producing standard video formats', 3, None, '___sec21'),
              ('Paying PNG files in a web browser', 3, None, '___sec22'),
              ('Making animated GIF files', 3, None, '___sec23'),
              ('Using a line-by-line ascii plotter', 2, None, '___sec24'),
              ('Empirical analysis of the solution',
               2,
               'vib:ode1:empirical',
               'vib:ode1:empirical'),
              ('Analysis of the numerical scheme',
               1,
               'vib:ode1:analysis',
               'vib:ode1:analysis'),
              ('Deriving a solution of the numerical scheme',
               2,
               None,
               '___sec27'),
              ('Exact discrete solution',
               2,
               'vib:ode1:analysis:sol',
               'vib:ode1:analysis:sol'),
              ('Convergence',
               2,
               'vib:ode1:analysis:conv',
               'vib:ode1:analysis:conv'),
              ('The global error', 2, None, '___sec30'),
              ('Stability', 2, None, '___sec31'),
              ('About the accuracy at the stability limit',
               2,
               None,
               '___sec32'),
              ('Alternative schemes based on 1st-order equations',
               1,
               'vib:model2x2',
               'vib:model2x2'),
              ('The Forward Euler scheme', 2, None, '___sec34'),
              ('The Backward Euler scheme', 2, None, '___sec35'),
              ('The Crank-Nicolson scheme', 2, None, '___sec36'),
              ('Comparison of schemes',
               2,
               'vib:model2x2:compare',
               'vib:model2x2:compare'),
              ('Runge-Kutta methods', 2, None, '___sec38'),
              ('Analysis of the Forward Euler scheme', 2, None, '___sec39'),
              ('Energy considerations',
               1,
               'vib:model1:energy',
               'vib:model1:energy'),
              ('Derivation of the energy expression', 2, None, '___sec41'),
              ('Energy of the exact solution', 3, None, '___sec42'),
              ('An error measure based on energy', 2, None, '___sec43'),
              ('The Euler-Cromer method',
               1,
               'vib:model2x2:EulerCromer',
               'vib:model2x2:EulerCromer'),
              ('Forward-backward discretization', 2, None, '___sec45'),
              ('Equivalence with the scheme for the second-order ODE',
               2,
               'vib:model2x2:EulerCromer:equiv',
               'vib:model2x2:EulerCromer:equiv'),
              ('Implementation',
               2,
               'vib:model2x2:EulerCromer:impl',
               'vib:model2x2:EulerCromer:impl'),
              ('The velocity Verlet algorithm', 2, None, '___sec48'),
              ('Generalization: damping, nonlinear spring, and external excitation',
               1,
               'vib:model2',
               'vib:model2'),
              ('A centered scheme for linear damping',
               2,
               'vib:ode2:fdm:flin',
               'vib:ode2:fdm:flin'),
              ('A centered scheme for quadratic damping',
               2,
               'vib:ode2:fdm:fquad',
               'vib:ode2:fdm:fquad'),
              ('A forward-backward discretization of the quadratic damping term',
               2,
               None,
               '___sec52'),
              ('Implementation', 2, 'vib:ode2:solver', 'vib:ode2:solver'),
              ('Verification', 2, 'vib:ode2:verify', 'vib:ode2:verify'),
              ('Constant solution', 3, None, '___sec55'),
              ('Linear solution', 3, None, '___sec56'),
              ('Quadratic solution', 3, None, '___sec57'),
              ('Visualization', 2, 'vib:ode2:viz', 'vib:ode2:viz'),
              ('User interface', 2, 'vib:ode2:ui', 'vib:ode2:ui'),
              ('The Euler-Cromer scheme for the generalized model',
               2,
               None,
               '___sec60'),
              ('Exercises and Problems', 1, None, '___sec61'),
              ('Problem 1: Use linear/quadratic functions for verification',
               2,
               'vib:exer:undamped:verify:linquad',
               'vib:exer:undamped:verify:linquad'),
              ('Exercise 2: Show linear growth of the phase with time',
               2,
               'vib:exer:phase:err:growth',
               'vib:exer:phase:err:growth'),
              ('Exercise 3: Improve the accuracy by adjusting the frequency',
               2,
               'vib:exer:w:adjust',
               'vib:exer:w:adjust'),
              ('Exercise 4: See if adaptive methods improve the phase error',
               2,
               'vib:exer:undamped:adaptive',
               'vib:exer:undamped:adaptive'),
              ('Exercise 5: Use a Taylor polynomial to compute $u^1$',
               2,
               'vib:exer:step4b:alt',
               'vib:exer:step4b:alt'),
              ('Exercise 6: Find the minimal resolution of an oscillatory function',
               2,
               'vib:exer:wdt:limit',
               'vib:exer:wdt:limit'),
              ('Exercise 7: Visualize the accuracy of finite differences for a cosine function',
               2,
               'vib:exer:fd:exp:plot',
               'vib:exer:fd:exp:plot'),
              ('Exercise 8: Verify convergence rates of the error in energy',
               2,
               'vib:exer:energy:convrate',
               'vib:exer:energy:convrate'),
              ('Exercise 9: Use linear/quadratic functions for verification',
               2,
               'vib:exer:verify:gen:linear',
               'vib:exer:verify:gen:linear'),
              ('Exercise 10: Use an exact discrete solution for verification',
               2,
               'vib:exer:discrete:omega',
               'vib:exer:discrete:omega'),
              ('Exercise 11: Use analytical solution for convergence rate tests',
               2,
               'vib:exer:conv:rate',
               'vib:exer:conv:rate'),
              ('Exercise 12: Investigate the amplitude errors of many solvers',
               2,
               'vib:exer:undamped:odespy',
               'vib:exer:undamped:odespy'),
              ('Exercise 13: Minimize memory usage of a vibration solver',
               2,
               'vib:exer:memsave',
               'vib:exer:memsave'),
              ('Exercise 14: Implement the solver via classes',
               2,
               'vib:exer:gen:class',
               'vib:exer:gen:class'),
              ('Exercise 15: Interpret $[D_tD_t u]^n$ as a forward-backward difference',
               2,
               'vib:exer:DtDt:asDtpDtm',
               'vib:exer:DtDt:asDtpDtm'),
              ('Exercise 16: Use a backward difference for the damping term',
               2,
               'vib:exer:quad:damping:bw',
               'vib:exer:quad:damping:bw'),
              ('Exercise 17: Analysis of the Euler-Cromer scheme',
               2,
               'vib:exer:EulerCromer:analysis',
               'vib:exer:EulerCromer:analysis'),
              ('Applications of vibration models', 1, 'vib:app', 'vib:app'),
              ('Oscillating mass attached to a spring',
               2,
               'vib:app:mass_spring',
               'vib:app:mass_spring'),
              ('General mechanical vibrating system',
               2,
               'vib:app:mass_gen',
               'vib:app:mass_gen'),
              ('A sliding mass attached to a spring',
               2,
               'vib:app:mass_sliding',
               'vib:app:mass_sliding'),
              ('A jumping washing machine',
               2,
               'vib:app:washmach',
               'vib:app:washmach'),
              ('Motion of a pendulum',
               2,
               'vib:app:pendulum',
               'vib:app:pendulum'),
              ('Motion of an elastic pendulum',
               2,
               'vib:app:pendulum_elastic',
               'vib:app:pendulum_elastic'),
              ('Remarks about an elastic vs a non-elastic pendulum',
               3,
               None,
               '___sec86'),
              ('Initial conditions', 3, None, '___sec87'),
              ('The complete ODE problem', 3, None, '___sec88'),
              ('Scaling', 3, None, '___sec89'),
              ('Remark on the non-elastic limit', 3, None, '___sec90'),
              ('Bouncing ball',
               2,
               'vib:app:bouncing_ball',
               'vib:app:bouncing_ball'),
              ('Electric circuits', 2, None, '___sec92'),
              ('Exercises', 1, None, '___sec93'),
              ('Exercise 18: Simulate oscillations of a sliding box',
               2,
               'vib:exer:sliding_box',
               'vib:exer:sliding_box'),
              ('Exercise 19: Simulate a bouncing ball',
               2,
               'vib:exer:bouncing:ball',
               'vib:exer:bouncing:ball'),
              ('Exercise 20: Simulate an elastic pendulum',
               2,
               'vib:exer:pendulum_elastic',
               'vib:exer:pendulum_elastic'),
              ('Exercise 21: Simulate an elastic pendulum with air resistance',
               2,
               'vib:exer:pendulum_elastic_drag',
               'vib:exer:pendulum_elastic_drag'),
              ('Remarks', 3, None, '___sec98'),
              ('References', 1, None, '___sec99')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\acc}{\boldsymbol{a}}
\newcommand{\rpos}{\boldsymbol{r}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="vib.html">Finite difference methods for vibration problems</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#vib:model1" style="font-size: 80%;">Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="#vib:impl1" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#vib:ode1:longseries" style="font-size: 80%;">Long time simulations</a></li>
     <!-- navigation toc: --> <li><a href="#vib:ode1:analysis" style="font-size: 80%;">Analysis of the numerical scheme</a></li>
     <!-- navigation toc: --> <li><a href="#vib:model2x2" style="font-size: 80%;">Alternative schemes based on 1st-order equations</a></li>
     <!-- navigation toc: --> <li><a href="#vib:model1:energy" style="font-size: 80%;">Energy considerations</a></li>
     <!-- navigation toc: --> <li><a href="#vib:model2x2:EulerCromer" style="font-size: 80%;">The Euler-Cromer method</a></li>
     <!-- navigation toc: --> <li><a href="._vib003.html#vib:model2" style="font-size: 80%;">Generalization: damping, nonlinear spring, and external excitation</a></li>
     <!-- navigation toc: --> <li><a href="._vib003.html#___sec61" style="font-size: 80%;">Exercises and Problems</a></li>
     <!-- navigation toc: --> <li><a href="._vib003.html#vib:app" style="font-size: 80%;">Applications of vibration models</a></li>
     <!-- navigation toc: --> <li><a href="._vib003.html#___sec93" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._vib003.html#___sec99" style="font-size: 80%;">References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0002"></a>
<!-- !split -->

<p>
<!-- 2DO: -->
<!-- _undamped -> _simple everywhere -->
<!-- Long time integration by adaptive RK: will that improve the -->
<!-- phase error? Do experiments where we measure the wavelength -->
<!-- and plot it as function of time. Can we vectorize the -->
<!-- max/min pt computation? -->

<p>
Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the forthcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Need to discuss errors also for the damped and nonlinear models. At least the frequency errors must be illustrated here as well and investigated numerically, either in text or exercises.)</font>
<!-- end inline comment -->

<h1 id="vib:model1">Finite difference discretization</h1>

<p>
Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
\( u^{\prime\prime} + u =0 \). This ODE is thus chosen as our starting
point for method development, implementation, and analysis.

<h2 id="___sec1">A basic model for vibrations </h2>

<p>
A system that vibrates without damping and external forcing
can be described by the ODE problem

$$
\begin{equation}
u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
\tp
\tag{1}
\end{equation}
$$

Here, \( \omega \) and \( I \) are given constants.
The exact solution of <a href="#mjx-eqn-1">(1)</a> is

$$
\begin{equation}
u(t) = I\cos (\omega t)
\tp
\tag{2}
\end{equation}
$$

That is, \( u \) oscillates with constant amplitude \( I \) and
angular frequency \( \omega \).
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is \( P=2\pi/\omega \).
The number of periods per second
is \( f=\omega/(2\pi) \) and measured in the unit Hz.
Both \( f \) and \( \omega \) are referred to as frequency, but \( \omega \)
is more precisely named <em>angular frequency</em>, measured in rad/s.

<p>
In vibrating mechanical systems modeled by <a href="#mjx-eqn-1">(1)</a>, \( u(t) \)
very often represents a position or a displacement of a particular
point in the system. The derivative \( u^{\prime}(t) \) then has the
interpretation of velocity, and \( u^{\prime\prime}(t) \) is the associated
acceleration.  The model <a href="#mjx-eqn-1">(1)</a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.

<h2 id="vib:ode1:fdm">A centered finite difference scheme</h2>

<p>
To formulate a finite difference method for the model
problem  <a href="#mjx-eqn-1">(1)</a> we follow the <a href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme" target="_self">four steps</a> explained in <a href="._vib003.html#Langtangen_decay">[1]</a>.

<h3 id="___sec3">Step 1: Discretizing the domain </h3>

<p>
The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are \( t_n=n\Delta t \), \( n=0,1,\ldots,N_t \),
where \( \Delta t = T/N_t \) is the constant length of the time steps.
We introduce a mesh function \( u^n \) for \( n=0,1,\ldots,N_t \), which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.

<h3 id="___sec4">Step 2: Fulfilling the equation at discrete time points </h3>

<p>
The ODE is to be satisfied at each mesh point:

$$
\begin{equation}
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
\tp
\tag{3}
\end{equation}
$$

<h3 id="___sec5">Step 3: Replacing derivatives by finite differences </h3>

<p>
The derivative \( u^{\prime\prime}(t_n) \) is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is

$$
\begin{equation}
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\tp
\tag{4}
\end{equation}
$$

Inserting <a href="#mjx-eqn-4">(4)</a> in <a href="#mjx-eqn-3">(3)</a>
yields

$$
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\tp
\tag{5}
\end{equation}
$$

<p>
We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for \( u^{\prime\prime} \):

$$
\begin{equation}
\frac{u^1-u^{-1}}{2\Delta t} = 0
\tag{6}
\tp
\end{equation}
$$

<h3 id="___sec6">Step 4: Formulating a recursive algorithm </h3>

<p>
To formulate the computational algorithm, we assume that we
have already computed \( u^{n-1} \) and \( u^n \) such that \( u^{n+1} \) is the
unknown value, which we can readily solve for:

$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
\tp
\tag{7}
\end{equation}
$$

The computational algorithm is simply to apply <a href="#mjx-eqn-7">(7)</a>
successively for \( n=1,2,\ldots,N_t-1 \). This numerical scheme sometimes
goes under the name
Stormer's
method or <a href="http://en.wikipedia.org/wiki/Verlet_integration" target="_self">Verlet integration</a>.

<h3 id="___sec7">Computing the first step </h3>

<p>
We observe that <a href="#mjx-eqn-7">(7)</a> cannot be used for \( n=0 \) since
the computation of \( u^1 \) then involves the undefined value \( u^{-1} \)
at \( t=-\Delta t \). The discretization of the initial condition
then comes to our rescue: <a href="#mjx-eqn-6">(6)</a> implies \( u^{-1} = u^1 \)
and this relation can be combined with <a href="#mjx-eqn-7">(7)</a>
for \( n=1 \) to yield a value for \( u^1 \):

$$
\begin{equation*} u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\end{equation*}
$$

which reduces to

$$
\begin{equation}
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
\tp
\tag{8}
\end{equation}
$$

<a href="._vib003.html#vib:exer:step4b:alt">Exercise 5: Use a Taylor polynomial to compute \( u^1 \)</a> asks you to perform an alternative derivation
and also to generalize the initial condition to \( u^{\prime}(0)=V\neq 0 \).

<h3 id="___sec8">The computational algorithm </h3>

<p>
The steps for solving <a href="#mjx-eqn-1">(1)</a> becomes

<ol>
 <li> \( u^0=I \)</li>
 <li> compute \( u^1 \) from <a href="#mjx-eqn-8">(8)</a></li>
 <li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <li> compute \( u^{n+1} \) from <a href="#mjx-eqn-7">(7)</a></li>
</ol>

</ol>

The algorithm is more precisely expressed directly in Python:

<p>

<!-- code=text (!bc cod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t = linspace(0, T, Nt+1)  # mesh points in time
dt = t[1] - t[0]          # constant time step
u = zeros(Nt+1)           # solution

u[0] = I
u[1] = u[0] - 0.5*dt**2*w**2*u[0]
for n in range(1, Nt):
    u[n+1] = 2*u[n] - u[n-1] - dt**2*w**2*u[n]
</pre></div>
<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remark on using <code>w</code> for \( \omega \).</b>
In the code, we use <code>w</code> as the symbol for \( \omega \).
The reason is that this author prefers <code>w</code> for readability
and comparison with the mathematical \( \omega \) instead of
the full word <code>omega</code> as variable name.
</div>


<h3 id="___sec9">Operator notation </h3>

<p>
We may write the scheme using a compact difference notation
(see also 
<a href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#compact-operator-notation-for-finite-differences" target="_self">examples</a> in <a href="._vib003.html#Langtangen_decay">[1]</a>).
The difference <a href="#mjx-eqn-4">(4)</a> has the operator
notation \( [D_tD_t u]^n \) such that we can write:

$$
\begin{equation}
[D_tD_t u  + \omega^2 u = 0]^n
\tp
\tag{9}
\end{equation}
$$

Note that \( [D_tD_t u]^n \) means applying a central difference with step \( \Delta t/2 \) twice:

$$ [D_t(D_t u)]^n = \frac{[D_t u]^{n+\half} - [D_t u]^{n-\half}}{\Delta t}$$

which is written out as
$$
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\tp
$$

<p>
The discretization of initial conditions can in the operator notation
be expressed as
$$
\begin{equation}
[u = I]^0,\quad [D_{2t} u = 0]^0,
\end{equation}
$$

where the operator \( [D_{2t} u]^n \) is defined as
$$
\begin{equation}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\tp
\end{equation}
$$

<h1 id="vib:impl1">Implementation</h1>

<h2 id="vib:impl1:solver">Making a solver function</h2>

<p>
The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
\( u^0,u^1,\ldots,u^{N_t} \) and \( t_0,t_1,\ldots,t_{N_t} \), given the
input \( I \), \( \omega \), \( \Delta t \), and \( T \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, w, dt, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    by a central finite difference method with time step dt.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
We do a simple <code>from module import *</code> to make the code as close as
possible to MATLAB, although good programming habits would prefix
the <code>numpy</code> and <code>matplotlib</code> calls by (abbreviations of) the module
name.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 2</b>: Refer to right section in decay book for prefix discussion.)</font>
<!-- end inline comment -->

<p>
A function for plotting the numerical and the exact solution is also
convenient to have:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_exact</span>(t, I, w):
    <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>cos(w<span style="color: #666666">*</span>t)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">visualize</span>(u, t, I, w):
    plot(t, u, <span style="color: #BA2121">&#39;r--o&#39;</span>)
    t_fine <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, t[<span style="color: #666666">-1</span>], <span style="color: #666666">1001</span>)  <span style="color: #408080; font-style: italic"># very fine mesh for u_e</span>
    u_e <span style="color: #666666">=</span> u_exact(t_fine, I, w)
    hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plot(t_fine, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)
    legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
    xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
    title(<span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> dt)
    umin <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span>u<span style="color: #666666">.</span>min();  umax <span style="color: #666666">=</span> <span style="color: #666666">-</span>umin
    axis([t[<span style="color: #666666">0</span>], t[<span style="color: #666666">-1</span>], umin, umax])
    savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>);  savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>)
</pre></div>
<p>
A corresponding main program calling these functions for a simulation
of a given number of periods (<code>num_periods</code>) may take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">I <span style="color: #666666">=</span> <span style="color: #666666">1</span>
w <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi
dt <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
num_periods <span style="color: #666666">=</span> <span style="color: #666666">5</span>
P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w    <span style="color: #408080; font-style: italic">#  one period</span>
T <span style="color: #666666">=</span> P<span style="color: #666666">*</span>num_periods
u, t <span style="color: #666666">=</span> solver(I, w, dt, T)
visualize(u, t, I, w, dt)
</pre></div>
<p>
Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <code>ArgumentParser</code> tool in
the <code>argparse</code> module to define option value (<code>--option value</code>)
pairs on the command line:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--I&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=1.0</span>)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--w&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=2*</span>pi)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--dt&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=0.05</span>)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--num_periods&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>, default<span style="color: #666666">=5</span>)
a <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
I, w, dt, num_periods <span style="color: #666666">=</span> a<span style="color: #666666">.</span>I, a<span style="color: #666666">.</span>w, a<span style="color: #666666">.</span>dt, a<span style="color: #666666">.</span>num_periods
</pre></div>
<p>
Such parsing of the command line is explained in more detailed in
 the
"section on user interfaces": "..." in <a href="._vib003.html#Langtangen_decay">[1]</a>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: Fix reference to web document.)</font>
<!-- end inline comment -->

<p>
A typical execution goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>

<h3 id="___sec12">Computing \( u^{\prime} \) </h3>

<p>
In mechanical vibration applications one is often interested in
computing the velocity \( v(t)=u^{\prime}(t) \) after \( u(t) \) has been computed.
This can be done by a central difference,

$$
\begin{equation}
v(t_n)=u^{\prime}(t_n) \approx v^n = \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\tp
\end{equation}
$$

This formula applies for all inner mesh points, \( n=1,\ldots,N_t-1 \).
For \( n=0 \), \( v(0) \) is given by the initial condition on \( u^{\prime}(0) \),
and for \( n=N_t \) we can use a one-sided, backward difference:

$$ v^n=[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}\tp$$

<p>
Typical (scalar) code is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(u)  <span style="color: #408080; font-style: italic"># or v = np.zeros(len(u))</span>
<span style="color: #408080; font-style: italic"># Use central difference for internal points</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(u)<span style="color: #666666">-1</span>):
    v[i] <span style="color: #666666">=</span> (u[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> u[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>dt)
<span style="color: #408080; font-style: italic"># Use initial condition for u&#39;(0) when i=0</span>
v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #408080; font-style: italic"># Use backward difference at the final mesh point</span>
v[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> u[<span style="color: #666666">-2</span>])<span style="color: #666666">/</span>dt
</pre></div>
<p>
We can get rid of the loop, which is slow for large \( N_t \), by
vectorizing the central difference. The above code segment
goes as follows in its vectorized version:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(u)
v[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u[:<span style="color: #666666">-2</span>])<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>dt)  <span style="color: #408080; font-style: italic"># central difference</span>
v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>                           <span style="color: #408080; font-style: italic"># boundary condition u&#39;(0)</span>
v[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> u[<span style="color: #666666">-2</span>])<span style="color: #666666">/</span>dt         <span style="color: #408080; font-style: italic"># backward difference</span>
</pre></div>

<h2 id="vib:ode1:verify">Verification</h2>

<h3 id="___sec14">Manual calculation </h3>

<p>
The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute \( u^1 \), \( u^2 \), and \( u^3 \)
with the aid of a calculator
and make a function for comparing these results with those from the <code>solver</code>
function. The <code>test_three_steps</code> function in
the file <a href="http://tinyurl.com/nm5587k/vib/vib_undamped.py" target="_self"><tt>vib_undamped.py</tt></a>
shows the details how we use the hand calculations to test the code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_three_steps</span>():
    I <span style="color: #666666">=</span> <span style="color: #666666">1</span>;  w <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi;  dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>;  T <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    u_by_hand <span style="color: #666666">=</span> array([<span style="color: #666666">1.000000000000000</span>,
                       <span style="color: #666666">0.802607911978213</span>,
                       <span style="color: #666666">0.288358920740053</span>])
    u, t <span style="color: #666666">=</span> solver(I, w, dt, T)
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_by_hand <span style="color: #666666">-</span> u[:<span style="color: #666666">3</span>])<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
</pre></div>

<h3 id="___sec15">Testing very simple solutions </h3>

<p>
Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here \( [D_tD_tt^2]^n=2 \), which is the exact
result. A solution \( u=t^2 \) leads to \( u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0 \).  We must therefore add a source in the equation: \( u^{\prime\prime} +
\omega^2 u = f \) to allow a solution \( u=t^2 \) for \( f=(\omega t)^2 \).  By
simple insertion we can show that the mesh function \( u^n = t_n^2 \) is
also a solution of the discrete equations.  <a href="._vib003.html#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!

<h3 id="___sec16">Checking convergence rates </h3>

<p>
Empirical computation of convergence rates
yields a good method for verification. The method and its computational
are explained in detail for a simple ODE model in the section on <a href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#computing-convergence-rates" target="_self">computing convergence rates</a>
in <a href="._vib003.html#Langtangen_decay">[1]</a>. Readers not familiar with the concept should
look up this reference before proceeding.

<p>
In the present problem, computing convergence rates means that we must

<ul>
 <li> perform \( m \) simulations with halved time steps: \( \Delta t_i=2^{-i}\Delta t_0 \), \( i=0,\ldots,m-1 \),</li>
 <li> compute the \( L^2 \) norm of the error,
   \( E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2} \) in each case,</li>
 <li> estimate the convergence rates \( r_i \) based on two consecutive
   experiments \( (\Delta t_{i-1}, E_{i-1}) \) and \( (\Delta t_{i}, E_{i}) \),
   assuming \( E_i=C(\Delta t_i)^{r} \) and \( E_{i-1}=C(\Delta t_{i-1})^{r} \).
   From these equations it follows that
   \( r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i) \). Since this \( r \)
   will vary with \( i \), we equip it with an index and call it \( r_{i-1} \),
   where \( i \) runs from \( 1 \) to \( m-1 \).</li>
</ul>

The computed rates \( r_0,r_1,\ldots,r_{m-2} \) hopefully converges to a
number, which hopefully is 2, the right one, in the present
problem. The convergence of the rates demands that the time steps
\( \Delta t_i \) are sufficiently small for the error model \( E_i=(\Delta t_i)^r \)
to be valid.

<p>
All the implementational details of computing the sequence
\( r_0,r_1,\ldots,r_{m-2} \) appear below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rates</span>(m, solver_function, num_periods<span style="color: #666666">=8</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #BA2121; font-style: italic">    based on m simulations, where the time step is halved</span>
<span style="color: #BA2121; font-style: italic">    for each simulation.</span>
<span style="color: #BA2121; font-style: italic">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span style="color: #BA2121; font-style: italic">    is based on simulation for num_periods periods.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    w <span style="color: #666666">=</span> <span style="color: #666666">0.35</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>       <span style="color: #408080; font-style: italic"># just chosen values</span>
    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w              <span style="color: #408080; font-style: italic"># period</span>
    dt <span style="color: #666666">=</span> P<span style="color: #666666">/30</span>               <span style="color: #408080; font-style: italic"># 30 time step per period 2*pi/w</span>
    T <span style="color: #666666">=</span> P<span style="color: #666666">*</span>num_periods

    dt_values <span style="color: #666666">=</span> []
    E_values <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        u, t <span style="color: #666666">=</span> solver_function(I, w, dt, T)
        u_e <span style="color: #666666">=</span> u_exact(t, I, w)
        E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>((u_e<span style="color: #666666">-</span>u)<span style="color: #666666">**2</span>))
        dt_values<span style="color: #666666">.</span>append(dt)
        E_values<span style="color: #666666">.</span>append(E)
        dt <span style="color: #666666">=</span> dt<span style="color: #666666">/2</span>

    r <span style="color: #666666">=</span> [log(E_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>E_values[i])<span style="color: #666666">/</span>
         log(dt_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>dt_values[i])
         <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, m, <span style="color: #666666">1</span>)]
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
The expected convergence rate is 2, because we have used
a second-order finite
difference approximations \( [D_tD_tu]^n \) to the ODE and a
second-order finite difference formula for the initial condition for
\( u^{\prime} \). Other theoretical error measures also points to
\( r=2 \).

<p>
In the present problem, when \( \Delta t_0 \) corresponds to 30 time steps
per period, the returned <code>r</code> list has all its values equal to 2.00
(if rounded to two decimals). This amazing result means that all
\( \Delta t_i \) values are well into the asymptotic regime where the
error model \( E_i = C(\Delta t_i)^r \) is valid.

<p>
We can now construct a test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. This unit test
goes like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence_rates</span>():
    r <span style="color: #666666">=</span> convergence_rates(m<span style="color: #666666">=5</span>, solver_function<span style="color: #666666">=</span>solver, num_periods<span style="color: #666666">=8</span>)
    <span style="color: #408080; font-style: italic"># Accept rate to 1 decimal place</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(r[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2.0</span>) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
The complete code appears in the file <code>vib_undamped.py</code>.

<h2 id="___sec17">Scaled model </h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 4</b>: Need reference to scaling book and maybe also decay book.)</font>
<!-- end inline comment -->

<p>
It is advantageous to use dimensionless variables in simulations, because
fewer parameters need to be set. The present problem is made dimensionless
by introducing dimensionless variables \( \bar t = t/t_c \) and \( \bar u = u/u_c \),
where \( t_c \) and \( u_c \) are characteristic scales for \( t \) and \( u \),
respectively. The scaled ODE problem reads

$$ \frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0\tp$$

A common choice is to take \( t_c \) as one period of
the oscillations, \( t_c = 2\pi/w \), and \( u_c=I \).
This gives the dimensionless model

$$
\begin{equation}
\frac{d^2\bar u}{\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\ 
\bar u^{\prime}(0)=0\tp
\tag{10}
\end{equation}
$$

Observe that there are no physical parameters in <a href="#mjx-eqn-10">(10)</a>!
We can therefore perform
a single numerical simulation \( \bar u(\bar t) \) and afterwards
recover any \( u(t; \omega, I) \) by

$$ u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(omega t/(2\pi))\tp$$

<p>
We can easily check this assertion: the solution of the scaled problem
is \( \bar u(\bar t) = \cos(2\pi\bar t) \). The formula for \( u \) in terms
of \( \bar u \) gives \( u = I\cos(\omega t) \), which is nothing but the solution
of the original problem with dimensions.

<p>
The scaled model can by run by calling <code>solver(I=1, w=2*pi, dt, T)</code>.
Each period is now 1 and <code>T</code> simply counts the number of periods.
Choosing <code>dt</code> as <code>1./M</code> gives <code>M</code> time steps per period.

<h1 id="vib:ode1:longseries">Long time simulations</h1>

<p>
Figure <a href="#vib:ode1:2dt">1</a> shows a comparison of the exact and numerical
solution for the scaled model <a href="#mjx-eqn-10">(10)</a> with
\( \Delta t=0.1, 0.05 \).
From the plot we make the following observations:

<ul>
 <li> The numerical solution seems to have correct amplitude.</li>
 <li> There is a angular frequency error which is reduced by reducing the time step.</li>
 <li> The total angular frequency error grows with time.</li>
</ul>

By angular frequency error we mean that the numerical angular frequency differs
from the exact \( \omega \). This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematical expressed by writing the numerical solution
as \( I\cos\tilde\omega t \), where \( \tilde\omega \) is not exactly
equal to \( \omega \). Later, we shall mathematically
quantify this numerical angular frequency \( \tilde\omega \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Effect of halving the time step. <div id="vib:ode1:2dt"></div> </p></center>
<p><img src="fig-vib/vib_freq_err1.png" align="bottom" width=800></p>
</center>

<h2 id="___sec19">Using a moving plot window </h2>

<p>
In vibration problems it is often of interest to investigate the system's
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the \( p \) most recently computed periods of the solution. The
<a href="https://github.com/hplgit/scitools" target="_self">SciTools</a> package contains
a convenient tool for this: <code>MovingPlotWindow</code>. Typing
<code>pydoc scitools.MovingPlotWindow</code> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <code>main</code> function the <code>vib_undamped</code> module
if the number of periods in the simulation exceeds 10.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">visualize_front</span>(u, t, I, w, savefig<span style="color: #666666">=</span><span style="color: #008000">False</span>, skip_frames<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Visualize u and the exact solution vs t, using a</span>
<span style="color: #BA2121; font-style: italic">    moving plot window and continuous drawing of the</span>
<span style="color: #BA2121; font-style: italic">    curves as they evolve in time.</span>
<span style="color: #BA2121; font-style: italic">    Makes it easy to plot very long time series.</span>
<span style="color: #BA2121; font-style: italic">    Plots are saved to files if savefig is True.</span>
<span style="color: #BA2121; font-style: italic">    Only each skip_frames-th plot is saved (e.g., if</span>
<span style="color: #BA2121; font-style: italic">    skip_frame=10, only each 10th plot is saved to file;</span>
<span style="color: #BA2121; font-style: italic">    this is convenient if plot files corresponding to</span>
<span style="color: #BA2121; font-style: italic">    different time steps are to be compared).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">st</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.MovingPlotWindow</span> <span style="color: #008000; font-weight: bold">import</span> MovingPlotWindow

    <span style="color: #408080; font-style: italic"># Remove all old plot files tmp_*.png</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">glob</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
    <span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> glob<span style="color: #666666">.</span>glob(<span style="color: #BA2121">&#39;tmp_*.png&#39;</span>):
        os<span style="color: #666666">.</span>remove(filename)

    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w  <span style="color: #408080; font-style: italic"># one period</span>
    umin <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span>u<span style="color: #666666">.</span>min();  umax <span style="color: #666666">=</span> <span style="color: #666666">-</span>umin
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
    plot_manager <span style="color: #666666">=</span> MovingPlotWindow(
        window_width<span style="color: #666666">=8*</span>P,
        dt<span style="color: #666666">=</span>dt,
        yaxis<span style="color: #666666">=</span>[umin, umax],
        mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;continuous drawing&#39;</span>)
    frame_counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,<span style="color: #008000">len</span>(u)):
        <span style="color: #008000; font-weight: bold">if</span> plot_manager<span style="color: #666666">.</span>plot(n):
            s <span style="color: #666666">=</span> plot_manager<span style="color: #666666">.</span>first_index_in_plot
            st<span style="color: #666666">.</span>plot(t[s:n<span style="color: #666666">+1</span>], u[s:n<span style="color: #666666">+1</span>], <span style="color: #BA2121">&#39;r-1&#39;</span>,
                    t[s:n<span style="color: #666666">+1</span>], I<span style="color: #666666">*</span>cos(w<span style="color: #666666">*</span>t)[s:n<span style="color: #666666">+1</span>], <span style="color: #BA2121">&#39;b-1&#39;</span>,
                    title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%6.3f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n],
                    axis<span style="color: #666666">=</span>plot_manager<span style="color: #666666">.</span>axis(),
                    show<span style="color: #666666">=</span><span style="color: #AA22FF; font-weight: bold">not</span> savefig) <span style="color: #408080; font-style: italic"># drop window if savefig</span>
            <span style="color: #008000; font-weight: bold">if</span> savefig <span style="color: #AA22FF; font-weight: bold">and</span> n <span style="color: #666666">%</span> skip_frames <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
                filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> frame_counter
                st<span style="color: #666666">.</span>savefig(filename)
                <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;making plot file&#39;</span>, filename, <span style="color: #BA2121">&#39;at t=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n]
                frame_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        plot_manager<span style="color: #666666">.</span>update(n)
</pre></div>
<p>
We run the scaled problem (the default values for the command-line arguments
<code>--I</code> and <code>--w</code> correspond to the scaled problem) for 40 periods with 20
time steps per period:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
<p>
The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, but it becomes more
prominent with time. A new run with \( \Delta t=0.1 \) (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.

<h2 id="vib:ode1:anim">Making animations</h2>

<h3 id="___sec21">Producing standard video formats </h3>

<p>
The <code>visualize_front</code> function stores all the plots in
files whose names are numbered:
<code>tmp_0000.png</code>, <code>tmp_0001.png</code>, <code>tmp_0002.png</code>,
and so on. From these files we may make a movie. The Flash
format is popular,

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; ffmpeg -r 12 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
<p>
The <code>ffmpeg</code> program can be replaced by the <code>avconv</code> program in
the above command if desired (but at the time of this writing it seems
to be more momentum in the <code>ffmpeg</code> project).
The <code>-r</code> option should come first and
describes the number of frames per second in the movie. The
<code>-i</code> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Format</b></td> <td align="center"><b>          Codec and filename         </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   Flash     </td> <td align="left">   <code>-c:v flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4       </td> <td align="left">   <code>-c:v libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   WebM      </td> <td align="left">   <code>-c:v libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg       </td> <td align="left">   <code>-c:v libtheora movie.ogg</code>    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-5 -->
<p>
The video file can be played by some video player like <code>vlc</code>, <code>mplayer</code>,
<code>gxine</code>, or <code>totem</code>, e.g.,

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; vlc movie.webm
</pre></div>
<p>
A web page can also be used to play the movie. Today's standard is
to use the HTML5 <code>video</code> tag:

<p>

<!-- code=html (!bc htmlcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">&lt;video</span> <span style="color: #7D9029">autoplay</span> <span style="color: #7D9029">loop</span> <span style="color: #7D9029">controls</span>
       <span style="color: #7D9029">width=</span><span style="color: #BA2121">&#39;640&#39;</span> <span style="color: #7D9029">height=</span><span style="color: #BA2121">&#39;365&#39;</span> <span style="color: #7D9029">preload=</span><span style="color: #BA2121">&#39;none&#39;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;source</span> <span style="color: #7D9029">src=</span><span style="color: #BA2121">&#39;movie.webm&#39;</span>  <span style="color: #7D9029">type=</span><span style="color: #BA2121">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;/video&gt;</span>
</pre></div>
<p>
Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads

<p>

<!-- code=html (!bc htmlcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">&lt;video</span> <span style="color: #7D9029">autoplay</span> <span style="color: #7D9029">loop</span> <span style="color: #7D9029">controls</span>
       <span style="color: #7D9029">width=</span><span style="color: #BA2121">&#39;640&#39;</span> <span style="color: #7D9029">height=</span><span style="color: #BA2121">&#39;365&#39;</span> <span style="color: #7D9029">preload=</span><span style="color: #BA2121">&#39;none&#39;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;source</span> <span style="color: #7D9029">src=</span><span style="color: #BA2121">&#39;movie.mp4&#39;</span>   <span style="color: #7D9029">type=</span><span style="color: #BA2121">&#39;video/mp4;</span>
<span style="color: #BA2121"> codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;source</span> <span style="color: #7D9029">src=</span><span style="color: #BA2121">&#39;movie.webm&#39;</span>  <span style="color: #7D9029">type=</span><span style="color: #BA2121">&#39;video/webm;</span>
<span style="color: #BA2121"> codecs=&quot;vp8, vorbis&quot;&#39;</span><span style="color: #008000; font-weight: bold">&gt;</span>
<span style="color: #008000; font-weight: bold">&lt;/video&gt;</span>
</pre></div>
<p>
The MP4 format should appear first to ensure that Apple devices will
load the video correctly.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Caution: number the plot files correctly.</b>
To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code>%04d</code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code>tmp_*.png</code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code>tmp_11.png</code> would appear
before <code>tmp_2.png</code> in the movie.
</div>


<h3 id="___sec22">Paying PNG files in a web browser </h3>

<p>
The <code>scitools movie</code> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <code>tmp_*.png</code> goes like

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
<p>
The <code>fps</code> argument controls the speed of the movie (&quot;frames per second&quot;).

<p>
To watch the movie, load the video file <code>vib.html</code> into some browser, e.g.,
<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
<p>
Clicking on <code>Start movie</code> to see the result. Moving this movie to
some other place requires moving <code>vib.html</code> <em>and all the PNG files</em>
<code>tmp_*.png</code>:
<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; mkdir vib_dt0.1
Terminal&gt; mv tmp_*.png vib_dt0.1
Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>

<h3 id="___sec23">Making animated GIF files </h3>

<p>
The <code>convert</code> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
<p>
The <code>-delay</code> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with \( \Delta t=0.05 \) and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 5</b>: Combine two simulations side by side!)</font>
<!-- end inline comment -->

<h2 id="___sec24">Using a line-by-line ascii plotter </h2>

<p>
Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen.
The tool
<code>scitools.avplotter.Plotter</code> makes it easy to create such plots:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">visualize_front_ascii</span>(u, t, I, w, fps<span style="color: #666666">=10</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Plot u and the exact solution vs t line by line in a</span>
<span style="color: #BA2121; font-style: italic">    terminal window (only using ascii characters).</span>
<span style="color: #BA2121; font-style: italic">    Makes it easy to plot very long time series.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.avplotter</span> <span style="color: #008000; font-weight: bold">import</span> Plotter
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w
    umin <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span>u<span style="color: #666666">.</span>min();  umax <span style="color: #666666">=</span> <span style="color: #666666">-</span>umin

    p <span style="color: #666666">=</span> Plotter(ymin<span style="color: #666666">=</span>umin, ymax<span style="color: #666666">=</span>umax, width<span style="color: #666666">=60</span>, symbols<span style="color: #666666">=</span><span style="color: #BA2121">&#39;+o&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(u)):
        <span style="color: #008000; font-weight: bold">print</span> p<span style="color: #666666">.</span>plot(t[n], u[n], I<span style="color: #666666">*</span>cos(w<span style="color: #666666">*</span>t[n])), \ 
              <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.1f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t[n]<span style="color: #666666">/</span>P)
        time<span style="color: #666666">.</span>sleep(<span style="color: #666666">1/</span><span style="color: #008000">float</span>(fps))

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    main()
    <span style="color: #008000">raw_input</span>()
</pre></div>
<p>
The call <code>p.plot</code> returns a line of text, with the \( t \) axis marked and
a symbol <code>+</code> for the first function (<code>u</code>) and <code>o</code> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (\( \omega =2\pi \), \( \Delta t=0.05 \))
looks like this:

<p>

<!-- code=text (!bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">                              |                       o+      14.0
                              |                      + o      14.0
                              |                  +    o       14.1
                              |             +     o           14.1
                              |     +        o                14.2
                             +|       o                       14.2
                     +        |                               14.2
              +       o       |                               14.3
         +     o              |                               14.4
      +   o                   |                               14.4
     +o                       |                               14.5
     o +                      |                               14.5
      o    +                  |                               14.6
          o      +            |                               14.6
               o        +     |                               14.7
                      o       | +                             14.7
                              |        +                      14.8
                              |       o       +               14.8
                              |              o     +          14.9
                              |                   o   +       14.9
                              |                       o+      15.0
</pre></div>

<h2 id="vib:ode1:empirical">Empirical analysis of the solution</h2>

<p>
For oscillating functions like those in Figure <a href="#vib:ode1:2dt">1</a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points \( (t_n, u_n) \) and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the \( u \) value at a maximum and a nearby
minimum gives an estimate of the local amplitude.

<p>
The local maxima are the points where
$$
\begin{equation}
u^{n-1} < u^n > u^{n+1},\quad n=1,\ldots,N_t-1,
\end{equation}
$$

and the local minima are recognized by
$$
\begin{equation}
u^{n-1} > u^n < u^{n+1},\quad n=1,\ldots,N_t-1
\tp
\end{equation}
$$

In computer code this becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">minmax</span>(t, u):
    minima <span style="color: #666666">=</span> []; maxima <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(u)<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">&gt;</span> u[n] <span style="color: #666666">&lt;</span> u[n<span style="color: #666666">+1</span>]:
            minima<span style="color: #666666">.</span>append((t[n], u[n]))
        <span style="color: #008000; font-weight: bold">if</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">&lt;</span> u[n] <span style="color: #666666">&gt;</span> u[n<span style="color: #666666">+1</span>]:
            maxima<span style="color: #666666">.</span>append((t[n], u[n]))
    <span style="color: #008000; font-weight: bold">return</span> minima, maxima
</pre></div>
<p>
Note that the two returned objects are lists of tuples.

<p>
Let \( (t_i, e_i) \), \( i=0,\ldots,M-1 \), be the sequence of all
the \( M \) maxima points, where \( t_i \)
is the time value and \( e_i \) the corresponding \( u \) value.
The local period can be defined as \( p_i=t_{i+1}-t_i \).
With Python syntax this reads

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">periods</span>(maxima):
    p <span style="color: #666666">=</span> [extrema[n][<span style="color: #666666">0</span>] <span style="color: #666666">-</span> maxima[n<span style="color: #666666">-1</span>][<span style="color: #666666">0</span>]
         <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(maxima))]
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>array(p)
</pre></div>
<p>
The list <code>p</code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code>2*pi/p</code>.

<p>
Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">amplitudes</span>(minima, maxima):
    a <span style="color: #666666">=</span> [(<span style="color: #008000">abs</span>(maxima[n][<span style="color: #666666">1</span>] <span style="color: #666666">-</span> minima[n][<span style="color: #666666">1</span>]))<span style="color: #666666">/2.0</span>
         <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">min</span>(<span style="color: #008000">len</span>(minima),<span style="color: #008000">len</span>(maxima)))]
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>array(a)
</pre></div>
<p>
The code segments are found in the file <a href="http://tinyurl.com/nm5587k/vib/vib_empirical_analysis.py" target="_self"><tt>vib_empirical_analysis.py</tt></a>.

<p>
Since <code>a[i]</code> and <code>p[i]</code> correspond to
the \( i \)-th amplitude estimate and the \( i \)-th period estimate, respectively,
it is most convenient to visualize the <code>a</code> and <code>p</code> values with the
index <code>i</code> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)

<p>
In the analysis of very long time series, it is advantageous to
compute and plot <code>p</code> and <code>a</code> instead of \( u \) to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and \( \Delta t=0.1, 0.05, 0.01 \).
A ready-made function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot_empirical_freq_and_amplitude(u, t, I, w)
</pre></div>
<p>
computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <code>I</code>
and the exact angular frequency <code>w</code>. We can make a little program
for creating the plot:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">vib_undamped</span> <span style="color: #008000; font-weight: bold">import</span> solver, plot_empirical_freq_and_amplitude
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi
dt_values <span style="color: #666666">=</span> [<span style="color: #666666">0.1</span>, <span style="color: #666666">0.05</span>, <span style="color: #666666">0.01</span>]
u_cases <span style="color: #666666">=</span> []
t_cases <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
    <span style="color: #408080; font-style: italic"># Simulate scaled problem for 40 periods</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, w<span style="color: #666666">=2*</span>pi, dt<span style="color: #666666">=</span>dt, T<span style="color: #666666">=40</span>)
    u_cases<span style="color: #666666">.</span>append(u)
    t_cases<span style="color: #666666">.</span>append(t)
plot_empirical_freq_and_amplitude(u_cases, t_cases, I<span style="color: #666666">=1</span>, w<span style="color: #666666">=2*</span>pi)
</pre></div>
<p>
Figure <a href="#vib:ode1:fig:freq_ampl">2</a> shows the result: we clearly see that
lowering \( \Delta t \) improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
\( \Delta t=0.01 \), corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good and frequencies
are more inaccurate.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Empirical amplitude and angular frequency for three cases of time steps. <div id="vib:ode1:fig:freq_ampl"></div> </p></center>
<p><img src="fig-vib/empirical_ampl_freq.png" align="bottom" width=800></p>
</center>

<p>
<!-- Use it for very long time integration of CN! And of RK4! -->

<h1 id="vib:ode1:analysis">Analysis of the numerical scheme</h1>

<h2 id="___sec27">Deriving a solution of the numerical scheme </h2>

<p>
After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
<a href="#mjx-eqn-7">(7)</a> has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
\( u^n=CA^n \), where \( A \) is some number
to be determined from the difference equation and \( C \) is found as the
initial condition (\( C=I \)).  Recall that \( n \) in \( u^n \) is a
superscript labeling the time level, while \( n \) in \( A^n \) is an
exponent.

<p>
With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an \( A \) on the form

$$ A=e^{i\tilde\omega \Delta t},$$

and solve for the numerical frequency \( \tilde\omega \) rather than
\( A \). Note that \( i=\sqrt{-1} \) is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have

$$
A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t} =
\cos (\tilde\omega t) + i\sin(\tilde \omega t)
\tp
$$

The physically relevant numerical solution can
be taken as the real part of this complex expression.

<p>
The calculations go as

$$
\begin{align*}
[D_tD_t u]^n &= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\ 
&= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\ 
&= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t+\Delta t)} - 2e^{i\tilde\omega t} + e^{i\tilde\omega(t-\Delta t)})\\ 
&= Ie^{i\tilde\omega t}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\ 
&= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\ 
&= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\ 
&= -Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
$$

The last line follows from the relation
\( \cos x - 1 = -2\sin^2(x/2) \) (try <code>cos(x)-1</code> in
<a href="http://www.wolframalpha.com" target="_self">wolframalpha.com</a> to see the formula).

<p>
The scheme <a href="#mjx-eqn-7">(7)</a>
with \( u^n=Ie^{i\omega\tilde\Delta t\, n} \) inserted now gives

$$
\begin{equation}
-Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 Ie^{i\tilde\omega t} = 0,
\end{equation}
$$

which after dividing by \( Ie^{i\tilde\omega t} \) results in
$$
\begin{equation}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\tp
\end{equation}
$$

The first step in solving for the unknown \( \tilde\omega \) is
$$ \sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\tp
$$

Then, taking the square root, applying the inverse sine function, and
multiplying by \( 2/\Delta t \), results in
$$
\begin{equation}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\tp
\tag{11}
\end{equation}
$$

<p>
The first observation of <a href="#mjx-eqn-11">(11)</a> tells that
there is a phase error since the numerical frequency \( \tilde\omega \)
never equals the exact frequency \( \omega \). But how good is
the approximation <a href="#mjx-eqn-11">(11)</a>? That is, what
is the error \( \omega - \tilde\omega \) or \( \tilde\omega/\omega \)?
Taylor series expansion
for small \( \Delta t \) may give an expression that is easier to understand
than the complicated function in <a href="#mjx-eqn-11">(11)</a>:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dt, w <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;dt w&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_e <span style="color: #666666">=</span> <span style="color: #666666">2/</span>dt<span style="color: #666666">*</span>asin(w<span style="color: #666666">*</span>dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_series <span style="color: #666666">=</span> w_tilde_e<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> w_tilde_series
w <span style="color: #666666">+</span> dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
This means that

<p>
<!-- See vib_symbolic.py for computations with sympy -->
$$
\begin{equation}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
+ \Oof{\Delta t^4}
\tp
\tag{12}
\end{equation}
$$

The error in the numerical frequency is of second-order in
\( \Delta t \), and the error vanishes as \( \Delta t\rightarrow 0 \).
We see that \( \tilde\omega > \omega \) since the term \( \omega^3\Delta t^2/24 >0 \)
and this is by far the biggest term in the series expansion for small
\( \omega\Delta t \). A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore &quot;lags behind&quot; the exact
oscillations, a feature that can be seen in the left plot in Figure
<a href="#vib:ode1:2dt">1</a>.

<p>
Figure <a href="#vib:ode1:tildeomega:plot">3</a> plots the discrete frequency
<a href="#mjx-eqn-11">(11)</a>
and its approximation <a href="#mjx-eqn-12">(12)</a> for \( \omega =1 \) (based
on the program <a href="http://tinyurl.com/nm5587k/vib/vib_plot_freq.py" target="_self"><tt>vib_plot_freq.py</tt></a>).
Although \( \tilde\omega \) is a function of \( \Delta t \) in
<a href="#mjx-eqn-12">(12)</a>,
it is misleading to think of \( \Delta t \) as the important
discretization parameter. It is the product \( \omega\Delta t \) that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set \( P=N_P\Delta t \), where \( P \) is the length of
a period, and \( N_P \) is the number of time steps during a period.
Since \( P \) and \( \omega \) are related by \( P=2\pi/\omega \),
we get that \( \omega\Delta t = 2\pi/N_P \), which shows that
\( \omega\Delta t \) is directly related to \( N_P \).

<p>
The plot shows
that at least \( N_P\sim 25-30 \) points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (\( T \)) as
the total phase error due to the frequency error grows linearly with time
(see <a href="._vib003.html#vib:exer:phase:err:growth">Exercise 2: Show linear growth of the phase with time</a>).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Exact discrete frequency and its second-order series expansion. <div id="vib:ode1:tildeomega:plot"></div> </p></center>
<p><img src="fig-vib/discrete_freq.png" align="bottom" width=400></p>
</center>

<h2 id="vib:ode1:analysis:sol">Exact discrete solution</h2>

<p>
Perhaps more important than the \( \tilde\omega = \omega + {\cal O}(\Delta t^2) \)
result found above is the fact that we have an exact discrete solution of
the problem:

$$
\begin{equation}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\tp
\tag{13}
\end{equation}
$$

We can then compute the error mesh function

$$
\begin{equation}
e^n = \uex(t_n) - u^n =
I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right)\tp
\tag{14}
\end{equation}
$$

From the formula \( \cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y) \) we can
rewrite \( e^n \) so the expression is easier to interpret:

$$
\begin{equation}
e^n = -2I\sin\left(t\half\left( \omega - \tilde\omega\right)\right)
\sin\left(t\half\left( \omega + \tilde\omega\right)\right)\tp
\tag{15}
\end{equation}
$$

<p>
The error mesh function is ideal for verification purposes
and you are strongly encouraged to make a test based on <a href="#mjx-eqn-13">(13)</a>
by doing <a href="._vib003.html#vib:exer:discrete:omega">Exercise 10: Use an exact discrete solution for verification</a>.

<h2 id="vib:ode1:analysis:conv">Convergence</h2>

<p>
We can use <a href="#mjx-eqn-12">(12)</a>, <a href="#mjx-eqn-14">(14)</a>, or
<a href="#mjx-eqn-15">(15)</a> to show <em>convergence</em> of the
numerical scheme, i.e., \( e^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
We have that

$$
\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,
$$

by L'Hopital's rule or simply asking <code>sympy</code> or
<a href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0" target="_self">WolframAlpha</a> about the limit:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dt, w <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x w&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> sym<span style="color: #666666">.</span>limit((<span style="color: #666666">2/</span>dt)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>asin(w<span style="color: #666666">*</span>dt<span style="color: #666666">/2</span>), dt, <span style="color: #666666">0</span>, <span style="color: #008000">dir</span><span style="color: #666666">=</span><span style="color: #BA2121">&#39;+&#39;</span>)
w
</pre></div>
<p>
Also <a href="#mjx-eqn-12">(12)</a> can be used to establish
this result that
\( \tilde\omega\rightarrow\omega \). It then follows from the expression(s)
for \( e^n \) that \( e^n\rightarrow 0 \).

<h2 id="___sec30">The global error </h2>

<p>
To achieve more analytical insight into the nature of the global error,
we can Taylor expand the error mesh function <a href="#mjx-eqn-14">(14)</a>.
Since \( \tilde\omega \) in <a href="#mjx-eqn-11">(11)</a>
contains \( \Delta t \) in the denominator we use the series expansion
for \( \tilde\omega \) inside the cosine function. A relevant <code>sympy</code>
session is

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dt, w, t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;dt w t&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_e <span style="color: #666666">=</span> <span style="color: #666666">2/</span>dt<span style="color: #666666">*</span>asin(w<span style="color: #666666">*</span>dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_series <span style="color: #666666">=</span> w_tilde_e<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_series
w <span style="color: #666666">+</span> dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
Series expansions in <code>sympy</code> have the inconvenient <code>O()</code> term that
prevents further calculations with the series. We can use the
<code>removeO()</code> command to get rid of the <code>O()</code> term:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_series <span style="color: #666666">=</span> w_tilde_series<span style="color: #666666">.</span>removeO()
<span style="color: #666666">&gt;&gt;&gt;</span> w_tilde_series
dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> w
</pre></div>
<p>
Using this <code>w_tilde_series</code> expression
for \( \tilde w \) in <a href="#mjx-eqn-14">(14)</a>,
dropping \( I \) (which is a common factor), and performing a series
expansion of the error yields

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> error <span style="color: #666666">=</span> cos(w<span style="color: #666666">*</span>t) <span style="color: #666666">-</span> cos(w_tilde_series<span style="color: #666666">*</span>t)
<span style="color: #666666">&gt;&gt;&gt;</span> error<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">6</span>)
dt<span style="color: #666666">**2*</span>t<span style="color: #666666">*</span>w<span style="color: #666666">**3*</span>sin(t<span style="color: #666666">*</span>w)<span style="color: #666666">/24</span> <span style="color: #666666">+</span> dt<span style="color: #666666">**4*</span>t<span style="color: #666666">**2*</span>w<span style="color: #666666">**6*</span>cos(t<span style="color: #666666">*</span>w)<span style="color: #666666">/1152</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**6</span>)
</pre></div>
<p>
Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in \( \Delta t \) and
goes most slowly to zero), we use the <code>.as_leading_term(dt)</code>
construction to pick out this term:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> error<span style="color: #666666">.</span>series(dt, <span style="color: #666666">0</span>, <span style="color: #666666">6</span>)<span style="color: #666666">.</span>as_leading_term(dt)
dt<span style="color: #666666">**2*</span>t<span style="color: #666666">*</span>w<span style="color: #666666">**3*</span>sin(t<span style="color: #666666">*</span>w)<span style="color: #666666">/24</span>
</pre></div>
<p>
The last result
means that the leading order global (true) error at a point \( t \)
is proportional to \( \omega^3t\Delta t^2 \). Now, \( t \) is related
to \( \Delta t \) through \( t=n\Delta t \). The factor
\( \sin(\omega t) \) can at most be 1, so we use this value to
bound the leading-order expression to its maximum value

$$ e^n = \frac{1}{24}n\omega^3\Delta t^3\tp$$

This is the dominating term of the error <em>at a point</em>.

<p>
We are interested in the accumulated global error, which can
be taken as the \( \ell^2 \) norm of \( e^n \).
The norm is simply computed by summing contributions from all mesh
points:

$$ ||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2\tp$$

The sum \( \sum_{n=0}^{N_t} n^2 \) is approximately equal to
\( \frac{1}{3}N_t^3 \). Replacing \( N_t \) by \( T/\Delta t \) and taking
the square root gives the expression

$$ ||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2\tp$$

This is our expression for the global (or integrated) error.
The main result from this expression is that also the global error
is proportional to \( \Delta t^2 \).

<h2 id="___sec31">Stability </h2>

<p>
Looking at <a href="#mjx-eqn-13">(13)</a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only \( \Delta t \) is large
enough, the magnitude of the argument to \( \sin^{-1} \) in
<a href="#mjx-eqn-11">(11)</a> may be larger than 1, i.e.,
\( \omega\Delta t/2 > 1 \). In this case, \( \sin^{-1}(\omega\Delta t/2) \)
has a complex value and therefore \( \tilde\omega \) becomes complex.
Type, for example, <code>asin(x)</code> in
<a href="http://www.wolframalpha.com" target="_self">wolframalpha.com</a> to see basic properties of \( \sin^{-1} (x) \)).

<p>
A complex \( \tilde\omega \) can be written \( \tilde\omega = \tilde\omega_r +
i\tilde\omega_i \). Since \( \sin^{-1}(x) \) has a <em>negative</em> imaginary part for
\( x>1 \), \( \tilde\omega_i < 0 \), which means that
\( e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t} \)
will lead to exponential growth in time because
\( e^{-\tilde\omega_i t} \) with \( \tilde\omega_i < 0 \) has a positive
exponent.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Stability criterion.</b>
We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em>  that
the argument in the inverse sine function leads
to real and not complex values of \( \tilde\omega \). The stability
criterion reads

$$
\begin{equation}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\tp
\end{equation}
$$
</div>


<p>
With \( \omega =2\pi \), \( \Delta t > \pi^{-1} = 0.3183098861837907 \) will give
growing solutions. Figure <a href="#vib:ode1:dt:unstable">4</a>
displays what happens when \( \Delta t =0.3184 \),
which is slightly above the critical value: \( \Delta t =\pi^{-1} + 9.01\cdot
10^{-5} \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Growing, unstable solution because of a time step slightly beyond the stability limit. <div id="vib:ode1:dt:unstable"></div> </p></center>
<p><img src="fig-vib/vib_unstable.png" align="bottom" width=400></p>
</center>

<h2 id="___sec32">About the accuracy at the stability limit </h2>

<p>
An interesting question is whether the stability condition
\( \Delta t < 2/\omega \) is unfortunate, or more precisely:
would it be meaningful to take larger time steps to speed up computations?
The answer is a clear no. At the stability limit, we have that
\( \sin^{-1}\omega\Delta t/2 = \sin^{-1} 1 = \pi/2 \), and therefore
\( \tilde\omega = \pi/\Delta t \). (Note that the approximate formula
<a href="#mjx-eqn-12">(12)</a> is very inaccurate for this
value of \( \Delta t \) as it predicts \( \tilde\omega = 2.34/pi \), which is
a 25 percent reduction.) The corresponding
period of the numerical solution
is \( \tilde P=2\pi/\tilde\omega = 2\Delta t \), which means that there is
just one time step \( \Delta t \) between a peak (maximum)
and a <a href="https://simple.wikipedia.org/wiki/Wave_(physics)" target="_self">through</a>
(minimum) in the
numerical solution. This is the shortest possible wave that can be
represented in the mesh! In other words, it is not meaningful to
use a larger time step than the stability limit.

<p>
Also, the error in angular frequency
when \( \Delta t = 2/\omega \) is severe: Figure
<a href="#vib:ode1:dt:stablimit">5</a> shows a comparison of the numerical and
analytical solution with \( \omega = 2\pi \) and
\( \Delta t = 2/\omega = \pi^{-1} \). Already after one period, the
numerical solution has a through while the exact solution has a peak (!).
The error in frequency when \( \Delta t \) is at the stability limit
becomes \( \omega - \tilde\omega = \omega(1-\pi/2)\approx -0.57\omega \).
The corresponding error in the period is \( P - \tilde P \approx 0.36P \).
The error after \( m \) periods is then \( 0.36mP \). This error has reached
half a period when \( m=1/(2\cdot 0.36)\approx 1.38 \), which theoretically
confirms the observations in Figure <a href="#vib:ode1:dt:stablimit">5</a>
that the numerical solution is a through ahead of a peak already after
one and a half period. Consequently, \( \Delta t \) should be chosen much
less than the stability limit to achieve meaningful numerical computations.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Numerical solution with \( \Delta t \) exactly at the stability limit. <div id="vib:ode1:dt:stablimit"></div> </p></center>
<p><img src="fig-vib/vib_stability_limit.png" align="bottom" width=400></p>
</center>

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Summary.</b>
From the accuracy and stability
analysis we can draw three important conclusions:

<ol>
<li> The key parameter in the formulas is \( p=\omega\Delta t \).
   The period of oscillations is \( P=2\pi/\omega \), and the
   number of time steps per period is \( N_P=P/\Delta t \).
   Therefore, \( p=\omega\Delta t = 2\pi N_P \), showing that the
   critical parameter is the number of time steps per period.
   The smallest possible \( N_P \) is 2, showing that \( p\in (0,\pi] \).</li>
<li> Provided \( p\leq 2 \), the amplitude of the numerical solution is
   constant.</li>
<li> The ratio of the numerical angular frequency and the exact
   one is
   \( \tilde\omega/\omega \approx 1 + \frac{1}{24}p^2 \).
   The error \( \frac{1}{24}p^2 \) leads to wrongly displaced peaks of the numerical
   solution, and the error in peak location grows linearly with time
   (see <a href="._vib003.html#vib:exer:phase:err:growth">Exercise 2: Show linear growth of the phase with time</a>).</li>
</ol>
</div>


<h1 id="vib:model2x2">Alternative schemes based on 1st-order equations</h1>

<p>
A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then choose a
solution strategy from the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem
$$ u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,$$

we introduce the auxiliary variable \( v=u^{\prime} \) and express the ODE problem
in terms of first-order derivatives of \( u \) and \( v \):

$$
\begin{align}
u^{\prime} &= v,
\tag{16}\\ 
v' &= -\omega^2 u
\tag{17}
\tp
\end{align}
$$

The initial conditions become \( u(0)=I \) and \( v(0)=0 \).

<h2 id="___sec34">The Forward Euler scheme </h2>

<p>
A Forward Euler approximation to our \( 2\times 2 \) system of ODEs
<a href="#mjx-eqn-16">(16)</a>-<a href="#mjx-eqn-17">(17)</a>
becomes

$$
\begin{align}
\lbrack D_t^+ u = v\rbrack^n,
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,
\end{align}
$$

or written out,

$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,
\tag{18}\\ 
v^{n+1} &= v^n -\Delta t \omega^2 u^n
\tag{19}
\tp
\end{align}
$$

<p>
Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from <a href="#mjx-eqn-18">(18)</a> and
<a href="#mjx-eqn-19">(19)</a> applied at levels \( n \) and \( n-1 \) that

$$ u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}\tp$$

Since from <a href="#mjx-eqn-18">(18)</a>
$$ v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),$$

it follows that

$$ u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},$$

which is very close to the centered difference scheme, but
the last term is evaluated at \( t_{n-1} \) instead of \( t_n \).
Dividing by \( \Delta t^2 \), the left-hand side is an approximation to
\( u^{\prime\prime} \) at \( t_n \), while the right-hand side is sampled at \( t_{n-1} \).
All terms should be sampled at the same mesh point, so using
\( \omega^2 u^{n-1} \) instead of \( \omega^2 u^n \) is an inconsistency
in the scheme. This inconsistency turns out to be rather
crucial for the accuracy of
the Forward Euler method applied to vibration problems.

<h2 id="___sec35">The Backward Euler scheme </h2>

<p>
A Backward Euler approximation the ODE system is equally easy to
write up in the operator notation:

$$
\begin{align}
\lbrack D_t^- u &= v\rbrack^{n+1},\\ 
\lbrack D_t^- v &= -\omega u\rbrack^{n+1} \tp
\end{align}
$$

This becomes a coupled system for \( u^{n+1} \) and \( v^{n+1} \):

$$
\begin{align}
u^{n+1} - \Delta t v^{n+1} &= u^{n},
\tag{20}\\ 
v^{n+1} + \Delta t \omega^2 u^{n+1} &= v^{n}
\tag{21}
\tp
\end{align}
$$

<p>
We can compare <a href="#mjx-eqn-20">(20)</a>-<a href="#mjx-eqn-21">(21)</a> with
the centered scheme <a href="#mjx-eqn-7">(7)</a>
for the second-order differential equation.
To this end, we eliminate \( v^{n+1} \) in <a href="#mjx-eqn-20">(20)</a>
using <a href="#mjx-eqn-21">(21)</a> solved with respect to \( v^{n+1} \).
Thereafter, we eliminate \( v^n \) using <a href="#mjx-eqn-20">(20)</a>
solved with respect to \( v^{n+1} \) and replacing \( n+1 \) by \( n \).
The resulting equation involving only \( u^{n+1} \), \( u^n \), and \( u^{n-1} \)
can be ordered as

$$ \frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},$$

which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at \( u^{n+1} \) and not \( u^n \). This inconsistent sampling
of terms has a dramatic effect on the numerical solution.

<h2 id="___sec36">The Crank-Nicolson scheme </h2>

<p>
The Crank-Nicolson scheme takes this form in the operator notation:

$$
\begin{align}
\lbrack D_t u &= \overline{v}^t\rbrack^{n+\half},\\ 
\lbrack D_t v &= -\omega \overline{u}^t\rbrack^{n+\half}
\tp
\end{align}
$$

Writing the equations out shows that this is also a coupled system:

$$
\begin{align}
u^{n+1} - \half\Delta t v^{n+1} &= u^{n} + \half\Delta t v^{n},\\ 
v^{n+1} + \half\Delta t \omega^2 u^{n+1} &= v^{n}
- \half\Delta t \omega^2 u^{n}
\tp
\end{align}
$$

<p>
To see the nature of this approximation, and that it is actually
very promising, we write the equations as follows

$$
\begin{align}
u^{n+1} - u^n &= \frac{1}{2}\Delta t(v^{n+1} + v^n),
\tag{22}\\ 
v^{n+1}  &= v^n -\frac{1}{2}\Delta t(u^{n+1} + u^n),
\tag{23}
\end{align}
$$

and add the latter at the previous time level as well:

$$
\begin{equation}
v^{n}  = v^{n-1} -\frac{1}{2}\Delta t(u^{n} + u^{n-1})
\tag{25}
\end{equation}
$$

We can also rewrite (<a href="#vib:undamped:CN3a">vib:undamped:CN3a</a>) at the previous time level
as

$$
\begin{equation}
v^{n+1} + v^n = \frac{2}{\Delta t}(u^{n+1} - u^n)\tp
\tag{25}
\end{equation}
$$

Inserting <a href="#mjx-eqn-23">(23)</a> for \( v^{n+1} \) in
(ref<div id="vib:undamped:CN3a"></div>) and
<a href="#mjx-eqn-25">(25)</a> for \( v^{n} \) in
(ref<div id="vib:undamped:CN3a"></div>) yields after some reordering:

$$ u^{n+1} - n^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^ + v^{n-1})\tp$$

Now, \( v^n + v^{n-1} \) can be eliminated by means of
<a href="#mjx-eqn-25">(25)</a>. The result becomes

$$
\begin{equation}
u^{n+1} - 2u^n + u^{n-1} = \Delta t^2\omega^2
\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1})\tp
\tag{26}
\end{equation}
$$

We have that

$$ \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + \Oof{\Delta t^2},$$

meaning that <a href="#mjx-eqn-26">(26)</a> is an approximation to
the centered scheme <a href="#mjx-eqn-7">(7)</a> for the second-order ODE where
the sampling error in the term \( \Delta t^2\omega^2 u^n \) is of the same
order as the approximation errors in the finite differences, i.e.,
\( \Oof{\Delta t^2} \). The Crank-Nicolson scheme written as
<a href="#mjx-eqn-26">(26)</a> therefore has consistent sampling of all
terms at the same time point \( t_n \). The implication is a much better
method than the Forward and Backward Euler schemes.

<h2 id="vib:model2x2:compare">Comparison of schemes</h2>

<p>
We can easily compare methods like the ones above (and many more!)
with the aid of the
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a> package. Below is
a sketch of the code.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t, w<span style="color: #666666">=1</span>):
    u, v <span style="color: #666666">=</span> u  <span style="color: #408080; font-style: italic"># u is array of length 2 holding our [u, v]</span>
    <span style="color: #008000; font-weight: bold">return</span> [v, <span style="color: #666666">-</span>w<span style="color: #666666">**2*</span>u]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">run_solvers_and_plot</span>(solvers, timesteps_per_period<span style="color: #666666">=20</span>,
                         num_periods<span style="color: #666666">=1</span>, I<span style="color: #666666">=1</span>, w<span style="color: #666666">=2*</span>np<span style="color: #666666">.</span>pi):
    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">/</span>w  <span style="color: #408080; font-style: italic"># duration of one period</span>
    dt <span style="color: #666666">=</span> P<span style="color: #666666">/</span>timesteps_per_period
    Nt <span style="color: #666666">=</span> num_periods<span style="color: #666666">*</span>timesteps_per_period
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt
    t_mesh <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)

    legends <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
        solver<span style="color: #666666">.</span>set(f_kwargs<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;w&#39;</span>: w})
        solver<span style="color: #666666">.</span>set_initial_condition([I, <span style="color: #666666">0</span>])
        u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t_mesh)
</pre></div>
<p>
There is quite some more code dealing with plots also, and we refer
to the source file <a href="http://tinyurl.com/nm5587k/vib/vib_undamped_odespy.py" target="_self"><tt>vib_undamped_odespy.py</tt></a>
for details. Observe that keyword arguments in <code>f(u,t,w=1)</code> can
be supplied through a solver parameter <code>f_kwargs</code> (dictionary of
additional keyword arguments to <code>f</code>).

<p>
Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solvers <span style="color: #666666">=</span> [
    odespy<span style="color: #666666">.</span>ForwardEuler(f),
    <span style="color: #408080; font-style: italic"># Implicit methods must use Newton solver to converge</span>
    odespy<span style="color: #666666">.</span>BackwardEuler(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>),
    odespy<span style="color: #666666">.</span>CrankNicolson(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>),
    ]
</pre></div>
<p>
The <code>vib_undamped_odespy.py</code>
program makes two plots of the computed solutions with the various
methods in the <code>solvers</code> list: one plot with \( u(t) \) versus \( t \), and
one <em>phase plane plot</em> where \( v \) is plotted against \( u \).
That is, the phase plane plot is the curve \( (u(t),v(t)) \) parameterized
by \( t \). Analytically, \( u=I\cos(\omega t) \) and \( v=u^{\prime}=-\omega I\sin(\omega t) \).
The exact curve \( (u(t),v(t)) \) is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that exact curve \( (u(t),v(t)) \) is
closed and repeats itself for every period. Not all numerical schemes
are capable of doing that, meaning that the amplitude instead shrinks or
grows with time.

<p>
Figure
<a href="#vib:ode1:1st:odespy:theta:phaseplane">6</a> show the results. Note that
Odespy applies the label MidpointImplicit for what we have specified
as <code>CrankNicolson</code> in the code (<code>CrankNicolson</code> is just a synonym for
class <code>MidpointImplicit</code> in the Odespy code).
The Forward Euler scheme in Figure
<a href="#vib:ode1:1st:odespy:theta:phaseplane">6</a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a href="#vib:ode1:1st:odespy:theta">7</a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Comparison of classical schemes in the phase plane for two time step values. <div id="vib:ode1:1st:odespy:theta:phaseplane"></div> </p></center>
<p><img src="fig-vib/vib_theta_1_pp.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Comparison of solution curves for classical schemes. <div id="vib:ode1:1st:odespy:theta"></div> </p></center>
<p><img src="fig-vib/vib_theta_1_u.png" align="bottom" width=800></p>
</center>

<h2 id="___sec38">Runge-Kutta methods </h2>

<p>
We may run two popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a href="#vib:ode1:1st:odespy:RK:phaseplane">8</a> and
<a href="#vib:ode1:1st:odespy:RK">9</a> show the solutions with larger \( \Delta
t \) values than what was used in the previous two plots.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Comparison of Runge-Kutta schemes in the phase plane. <div id="vib:ode1:1st:odespy:RK:phaseplane"></div> </p></center>
<p><img src="fig-vib/vib_RK_1_pp.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Comparison of Runge-Kutta schemes. <div id="vib:ode1:1st:odespy:RK"></div> </p></center>
<p><img src="fig-vib/vib_RK_1_u.png" align="bottom" width=800></p>
</center>

<p>
The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, while the 2nd-order scheme suffers from amplitude errors
unless the time step is very small.

<p>
The corresponding results for the Crank-Nicolson scheme are shown in
Figure <a href="#vib:ode1:1st:odespy:CN:long:phaseplane">10</a>.
It is clear that the Crank-Nicolson
scheme outperforms the 2nd-order Runge-Kutta method. Both schemes have
the same order of accuracy \( \Oof{\Delta t^2} \), but their differences
in the accuracy that matters in a real physical application is very
clearly pronounced in this example.  <a href="._vib003.html#vib:exer:undamped:odespy">Exercise 12: Investigate the amplitude errors of many solvers</a> invites you to investigate how the amplitude
is computed by a series of famous methods for first-order ODEs.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Long-time behavior of the Crank-Nicolson scheme in the phase plane. <div id="vib:ode1:1st:odespy:CN:long:phaseplane"></div> </p></center>
<p><img src="fig-vib/vib_CN_10_pp.png" align="bottom" width=800></p>
</center>

<h2 id="___sec39">Analysis of the Forward Euler scheme </h2>

<p>
We may try to find exact solutions of the discrete
equations <a href="#mjx-eqn-18">(18)</a>-<a href="#mjx-eqn-19">(19)</a>
in the Forward Euler method. An &quot;ansatz&quot;
is

$$
\begin{align*}
u^n &= IA^n,\\ 
v^n &= qIA^n,
\end{align*}
$$

where \( q \) and \( A \) are unknown numbers. We could have used a complex
exponential form \( e^{i\tilde\omega n\Delta t} \) since we get
oscillatory form, but the oscillations grow in the Forward Euler
method, so the numerical frequency \( \tilde\omega \) will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex \( A \) and \( q \) as introduced
above.

<p>
The Forward Euler scheme leads to

$$
\begin{align*}
A &= 1 + \Delta t q,\\ 
A &= 1 - \Delta t\omega^2 q^{-1}\tp
\end{align*}
$$

We can easily eliminate \( A \), get \( q^2 + \omega^2=0 \), and solve for

$$ q = \pm i\omega,$$

which gives

$$ A = 1 \pm \Delta t i\omega\tp$$

We shall take the real part of \( A^n \) as the solution. The two
values of \( A \) are complex conjugates, and the real part of
\( A^n \) will be the same for both roots. This is easy to realize if
we rewrite the complex numbers in polar form,
which is also convenient
for further analysis and understanding.
The polar form \( re^{i\theta} \) of a complex number \( x+iy \) has
\( r=\sqrt{x^2+y^2} \) and \( \theta = \tan^{-1}(y/x) \).
Hence, the polar form of the two values for \( A \) become

$$ 1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}\tp$$

Now it is very easy to compute \( A^n \):

$$ (1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}\tp$$

Since \( \cos (\theta n) = \cos (-\theta n) \), the real part of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.

<p>
The general solution is \( u^n = CA^n \), where
\( C \) is a constant determined from the initial condition:
\( u^0=C=I \). We have \( u^n=IA^n \) and
\( v^n=qIA^n \). The final solutions
are just the real part of the expressions in polar form:

$$
\begin{align}
u^n & =
I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),\\ 
v^n &=- \omega
I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t))\tp
\end{align}
$$

The expression \( (1+\omega^2\Delta t^2)^{n/2} \) causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent \( n/2 \). We can develop a series expression to better understand
the formula for the amplitude. Introducing \( p=\omega\Delta t \) as the
key variable and using <code>sympy</code> gives

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;p&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> n <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;n&#39;</span>, integer<span style="color: #666666">=</span><span style="color: #008000">True</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> amplitude <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">+</span> p<span style="color: #666666">**2</span>)<span style="color: #666666">**</span>(n<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> amplitude<span style="color: #666666">.</span>series(p, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
<span style="color: #666666">1</span> <span style="color: #666666">+</span> n<span style="color: #666666">*</span>p<span style="color: #666666">**2/2</span> <span style="color: #666666">+</span> O(p<span style="color: #666666">**4</span>)
</pre></div>
<p>
The amplitude goes like \( 1 + \half n\omega^2\Delta t^2 \), clearly growing
linearly in time (with \( n \)).

<p>
We can also investigate the error in the angular frequency by a
series expansion:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> n<span style="color: #666666">*</span>atan(p)<span style="color: #666666">.</span>series(p, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
n<span style="color: #666666">*</span>(p <span style="color: #666666">-</span> p<span style="color: #666666">**3/3</span> <span style="color: #666666">+</span> O(p<span style="color: #666666">**4</span>))
</pre></div>
<p>
This means that the solution for \( u^n \) can be written as

$$ u^n = (1 + \half n\omega^2\Delta t^2 + \Oof(\Delta t^4))
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + \Oof{\Delta t^4}\right)
\tp$$

The error in the angular frequency is of the same order as in the
scheme <a href="#mjx-eqn-7">(7)</a> for the second-order ODE, but error
in the amplitude is severe.

<h1 id="vib:model1:energy">Energy considerations</h1>

<p>
The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,

$$ E(t) = \half(u^{\prime})^2 + \half\omega^2u^2,$$

is <em>constant</em> for all \( t \). Checking that \( E(t) \) really remains constant
brings evidence that the numerical computations are sound.
It turns out that \( E \) is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations.

<h2 id="___sec41">Derivation of the energy expression </h2>

<p>
We start out with multiplying

$$ u^{\prime\prime} + \omega^2 u = 0,$$

by \( u^{\prime} \) and integrating from \( 0 \) to \( T \):

$$ \int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0\tp$$

Observing that

$$ u^{\prime\prime}u^{\prime} = \frac{d}{dt}\half(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\half}u^2,$$

we get

$$
\int_0^T (\frac{d}{dt}\half(u^{\prime})^2 + \frac{d}{dt} \half\omega^2u^2)dt = E(T) - E(0)=0,
$$

where we have introduced

$$
\begin{equation}
E(t) = \half(u^{\prime})^2 + \half\omega^2u^2\tp
\tag{27}
\end{equation}
$$

The important result from this derivation is that the total energy
is constant:

$$ E(t) = E(0)\tp$$

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>\( E(t) \) is closely related to the system's energy.</b>
The quantity \( E(t) \) derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton's second law \( F=ma \) (\( F \) is the sum of forces, \( m \)
is the mass of the system, and \( a \) is the acceleration).
The displacement \( u \) is related to \( a \) through
\( a=u^{\prime\prime} \). With a spring force as the only force we have \( F=-ku \), where
\( k \) is a spring constant measuring the stiffness of the spring.
Newton's second law then implies the differential equation

$$ -ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0\tp$$

This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval \( [0,T] \).
To this end, we multiply the equation by \( du=u^{\prime}dt \) and integrate:

$$ \int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0\tp$$

The result is

$$ \tilde E(t) = E_k(t) + E_p(t) = 0,$$

where

$$
\begin{equation}
E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},
\tag{28}
\end{equation}
$$

is the <em>kinetic energy</em> of the system, and

$$
\begin{equation}
E_p(t) = {\half}ku^2
\tag{29}
\end{equation}
$$

is the <em>potential energy</em>. The sum \( \tilde E(t) \) is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in system, as we do in the section <a href="._vib003.html#vib:model2">Generalization: damping, nonlinear spring, and external excitation</a>.)

<p>
The equation \( mu^{\prime\prime}+ku=0 \) can be divided by \( m \) and written as
\( u^{\prime\prime} + \omega^2u=0 \) for \( \omega=\sqrt{k/m} \). The energy expression
\( E(t)=\half(u^{\prime})^2 + \half\omega^2u^2 \) derived earlier is then
\( \tilde E(t)/m \), i.e., mechanical energy per unit mass.
</div>


<h3 id="___sec42">Energy of the exact solution  </h3>

<p>
Analytically, we have \( u(t)=I\cos\omega t \), if \( u(0)=I \) and \( u^{\prime}(0)=0 \),
so we can easily check that the energy evolution and confirm that \( E(t) \)
is constant:

$$ E(t) = {\half}I^2 (-\omega\sin\omega t)^2
+ \half\omega^2 I^2 \cos^2\omega t
= \half\omega^2 (\sin^2\omega t + \cos^2\omega t) = \half\omega^2
\tp
$$

<h2 id="___sec43">An error measure based on energy </h2>

<p>
The constant energy is well expressed by its initial value \( E(0) \), so that
the error in mechanical energy can be computed as a mesh function by

$$
\begin{equation}
e_E^n = \half\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
+ \half\omega^2 (u^n)^2 - E(0),
\quad n=1,\ldots,N_t-1,
\end{equation}
$$

where

$$ E(0) = {\half}V^2 + \half\omega^2I^2,$$

if \( u(0)=I \) and \( u^{\prime}(0)=V \). Note that we have used
a centered approximation to \( u^{\prime} \): \( \u^{\prime}(t_n)\approx
[D_{2t}u]^n \).

<p>
A useful norm of the mesh function \( e_E^n \)
for the discrete mechanical energy
can be the maximum absolute value of \( e_E^n \):

$$ ||e_E^n||_{\ell^\infty} = \max_{1\leq n < N_t} |e_E^n|\tp$$

Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.

<p>
A vectorized Python implementation takes the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># import numpy as np and compute u, t</span>
dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>t[<span style="color: #666666">0</span>]
E <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>((u[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u[:<span style="color: #666666">-2</span>])<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>dt))<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>w<span style="color: #666666">**2*</span>u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]<span style="color: #666666">**2</span>
E0 <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>V<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">0.5**</span>w<span style="color: #666666">**2*</span>I<span style="color: #666666">**2</span>
e_E <span style="color: #666666">=</span> E <span style="color: #666666">-</span> E0
e_E_norm <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(e_E)<span style="color: #666666">.</span>max()
</pre></div>
<p>
The convergence rates of the quantity <code>e_E_norm</code> can be used for verification.
The value of <code>e_E_norm</code> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the error in total energy for various schemes. We clearly see that
the Crank-Nicolson and 4th-order Runge-Kutta schemes are superior to
the 2nd-order Runge-Kutta method and better compared to the Forward
and Backward Euler schemes.

<p>

<div class="row">
  <div class="col-xs-9">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>        Method       </b></td> <td align="center">\( T \) </td> <td align="center">\( \Delta t \)</td> <td align="center">\( \max \left\vert e_E^n\right\vert \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   Forward Euler            </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 1.113\cdot 10^{2} \)                   </td> </tr>
<tr><td align="left">   Forward Euler            </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.025 \)       </td> <td align="left">   \( 3.312\cdot 10^{1} \)                   </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 1.683\cdot 10^{1} \)                   </td> </tr>
<tr><td align="left">   Backward Euler           </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.025 \)       </td> <td align="left">   \( 1.231\cdot 10^{1} \)                   </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.1 \)         </td> <td align="left">   \( 8.401 \)                               </td> </tr>
<tr><td align="left">   Runge-Kutta 2nd-order    </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 9.637\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 9.389\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.025 \)       </td> <td align="left">   \( 2.411\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.1 \)         </td> <td align="left">   \( 2.387 \)                               </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   \( 1 \)     </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 6.476\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   \( 10 \)    </td> <td align="left">   \( 0.1 \)         </td> <td align="left">   \( 3.389 \)                               </td> </tr>
<tr><td align="left">   Crank-Nicolson           </td> <td align="left">   \( 10 \)    </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 9.389\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   \( 10 \)    </td> <td align="left">   \( 0.1 \)         </td> <td align="left">   \( 3.686 \)                               </td> </tr>
<tr><td align="left">   Runge-Kutta 4th-order    </td> <td align="left">   \( 10 \)    </td> <td align="left">   \( 0.05 \)        </td> <td align="left">   \( 6.928\cdot 10^{-1} \)                  </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-9 -->
<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 6</b>: The error reductions are not directly in accordance with the order of the schemes, probably caused by \( \Delta t \) not being in the asympotic regime.)</font>
<!-- end inline comment -->

<p>
<!-- Should build a verification test on the energy error. -->

<p>
<!-- Link phase plane plot to energy -->
<!-- A phase plane plot shows the curve \( (u(t), u^{\prime}(t)) \). -->

<h1 id="vib:model2x2:EulerCromer">The Euler-Cromer method</h1>

<p>
While the 4th-order Runge-Kutta method and a
Crank-Nicolson scheme work well for vibration equation modeled as a
first-order ODE system,
both were inferior to the straightforward centered
difference scheme for the second-order equation
\( u^{\prime\prime}+\omega^2u=0 \). However, there is a similarly successful scheme
available for the first-order system \( u^{\prime}=v \), \( v'=-\omega^2u \), to be
presented next.

<h2 id="___sec45">Forward-backward discretization </h2>

<p>
The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as

$$
\begin{align}
\lbrack D_t^+u &= v\rbrack^n,\\ 
\lbrack D_t^-v &= -\omega u\rbrack^{n+1}
\tp
\end{align}
$$

We can write out the formulas and collect the unknowns on the left-hand side:
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,
\tag{30}\\ 
v^{n+1} &= v^n -\Delta t \omega^2u^{n+1}
\tag{31}
\tp
\end{align}
$$

We realize that after \( u^{n+1} \) has been computed from
<a href="#mjx-eqn-30">(30)</a>, it may be used directly
in
<a href="#mjx-eqn-31">(31)</a> to compute \( v^{n+1} \).

<p>
In physics, it is more common to update the \( v \) equation first, with
a forward difference, and thereafter the \( u \) equation, with a backward
difference that applies the most recently computed \( v \) value:

$$
\begin{align}
v^{n+1} &= v^n -\Delta t \omega^2u^{n},
\tag{32}\\ 
u^{n+1} &= u^n + \Delta t v^{n+1}\tp
\tag{33}
\end{align}
$$

The advantage of ordering the ODEs as in
<a href="#mjx-eqn-32">(32)</a>-<a href="#mjx-eqn-33">(33)</a>
becomes evident
when consider complicated models. Such models are included if
we write our vibration ODE more generally as

$$ \ddot u + g(u, u^{\prime}, t)=0\tp$$

We can rewrite this second-order ODE as two first-order ODEs,

$$
\begin{align*}
v' &= -g(u,v,t),\\ 
u^{\prime} &= v\tp
\end{align*}
$$

This rewrite allows the following scheme to be used:

$$
\begin{align*}
v^{n+1} &= v^n -\Delta t\, g(u^n,v^n,t),\\ 
u^{n+1} &= u^n + \Delta t\, v^{n+1}\tp
\end{align*}
$$

We realize that the first update works well with any \( g \) since old
values \( u^n \) and \( v^n \) are used. Switching the equations would
demand \( u^n{+1} \) and \( v^{n+1} \) values in \( g \).

<p>
<!-- Despite using a backward difference, there is no need to solve a coupled -->
<!-- system for \( u^{n+1} \) and \( v^{n+1} \) because the structure of the ODEs -->
<!-- allows <a href="#mjx-eqn-30">(30)</a> -->

<p>
The scheme
<a href="#mjx-eqn-32">(32)</a>-<a href="#mjx-eqn-33">(33)</a>
goes under several names: forward-backward scheme, <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method" target="_self">semi-implicit Euler method</a>, semi-explicit Euler,
symplectic Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is \( \Oof{\Delta t^2} \). This is explained below.

<h2 id="vib:model2x2:EulerCromer:equiv">Equivalence with the scheme for the second-order ODE</h2>

<p>
We may eliminate the \( v^n \) variable from
<a href="#mjx-eqn-30">(30)</a>-<a href="#mjx-eqn-31">(31)</a>
or
<a href="#mjx-eqn-32">(32)</a>-<a href="#mjx-eqn-33">(33)</a>.
The \( v^{n+1} \) term in <a href="#mjx-eqn-32">(32)</a> can
be eliminated from <a href="#mjx-eqn-33">(33)</a>:
$$
\begin{equation}
u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t^2 u^n)\tp
\tag{34}
\end{equation}
$$

The \( v^{n} \) quantity can be expressed by \( u^n \) and \( u^{n-1} \)
using <a href="#mjx-eqn-33">(33)</a>:
$$ v^{n} = \frac{u^n - u^{n-1}}{\Delta t},
$$

and when this is inserted in <a href="#mjx-eqn-34">(34)</a> we get
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},
\end{equation}
$$

which is nothing but the centered scheme <a href="#mjx-eqn-7">(7)</a>!
The two seemingly different numerical methods are mathematically
equivalent. Consequently,
the previous analysis of
<a href="#mjx-eqn-7">(7)</a> also applies to the Euler-Cromer
method. In particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
<a href="#mjx-eqn-12">(12)</a>. <a href="._vib003.html#vib:exer:EulerCromer:analysis">Exercise 17: Analysis of the Euler-Cromer scheme</a>
gives guidance on how to derive the exact discrete solution of
the two equations in the Euler-Cromer method.

<p>
Although the Euler-Cromer scheme and the method <a href="#mjx-eqn-7">(7)</a> are
equivalent, there could be differences in the way they handle
the initial conditions. Let is look into this topic.
The initial condition \( u^{\prime}=0 \) means \( u^{\prime}=v=0 \).  From
<a href="#mjx-eqn-33">(33)</a> we get \( v^1=-\omega^2 u^0 \)
and \( u^1=u^0 - \omega^2\Delta t^2 u^0 \). When using
a centered approximation of \( u^{\prime}(0)=0 \) combined with the
discretization <a href="#mjx-eqn-7">(7)</a> of the second-order ODE, we
get \( u^1=u^0 - \frac{1}{2}\omega^2\Delta t^2 u^0 \). The difference
is \( \frac{1}{2}\omega^2\Delta t^2 u^0 \), which is of second order in \( \Delta t \),
seemingly
consistent with the overall error in the scheme for the differential equation
model.

<p>
A different view can also be taken.
If we approximate \( u^{\prime}(0)=0 \) by a backward difference,
\( (u^0-u^{-1})/\Delta t =0 \), we get \( u^{-1}=u^0 \), and when combined
with <a href="#mjx-eqn-7">(7)</a>, it results in
\( u^1=u^0 - \omega^2\Delta t^2 u^0 \). This means that
the Euler-Cromer method based on
<a href="#mjx-eqn-33">(33)</a>-<a href="#mjx-eqn-32">(32)</a>
corresponds to using only a first-order approximation to the initial condition
in the method from the section <a href="#vib:ode1:fdm">A centered finite difference scheme</a>.

<p>
Correspondingly, using the formulation
<a href="#mjx-eqn-30">(30)</a>-<a href="#mjx-eqn-31">(31)</a>
with \( v^n=0 \) leads to \( u^1=u^0 \), which can be interpreted as using
a forward difference approximation for the initial condition \( u^{\prime}(0)=0 \).
Both Euler-Cromer formulations lead to slightly different values for
\( u^1 \) compared to the method in the section <a href="#vib:ode1:fdm">A centered finite difference scheme</a>.
The error is \( \frac{1}{2}\omega^2\Delta t^2 u^0 \) and of the same order
as the overall scheme.

<h2 id="vib:model2x2:EulerCromer:impl">Implementation</h2>

<p>
The function below, found in <a href="http://tinyurl.com/nm5587k/vib/vib_EulerCromer.py" target="_self"><tt>vib_EulerCromer.py</tt></a> implements the Euler-Cromer scheme
<a href="#mjx-eqn-32">(32)</a>-<a href="#mjx-eqn-33">(33)</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros, linspace

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, w, dt, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve v&#39; = - w**2*u, u&#39;=v for t in (0,T], u(0)=I and v(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    by an Euler-Cromer method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    v <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        v[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> v[n] <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>w<span style="color: #666666">**2*</span>u[n]
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>v[n<span style="color: #666666">+1</span>]
    <span style="color: #008000; font-weight: bold">return</span> u, v, t
</pre></div>
<p>
Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE \( u^{\prime\prime}+\omega^2u=0 \) (see the section <a href="#vib:model2x2:EulerCromer:equiv">Equivalence with the scheme for the second-order ODE</a>), the performance of the above
<code>solver</code> function is the same as for the <code>solver</code> function in the section <a href="#vib:impl1">Implementation</a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a href="#vib:ode1:analysis:sol">Exact discrete solution</a> is not a solution of the Euler-Cromer
scheme!

<p>
To verify the implementation of the Euler-Cromer method we
can adjust <code>v[1]</code> so that the computer-generated values can be
compared with the formula
<a href="#mjx-eqn-13">(13)</a> from in the section <a href="#vib:ode1:analysis:sol">Exact discrete solution</a>. This
adjustment is done in an alternative solver function, <code>solver_ic_fix</code>
in <code>vib_EulerCromer.py</code>. Since we now have an exact solution of the
discrete equations available, we can write a test function
<code>test_solver</code> for checking the equality of computed values with the
formula <a href="#mjx-eqn-13">(13)</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Test solver with fixed initial condition against</span>
<span style="color: #BA2121; font-style: italic">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    I <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>; w <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>; T <span style="color: #666666">=</span> <span style="color: #666666">5</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">2/</span>w  <span style="color: #408080; font-style: italic"># longest possible time step</span>
    u, v, t <span style="color: #666666">=</span> solver_ic_fix(I, w, dt, T)
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">vib_undamped</span> <span style="color: #008000; font-weight: bold">import</span> solver <span style="color: #008000; font-weight: bold">as</span> solver2  <span style="color: #408080; font-style: italic"># 2nd-order ODE</span>
    u2, t2 <span style="color: #666666">=</span> solver2(I, w, dt, T)
    error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u <span style="color: #666666">-</span> u2)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> error <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
Another function, <code>demo</code>,
visualizes the difference between Euler-Cromer scheme and the scheme
<a href="#mjx-eqn-7">(7)</a>
for the second-oder ODE, arising from the mismatch in the first time level.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 7</b>: Odespy's Euler-Cromer, but it needs more work with the example code.)</font>
<!-- end inline comment -->

<p>
<!-- is anything gained? is v of higher order than D_2t u from the -->
<!-- other approach, i.e., if we need v, is this alg better? Probably not -->
<!-- since v is related u through a difference -->

<p>
<!-- make exercises: -->
<!-- investigate how important the u^1 wrong formula really is on -->
<!-- convergence rate -->

<p>
<!-- new file: genealizations, systems, -->
<!-- new file: apps -->

<p>
<!-- exercise: damping analysis, see geophysics book first... -->

<h2 id="___sec48">The velocity Verlet algorithm </h2>

<p>
Another very popular algorithm for vibration problems \( u^{\prime\prime}+\omega^2u=0 \)
can be derived as follows. First, we step \( u \) forward from \( t_n \) to
\( t_{n+1} \) using a three-term Taylor series,

$$ u(t_{n+1}) = u(t_n) + u^{\prime}(t_n)\Delta t + \frac{1}{2}u^{\prime\prime}(t_n)\Delta t^2\tp$$

Using \( u^{\prime}=v \) and \( u^{\prime\prime}=-\omega^2u \), we get the updating formula

$$ u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n\tp$$

Second, the first-order equation for \( v \),

$$ v'=-\omega^2u,$$

is discretized by a centered difference
in a Crank-Nicolson fashion at \( t_{n+\frac{1}{2}} \):

$$ \frac{v^{n+1}-v^n}{\Delta t} = -\omega^2\frac{1}{2}(u^n + u^{n+1})\tp$$

To summarize, we have the scheme

$$
\begin{align}
u^{n+1} &= u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n
\tag{35} \\ 
v^{n+1} &= v^n -\frac{1}{2}\Delta t\omega^2 (u^n + u^{n+1}),
\tag{36}
\end{align}
$$

known as the <em>velocity Verlet</em> algorithm.
Observe that this scheme is explicit since \( u^{n+1} \) in
<a href="#mjx-eqn-36">(36)</a> is already computed
from <a href="#mjx-eqn-35">(35)</a>.

<p>
The algorithm can be straightforwardly implemented as shown below (the
code appears in the file <a href="http://tinyurl.com/nm5587k/vib/vib_undamped_velocity_Verlet.py" target="_self"><tt>vib_undamped_velocity_Verlet.py</tt></a>).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">vib_undamped</span> <span style="color: #008000; font-weight: bold">import</span> (
    zeros, linspace,
    convergence_rates,
    main)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, w, dt, T, return_v<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=v, v&#39;=-w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    by the velocity Verlet method with time step dt.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    v <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> v[n]<span style="color: #666666">*</span>dt <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[n]
        v[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> v[n] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">*</span>w<span style="color: #666666">**2*</span>(u[n] <span style="color: #666666">+</span> u[n<span style="color: #666666">+1</span>])
    <span style="color: #008000; font-weight: bold">if</span> return_v:
        <span style="color: #008000; font-weight: bold">return</span> u, v, t
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #408080; font-style: italic"># Return just u and t as in the vib_undamped.py&#39;s solver</span>
        <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
We provide the option that this <code>solver</code> function returns the same data
as the <code>solver</code> function from the section <a href="#vib:impl1:solver">Making a solver function</a> (if <code>return_v</code>
is <code>False</code>), but we may return <code>v</code> along with <code>u</code> and <code>t</code>.

<p>
The error in the Taylor series expansion behind
<a href="#mjx-eqn-35">(35)</a> is \( \Oof{\Delta t^3} \), while the error
in the central difference for \( v \) is \( \Oof{\Delta t^2} \).  The overall
error is then no better than \( \Oof{\Delta t^2} \), which can be verified
empirically using the <code>convergence_rates</code> function from
<a href="#vib:ode1:verify">Verification</a>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">vib_undamped_velocity_Verlet</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">m</span>
<span style="color: #666666">&gt;&gt;&gt;</span> m<span style="color: #666666">.</span>convergence_rates(<span style="color: #666666">4</span>, solver_function<span style="color: #666666">=</span>m<span style="color: #666666">.</span>solver)
[<span style="color: #666666">2.0036366687367346</span>, <span style="color: #666666">2.0009497328124835</span>, <span style="color: #666666">2.000240105995295</span>]
</pre></div>
<p>
<!-- The output confirms that the overall convergence rate is 2. -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._vib001.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._vib003.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

