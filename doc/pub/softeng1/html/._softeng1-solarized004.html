<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scientific software engineering; ODE model">
<meta name="keywords" content="importing modules,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,doctests,software testing doctests,unit testing,software testing nose,software testing pytest,test function,software testing test function,doctest in test function,unit testing,software testing unit testing (class-based),problem class,solver class,wrapper (code),reproducibility,replicability,Unix wildcard notation,wildcard notation (Unix),Word (Microsoft),LibreOffice,OpenOffice,HTML,MathJax,LaTeX,Sphinx (typesetting tool),Markdown,IPython notebooks,Jupyter notebooks,DocOnce,replicability">

<title>Scientific software engineering; ODE model</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Basic implementations ',
               1,
               'softeng1:basic',
               'softeng1:basic'),
              (' Mathematical problem and solution technique ',
               2,
               'softeng1:basic:math',
               'softeng1:basic:math'),
              (' A first, quick implementation ',
               2,
               'softeng1:basic:impl1',
               'softeng1:basic:impl1'),
              (' A more decent, flat program ',
               2,
               'softeng1:basic:impl2',
               'softeng1:basic:impl2'),
              (' Implementing the numerical algorithm in a function ',
               2,
               'softeng1:basic:func',
               'softeng1:basic:func'),
              (' Making a module ',
               2,
               'softeng1:basic:module',
               'softeng1:basic:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'softeng1:basic:modprefix',
               'softeng1:basic:modprefix'),
              (' Comparing numerical schemes in one plot ',
               2,
               'softeng1:basic:experiment2',
               'softeng1:basic:experiment2'),
              (' Documenting functions and modules ',
               2,
               'softeng1:basic:docstring',
               'softeng1:basic:docstring'),
              (' User interfaces ',
               1,
               'softeng1:basic:UI',
               'softeng1:basic:UI'),
              (' Command-line arguments ', 2, None, '___sec10'),
              (' Positional command-line arguments ', 2, None, '___sec11'),
              (' Option-value pairs on the command line ',
               2,
               None,
               '___sec12'),
              (' Creating a graphical web user interface ',
               2,
               None,
               '___sec13'),
              (' Making a compute function ', 3, None, '___sec14'),
              (' Generating the user interface ', 3, None, '___sec15'),
              (' Running the web application ', 3, None, '___sec16'),
              (' Tests for verifying implementations ', 1, None, '___sec17'),
              (' Doctests ', 2, None, '___sec18'),
              (' Unit tests and test functions ', 2, None, '___sec19'),
              (' Two Python test frameworks: nose and pytest ',
               3,
               None,
               '___sec20'),
              (' Test function requirements ', 3, None, '___sec21'),
              (' Comparison of real numbers ', 3, None, '___sec22'),
              (' Special assert functions from nose ', 3, None, '___sec23'),
              (' Locating test functions ', 3, None, '___sec24'),
              (' Running tests ', 3, None, '___sec25'),
              (' Embedding doctests in a test function ',
               3,
               None,
               '___sec26'),
              (' Installing nose and pytest ', 3, None, '___sec27'),
              (' Test function for the solver ', 2, None, '___sec28'),
              (' Test function for reading positional command-line arguments ',
               2,
               None,
               '___sec29'),
              (' Test function for reading option-value pairs ',
               2,
               None,
               '___sec30'),
              (' Classical class-based unit testing ',
               2,
               'softeng1:basic:unittest',
               'softeng1:basic:unittest'),
              (' Packaging the software for other users ',
               1,
               'softeng1:prog:se:git',
               'softeng1:prog:se:git'),
              (' Software directory tree ', 2, None, '___sec33'),
              (' Distributing just a module file ', 3, None, '___sec34'),
              (' Distributing a package ', 3, None, '___sec35'),
              (' Publishing the software at GitHub ', 2, None, '___sec36'),
              (' Classes for problem and solution method ',
               1,
               'softeng1:prog:se:class',
               'softeng1:prog:se:class'),
              (' The problem class ', 2, None, '___sec38'),
              (' The solver class ', 2, None, '___sec39'),
              (' Combining the objects ', 3, None, '___sec40'),
              (' Improving the problem and solver classes ',
               2,
               'softeng1:prog:se:class2',
               'softeng1:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec42'),
              (' Automating scientific experiments ',
               1,
               'softeng1:experiments',
               'softeng1:experiments'),
              (' Available software ', 2, None, '___sec44'),
              (' Required new results ', 2, None, '___sec45'),
              (' Combining plot files ', 2, None, '___sec46'),
              (' Running a program from Python ', 2, None, '___sec47'),
              (' The automating script ', 2, None, '___sec48'),
              (' Making a report ',
               2,
               'softeng1:exper:report',
               'softeng1:exper:report'),
              (' Word, OpenOffice, GoogleDocs ', 3, None, '___sec50'),
              (' HTML with MathJax ', 3, None, '___sec51'),
              (' LaTeX ', 3, None, '___sec52'),
              (' Sphinx ', 3, None, '___sec53'),
              (' Markdown ', 3, None, '___sec54'),
              (' IPython/Jupyter notebooks ', 3, None, '___sec55'),
              (' Wiki formats ', 3, None, '___sec56'),
              (' DocOnce ', 3, None, '___sec57'),
              (' Publishing a complete project ',
               2,
               'softeng1:exper:github',
               'softeng1:exper:github'),
              (' Exercises ', 1, None, '___sec59'),
              (' Problem 1: Make a tool for differentiating curves ',
               2,
               'softeng1:exer:derivative',
               'softeng1:exer:derivative'),
              (' Problem 2: Make solid software for the Trapezoidal rule ',
               2,
               'softeng1:exer:integral:flat',
               'softeng1:exer:integral:flat'),
              (' Problem 3: Implement classes for the Trapezoidal rule ',
               2,
               'softeng1:exer:integral:flat2',
               'softeng1:exer:integral:flat2'),
              (' Problem 4: Write a doctest and a test function ',
               2,
               'softeng1:exer:doctest1',
               'softeng1:exer:doctest1'),
              (' Exercise 5: Make use of a class implementation ',
               2,
               'softeng1:exer:class:dts',
               'softeng1:exer:class:dts'),
              (' Bibliography ', 1, None, '___sec65')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0004"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng1-solarized003.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng1-solarized005.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec17">Tests for verifying implementations </h1>

<p>
Any module with functions should have a set of tests that can
check the
correctness of the implementations.
There exists
well-established procedures and corresponding tools for automating
the execution of such tests. One can in this way, with a one-line command,
run large test sets and confirm that the software works (as far as the
tests tell!). Here we shall illustrate two important
software testing techniques: <em>doctest</em> and <em>unit testing</em>.
The first one is Python specific, while unit testing is the dominating
test technique for computer software today.

<h2 id="___sec18">Doctests </h2>

<p>
A doc string, the first string after the function header, is used to
document the purpose of functions and their arguments
(see the section <a href="._softeng1-solarized002.html#softeng1:basic:func">Implementing the numerical algorithm in a function</a>). Very often it
is instructive to include an example in the doc string
on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from the statements and expressions.
For example,
we can in the <code>solver</code> function include an example on calling
this function and printing the computed <code>u</code> and <code>t</code> arrays:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>


<span class="sd">    &gt;&gt;&gt; u, t = solver(I=0.8, a=1.2, T=1.5, dt=0.5, theta=0.5)</span>
<span class="sd">    &gt;&gt;&gt; for t_n, u_n in zip(t, u):</span>
<span class="sd">    ...     print &#39;t=%.1f, u=%.14f&#39; % (t_n, u_n)</span>
<span class="sd">    t=0.0, u=0.80000000000000</span>
<span class="sd">    t=0.5, u=0.43076923076923</span>
<span class="sd">    t=1.0, u=0.23195266272189</span>
<span class="sd">    t=1.5, u=0.12489758761948</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
<p>
When such interactive demonstrations are inserted in doc strings,
Python's <a href="http://docs.python.org/library/doctest.html" target="_self"><tt>doctest</tt></a>
module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to run the module file <code>decay.py</code> with

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="n">Terminal</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">doctest</span> <span class="n">decay</span><span class="o">.</span><span class="n">py</span>
</pre></div>
<p>
This command imports the <code>doctest</code> module, which runs all
doctests found in the file and reports discrepancies between
expected and computed output.
Alternatively, the test block in a module may run all doctests
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>
<p>
Doctests can also be embedded in nose/pytest unit tests
as explained in the next section.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Doctests prevent command-line arguments!</b>
<p>
No additional command-line argument is allowed when running doctests.
If your program relies on command-line input, make sure the doctests
can be run <em>without</em> such input.
</div>


<p>
The execution command above will report any problem if a test fails.
For example, changing the last digit <code>8</code> in the output of the doctest
to <code>7</code> triggers a report:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight"><pre>Terminal&gt; python -m doctest decay.py
********************************************************
File &quot;decay.py&quot;, line ...
Failed example:
    for t_n, u_n in zip(t, u):
        print &#39;t=%.1f, u=%.14f&#39; % (t_n, u_n)
Expected:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761947
Got:
    t=0.0, u=0.80000000000000
    t=0.5, u=0.43076923076923
    t=1.0, u=0.23195266272189
    t=1.5, u=0.12489758761948
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Pay attention to the number of digits in doctest results!</b>
<p>
Note that in the output of <code>t</code> and <code>u</code> we write <code>u</code> with 14 digits.
Writing all 16 digits is not a good idea: if the tests are run on
different hardware, round-off errors might be different, and
the <code>doctest</code> module detects that the numbers are not precisely the same
and reports failures. In the present application, where \( 0 < u(t) \leq 0.8 \),
we expect round-off errors to be of size \( 10^{-16} \), so comparing 15
digits would probably be reliable, but we compare 14 to be on the
safe side. On the other hand, comparing a small number of digits may
hide software errors.
</div>


<p>
Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Caution.</b>
<p>
Doctests requires careful coding if they use command-line input or
print results to the terminal window. Command-line input must
be simulated by filling <code>sys.argv</code> correctly, e.g.,
<code>sys.argv = '--I 1.0 --a 5'.split</code>.
The output lines of print statements inside doctests
must be copied exactly as they
appear when running the statements in an interactive Python shell.
</div>


<h2 id="___sec19">Unit tests and test functions </h2>

<p>
The unit testing technique consists of identifying small units
of code, say a function, and write one or more tests for
each unit. One test should, ideally, not depend on the outcome of
other tests. The recommended practice is actually to
design and write the unit tests first and <em>then</em> implement the functions!

<p>
In scientific computing it is not always obvious how to best perform
unit testing. The units is naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit, such as our <code>solver</code> function.

<h3 id="___sec20">Two Python test frameworks: nose and pytest </h3>

<p>
Python offers two very easy-to-use software frameworks for implementing
unit tests: nose and pytest. These work (almost) in the same way,
but my recommendation is to go for pytest.

<h3 id="___sec21">Test function requirements </h3>

<p>
Each test can in these frameworks be realized as a <em>test function</em>
that follows three rules:

<ol>
 <li> The name must start with <code>test_</code>.</li>
 <li> Function arguments are not allowed.</li>
 <li> An <code>AssertionError</code> exception must be raised if the test fails.</li>
</ol>

A specific example might be illustrative before proceeding.
We have the following function that we want to test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span>
</pre></div>
<p>
The corresponding test function may look like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_double</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">4</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">computed</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
<p>
The last two lines, however, are never written like this in test functions.
Instead, use Python's <code>assert</code> statement: <code>assert success, msg</code>, where
<code>success</code> is a boolean variable, which is <code>False</code> if the test fails, and
<code>msg</code> is <em>an optional</em> message string that is printed when the test fails.
A better version of the test function is therefore

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_double</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Test that double(n) works for one specific n.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">4</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;expected </span><span class="si">%g</span><span class="s">, computed </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">computed</span>
    <span class="k">assert</span> <span class="n">success</span><span class="p">,</span> <span class="n">msg</span>
</pre></div>

<h3 id="___sec22">Comparison of real numbers </h3>

<p>
In scientific computing we very often have to deal with real numbers and
finite precision arithmetics (round-off errors)
so the <code>==</code> operator is not suitable for checking that
a test passes. Instead, we must be replace <code>==</code> by a comparison
based on a tolerance. Here is a slightly different function that
we want to test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">third</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="mf">3.</span>
</pre></div>
<p>
We write a test function where the expected result is computed as
\( \frac{1}{3}x \) rather than \( x/3 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_third</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="n">third</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">computed</span>
        <span class="k">assert</span> <span class="n">success</span>
</pre></div>
<p>
This <code>test_third</code> function executes silently, i.e., no failure,
until <code>x</code> becomes 0.15. Then round-off errors make the <code>==</code> comparison
<code>False</code>. In fact, seven <code>x</code> values face this problem.
The solution is to compare <code>expected</code> and <code>computed</code>
with a small tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_third</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that third(x) works for many x values.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="n">third</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
        <span class="n">success</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">assert</span> <span class="n">success</span>
</pre></div>
<p>
Real numbers should never be compared with the <code>==</code> operator, but always
with the absolute value of the difference and a tolerance.

<h3 id="___sec23">Special assert functions from nose </h3>

<p>
The nose test framework contains more tailored
<em>assert functions</em> that can be called instead of using the <code>assert</code>
statement. For example, comparing two objects within
a tolerance, as in the present
case, can be done by <code>assert_almost_equal</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">nose.tools</span> <span class="kn">as</span> <span class="nn">nt</span>

<span class="k">def</span> <span class="nf">test_third</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mf">0.15</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">third</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span>
        <span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-15</span><span class="p">,</span>
        <span class="n">msg</span><span class="o">=</span><span class="s">&#39;diff=</span><span class="si">%.17E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expected</span> <span class="o">-</span> <span class="n">computed</span><span class="p">))</span>
</pre></div>
<p>
Whether to use the plain <code>assert</code> statement with a comparison based on
a tolerance or to use the ready-made function <code>assert_almost_equal</code>
depends on the programmer's preference. The pytest framework (which we
recommend) sticks to the plain <code>assert</code> statement.

<h3 id="___sec24">Locating test functions </h3>

<p>
Test functions can reside in a module together with the functions they
are supposed to verify, or the test functions can be collected in
separate files having names starting with <code>test</code>. Actually,
nose and pytest can automatically recursively run all test functions
in all <code>test*.py</code>
files in the current and all subdirectories!

<p>
The <a href="http://tinyurl.com/nm5587k/softeng1/decay.py" target="_self"><tt>decay.py</tt></a> module file features
test functions in the module, but we could equally well have made
a subdirectory <code>tests</code> and put the test functions in
<a href="http://tinyurl.com/nm5587k/softeng1/tests/test_decay.py" target="_self"><tt>tests/test_decay.py</tt></a>.

<h3 id="___sec25">Running tests </h3>

<p>
To run all test functions in the file <code>decay.py</code> do

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight"><pre>Terminal&gt; nosetests -s -v decay.py
Terminal&gt; py.test -s -v decay.py
</pre></div>
<p>
The <code>-s</code> option ensures that output from the test functions is printed
in the terminal window, and <code>-v</code> prints the outcome of each individual
test function.

<p>
Alternatively, if the test functions are in some separate
<code>test*.py</code> files,
we can just write

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight"><pre>Terminal&gt; py.test -s -v
</pre></div>
<p>
to <em>recursively</em> run <em>all</em> test functions in the current
directory tree. The corresponding

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight"><pre>Terminal&gt; nosetests -s -v
</pre></div>
<p>
command does the same, but requires subdirectory names to start
with <code>test</code> or end with <code>_test</code> or <code>_tests</code> (which is a good habit anyway).
An example of a <code>tests</code> directory with a <code>test*.py</code>
file is found in <a href="http://tinyurl.com/nm5587k/softeng1/tests" target="_self">src/softeng1/tests</a>.

<h3 id="___sec26">Embedding doctests in a test function </h3>

<p>
Doctests can also be executed from nose/pytest unit tests. Here
is an example of a file <a href="http://tinyurl.com/nm5587k/softeng1/tests/test_decay_doctest.py" target="_self"><tt>test_decay_doctest.py</tt></a> where we in the test block run all the doctests
in the imported module <code>decay</code>, but we also include a test function that
does the same:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">decay</span>
<span class="kn">import</span> <span class="nn">doctest</span>

<span class="k">def</span> <span class="nf">test_decay_module_with_doctest</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Doctest embedded in a nose/pytest unit test.&quot;&quot;&quot;</span>
    <span class="c"># Test all functions with doctest in module decay</span>
    <span class="n">failure_count</span><span class="p">,</span> <span class="n">test_count</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">decay</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">failure_count</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># Run all functions with doctests in this module</span>
    <span class="n">failure_count</span><span class="p">,</span> <span class="n">test_count</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">decay</span><span class="p">)</span>
</pre></div>
<p>
We can then run <code>py.test</code> or <code>nosetests</code> and trigger the doctest.

<h3 id="___sec27">Installing nose and pytest </h3>

<p>
With <code>pip</code> available, it is trivial to install nose and/or pytest:
<code>sudo pip install nose</code> and <code>sudo pip install pytest</code>.

<h2 id="___sec28">Test function for the solver </h2>

<p>
Finding good test problems for verifying the implementation of numerical
methods is a topic on its own. The challenge is that we very seldom know
what the numerical errors are. For the present model problem
<a href="._softeng1-solarized002.html#mjx-eqn-1">(1)</a>-<a href="._softeng1-solarized002.html#mjx-eqn-2">(2)</a> solved by
<a href="._softeng1-solarized002.html#mjx-eqn-3">(3)</a> one can, fortunately, derive a formula for
the numerical approximation:

$$ u^n = I\left(
\frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}
\right)^n\tp$$

Then we know that the implementation should
produce numbers that agree with this formula to machine precision.
The formula for \( u^n \) is known as an <em>exact discrete solution</em> of the
problem and can be coded as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return exact discrete solution of the numerical schemes.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># avoid integer division</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="n">n</span>
</pre></div>
<p>
A test function can evaluate this solution on a time mesh
and check that the <code>u</code> values produced by the <code>solver</code> function
do not deviate with more than a small tolerance:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_exact_discrete_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that solver reproduces the exact discr. sol.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="c"># Evaluate exact discrete solution on the mesh</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

    <span class="c"># Find largest deviation</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="k">assert</span> <span class="n">success</span>
</pre></div>
<p>
An important topic to address in test functions is potentially
problematic input to functions. For example, if \( a \), \( \Delta t \), and
\( \theta \) are integers, one may face problems with unintended integer
division in the numerical solution algorithm for the present mathematical
problem. We should therefore add a test to make sure our <code>solver</code>
function does not fall into this potential trap:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_potential_integer_division</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Choose variables that can trigger integer division.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>
</pre></div>

<h2 id="___sec29">Test function for reading positional command-line arguments </h2>

<p>
The function <code>read_command_line_positional</code> extracts numbers from the
command line. To test it, decide on a set of numbers, fill <code>sys.argv</code>
appropriately, and check that we get the expected numbers:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_read_command_line_positional</span><span class="p">():</span>
    <span class="c"># Decide on a data set of input parameters</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.6</span><span class="p">;</span>  <span class="n">a</span> <span class="o">=</span> <span class="mf">1.8</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>  <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="c"># Expected return from read_command_line_positional</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">]</span>
    <span class="c"># Construct corresponding sys.argv array</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="s">&#39;CN&#39;</span><span class="p">]</span> <span class="o">+</span> \ 
               <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">]</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">read_command_line_positional</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">expected_arg</span><span class="p">,</span> <span class="n">computed_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">expected_arg</span> <span class="o">==</span> <span class="n">computed_arg</span>
</pre></div>
<p>
Note that <code>sys.argv[0]</code> is always the program name and that we have to
copy that string from the original <code>sys.argv</code> array to the new one we
construct in the test function. (Actually, the test function destroys
the original <code>sys.argv</code> that Python fetched from the command line.)

<p>
Any numerical code writer should always be skeptical to the use of the exact
equality operator <code>==</code> in test functions, since round-off errors often
come into play. Here, however, we set some real values, convert them
to strings and convert back again to real numbers (of the same precision).
This string-number conversion does not involve any finite precision
arithmetics effects so we
can safely use <code>==</code> in tests. Note also that the last element in
<code>expected</code> and <code>computed</code> is the list <code>dt_values</code>, and <code>==</code> works
for comparing two lists too.

<h2 id="___sec30">Test function for reading option-value pairs </h2>

<p>
Testing the function <code>read_command_line_argparse</code> follows the
set up for the similar function for positional command-line arguments.
However, the construction of the command line is a bit more complicated.
We find it convenient to construct the line as a string and then
split the line into words to get the desired list <code>sys.argv</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">test_read_command_line_argparse</span><span class="p">():</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.6</span><span class="p">;</span>  <span class="n">a</span> <span class="o">=</span> <span class="mf">1.8</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>  <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
    <span class="c"># Expected return from read_command_line_positional</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">]</span>
    <span class="c"># Construct corresponding sys.argv array</span>
    <span class="n">cml</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> --a </span><span class="si">%s</span><span class="s"> --I </span><span class="si">%s</span><span class="s"> --T </span><span class="si">%s</span><span class="s"> --scheme CN --dt &#39;</span> <span class="o">%</span> \ 
          <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">cml</span> <span class="o">=</span> <span class="n">cml</span> <span class="o">+</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">])</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">cml</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">expected_arg</span><span class="p">,</span> <span class="n">computed_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">expected_arg</span> <span class="o">==</span> <span class="n">computed_arg</span>
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Let silent test functions speak up during development!</b>
<p>
When you develop test functions in a module, it is common to use IPython
to reload the module and call the test function as it gets developed:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">decay</span>

<span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">decay</span><span class="o">.</span><span class="n">test_read_command_line_argparse</span><span class="p">()</span>

<span class="n">In</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="nb">reload</span><span class="p">(</span><span class="n">decay</span><span class="p">)</span>  <span class="c"># force new import</span>

<span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">decay</span><span class="o">.</span><span class="n">test_read_command_line_argparse</span><span class="p">()</span>  <span class="c"># test again</span>
</pre></div>
<p>
However, a working test function is completely silent! Many
find it psychologically annoying to convince themselves that a
completely silent function is doing the right things. It can therefore,
during development of a test function, be convenient to insert
print statements in the function to monitor that the function body
is indeed executed. For example, one can print the expected and
computed values in the terminal window.
</div>


<h2 id="softeng1:basic:unittest">Classical class-based unit testing</h2>

<p>
The test functions written for the nose and pytest frameworks are
very straightforward and to the point, with no framework-required boilerplate
code. We just write the statements we need to make the computations and
comparisons and then apply the required <code>assert</code>.

<p>
The classical way of implementing unit tests (which derives from the
JUnit object-oriented tool in Java) leads to much more comprehensive
implementations with much more boilerplate code.  Python comes with a
built-in module <code>unittest</code> for doing this type of classical unit
tests. Although I strongly recommend to use nose or pytest over
<code>unittest</code>, class-based unit testing in the style of <code>unittest</code> has a
very strong position in computer science and is so widespread that
even computational scientists should have an idea how such unit test
code is written. A short demo of <code>unittest</code> is therefore included
next.

<p>
Suppose we have a function <code>double(x)</code> in a module file <code>mymod.py</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
</pre></div>
<p>
Unit testing with the aid of the <code>unittest</code> module
consists of writing a file <code>test_mymod.py</code> for testing the functions
in <code>mymod.py</code>. The individual tests must be methods with names
starting with <code>test_</code> in a class derived from class <code>TestCase</code> in
<code>unittest</code>. With one test method for the function <code>double</code>, the
<code>test_mymod.py</code> file becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">mymod</span>

<span class="k">class</span> <span class="nc">TestMyCode</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="n">mymod</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
<p>
The test is run by executing the test file <code>test_mymod.py</code> as a standard
Python program. There is no support in <code>unittest</code> for automatically
locating and running all tests in all test files in a directory tree.

<p>
We could use the basic <code>assert</code> statement as we did with nose and pytest
functions, but those who write code based on <code>unittest</code> almost
exclusively use the wide range of built-in assert functions such
as <code>assertEqual</code>, <code>assertNotEqual</code>, <code>assertAlmostEqual</code>, to mention
some of them.

<p>
Translation of <code>test_exact_discrete_solution</code>,
<code>test_potential_integer_division</code>, and the other test functions in <code>decay.py</code>
to <code>unittest</code> means making a new file <code>test_decay.py</code> file with a
test class <code>TestDecay</code> where the stand-alone functions for
nose/pytest now become methods in this class.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">decay</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">TestDecay</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_exact_discrete_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">decay</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="c"># Evaluate exact discrete solution on the mesh</span>
        <span class="n">u_de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># largest deviation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_potential_integer_division</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_read_command_line_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">expected_arg</span><span class="p">,</span> <span class="n">computed_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">computed</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected_arg</span><span class="p">,</span> <span class="n">computed_arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_read_command_line_argparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._softeng1-solarized003.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._softeng1-solarized005.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

