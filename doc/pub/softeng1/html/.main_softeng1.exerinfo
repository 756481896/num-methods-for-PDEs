
# Information about all exercises in the file main_softeng1.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_softeng1.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['curvediff.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:derivative',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a function\n`differentiate(x, y)` for differentiating a curve\n   with coordinates in the arrays `x` and `y`, using the\n   formulas above. The function should return the coordinate arrays\nof the resulting differentiated curve.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test function for the function in a).'},
            {'aftertext': '\n# Using a 2nd-order backward formula at x=1 does not improve the\n# results much, one gets large errors at the end points.\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Start with a curve corresponding to $y=\\sin(\\pi x)$ and $n+1$\npoints in $[0,1]$. Apply `differentiate` four times and plot the\nresulting curve and the exact $y=\\sin\\pi x$ for $n=6, 11, 21, 41$.'}],
  'text': 'Suppose we have a curve specified through a set\nof discrete coordinates $(x_i,y_i)$, $i=0,\\ldots,n$, where the $x_i$\nvalues are uniformly distributed with spacing $\\Delta x$: $x_i=\\Delta x$.\nThe derivative of this curve, defined as a new curve with points\n$(x_i, d_i)$, can be computed via finite differences:\n\n!bt\n\\begin{equation}\nd_0 = \\frac{y_1-y_0}{\\Delta x},\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nd_i = \\frac{y_{i+1}-y_{i-1}}{2\\Delta x},\\quad i=1,\\ldots,n-1,\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nd_n = \\frac{y_n-y_{n-1}}{\\Delta x}\\tp\n\\end{equation}\n\n!et',
  'title': 'Make a tool for differentiating curves',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['trapezoidal.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "The ``flat'' implementation above suffers from three serious flaws:\n\n o A general numerical algorithm (the Trapezoidal rule) is implemented\n   in a specialized form where the formula for $f$ is inserted directly\n   into the code for the general integration formula.\n o A general numerical algorithm is not encapsulated as a general\n   function, with appropriate parameters, which can be reused\n   across a wide range of applications.\n o The lazy programmer dropped the first terms in the general formula\n   since $\\sin(0)=\\sin(\\pi)=0$.\n\nWrite a function `trapezoidal` that fixes these flaws.\nPlace the function in a module `trapezoidal`."},
            {'answer': '',
             'file': None,
             'hints': ['Note that even if you know the value of the integral, you do not know\nthe error in the approximation produced by the Trapezoidal rule.\nHowever, the Trapezoidal rule will integrate linear functions,\nand piecewise linear functions, with discontinuities at the $x_i$\npoints, exactly (i.e., to machine precision). Base a test function\non such linear functions $f(x)$.'],
             'solution': '',
             'text': 'Write a test function `test_trapezoidal`. Call the test function\nexplicitly to check that it works. Remove the call and run pytest\non the module:\n\n!bc sys\nTerminal> py.test -s -v trapezoidal\n\n!ec'},
            {'answer': '',
             'file': None,
             'hints': ['To translate a string formula on the command line, like `sin(x)**2`,\ninto a Python function, you can wrap a function declaration around\nthe formula and run `exec` on the string to turn it into live Python code:\n\n!bc pycod\nimport math, sys\nformula = sys.argv[1]\nf_code = """\ndef f(x):\n    return %s\n""" % formula\nexec(code, math.__dict__)\n\n!ec\nThe result is the same as if we had hardcoded\n\n!bc pycod\ndef f(x):\n    return sin(x)**2\n\n!ec\nin the program. Note that `exec` needs the namespace\n`math.__dict__`, i.e., all names in the `math` module, such that\nit understands `sin` and other mathematical functions.\nSimilarly, to allow $a$ and $b$ to be `math` values like `pi`,\ndo\n\n!bc sys\na = eval(sys.argv[2], math.__dict__)\nb = eval(sys.argv[2], math.__dict__)\n\n!ec'],
             'solution': '',
             'text': "Add functionality for computing $\\int_a^b f(x)dx$ by providing\n$f$, $a$, $b$, and $n$ as positional command-line arguments:\n\n!bc sys\nTerminal> python trapezoidal.py 'sin(x)**2' 0 pi 20\n\n!ec\n\nNote that the `trapezoidal.py` must still be a valid module file, so the\ninterpretation of command-line data and computation of the integral\nmust be performed from calls in a test block."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test function for verifying the implementation of the\nreading data from the command line.'}],
  'text': 'An integral\n\n!bt\n\\[ \\int_a^b f(x)dx \\]\n\n!et\ncan be numerically approximated by the Trapezoidal rule,\n\n!bt\n\\[ \\int_a^b f(x)dx \\approx \\frac{h}{2}(f(a) + f(b)) + h\\sum_{i=1}^{n-1} f(x_i),\n\\]\n\n!et\nwhere $x_i$ is a set of uniformly spaced points in $[a,b]$:\n\n!bt\n\\[ h = \\frac{b-a}{n},\\quad x_i=a + ih,\\ i=1,\\ldots,n-1\\tp \\]\n\n!et\n\nSomebody has used this rule to compute the integral $\\int_0^\\pi sin^2x dx$:\n\n!bc pypro\nfrom math import pi, sin\nn = 20\nh = pi/n\nI = 0\nfor i in range(1, n):\n    I += sin(i*h)**2\nprint I\n\n!ec',
  'title': 'Make solid software for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['trapezoidal_class.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:integral:flat2',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the same problem setting as in Problem\nref{softeng1:exer:integral:flat}. Make a module with a class `Problem`\nrepresenting the mathematical problem to be solved and a class\n`Solver` representing the solution method.  The rest of the\nfunctionality of the module, including test functions and reading data\nfrom the command line, should be as in Problem\nref{softeng1:exer:integral:flat}.',
  'title': 'Implement classes for the Trapezoidal rule',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['doctest_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:doctest1',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Type in the following program and equip the `roots` function with a doctest:\n\n!bc pypro\nimport sys\n# This sqrt(x) returns real if x>0 and complex if x<0\nfrom numpy.lib.scimath import sqrt\n\ndef roots(a, b, c):\n    """\n    Return the roots of the quadratic polynomial\n    p(x) = a*x**2 + b*x + c.\n\n    The roots are real or complex objects.\n    """\n    q = b**2 - 4*a*c\n    r1 = (-b + sqrt(q))/(2*a)\n    r2 = (-b - sqrt(q))/(2*a)\n    return r1, r2\n\na, b, c = [float(arg) for arg in sys.argv[1:]]\nprint roots(a, b, c)\n\n!ec\nMake sure to test both real and complex roots.\nWrite out numbers with 14 digits or less.',
  'title': 'Write a doctest',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:nosetest1',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a test function for the `roots` function in\nProblem ref{softeng1:exer:doctest1}.',
  'title': 'Write a nose test',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['experiment_compare_dt_class.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'softeng1:exer:class:dts',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the `experiment_compare_dt` function from `decay.py`\nusing class `Problem` and class `Solver` from\nSection ref{softeng1:prog:se:class}.\nThe parameters `I`, `a`, `T`, the scheme name, and a series of\n`dt` values should be read from the command line.',
  'title': 'Make use of a class implementation',
  'type': 'Exercise',
  'type_visible': True}]