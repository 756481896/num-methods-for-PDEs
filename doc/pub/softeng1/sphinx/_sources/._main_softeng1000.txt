.. Automatically generated Sphinx-extended reStructuredText file from DocOnce source
   (https://github.com/hplgit/doconce/)

Scientific software engineering with a simple ODE model as example
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:Authors: Hans Petter Langtangen
:Date: Mar 21, 2015

.. Intro...

Teaching material on scientific computing has traditionally been very
focused on the mathematics and the applications, while details on how
the computer is programmed to solve the problems have received little attention.
Many end up writing as simple programs as possible and are
not aware of much useful computer science technology that would increase
the fun, efficiency, and reliability of the their scientific computing
activities.

This document demonstrates a series of good practices and tools
from modern computer science, using a very simple mathematical problem
with a very simple implementation such that we minimize the
mathematical details.  Our goal is to increase the technological
quality of computer programming and make it match the more
well-established quality of the mathematics of scientific computing.

More specifically we address the following scientific topics:

 * How to structure a code in terms of functions

 * How to make a module

 * How to read input data flexibly from the command line

 * How to create graphical/web user interfaces

 * How to write unit tests (test functions or doctests)

 * How to refactor code in terms of classes (instead of functions only)

 * How to conduct and automate large-scale numerical experiments

 * How to write scientific reports in various formats (LaTeX, HTML)

The conventions and techniques outlined here will save you a lot of time
when you incrementally extend software over time from simpler to more
complicated problems. In particular, you will benefit from
many good habits:

 * new code is added in a modular fashion to a library (modules),

 * programs are run through convenient user interfaces,

 * it takes one quick command to let all your code can undergo heavy testing,

 * tedious manual work with running programs is automated,

 * your scientific investigations are reproducible,

 * scientific reports with top quality typesetting are written both
   for paper and electronic devices.

.. _softeng1:basic:

Basic implementations
=====================

.. _softeng1:basic:math:

Mathematical problem and solution technique
-------------------------------------------

We address the perhaps simplest possible differential equation problem

.. _Eq:softeng1:ode:

.. math::
   :label: softeng1:ode
        
        u'(t) = -au(t), \quad t \in (0,T], 
        

.. _Eq:softeng1:u0:

.. math::
   :label: softeng1:u0
          
        u(0)  = I,                         
        

where :math:`a`, :math:`I`, and :math:`T` are prescribed parameters, and :math:`u(t)` is
the unknown function to be estimated. This mathematical model
is relevant for physical phenomena featuring exponential decay
in time, e.g., vertical pressure variation in the atmosphere,
cooling of an object, and radioactive decay.

The time domain is discretized with points :math:`0 = t_0 < t_1 \cdots < t_{N_t}=T`,
here with a constant spacing :math:`\Delta t` between the
mesh points: :math:`\Delta t = t_{n}-t_{n-1}`, :math:`n=1,\ldots,N_t`. Let
:math:`u^n` be the numerical approximation to the exact solution at :math:`t_n`.
A family of popular numerical methods can be written in the form

.. _Eq:softeng1:utheta:

.. math::
   :label: softeng1:utheta
        
        u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
        
        

for :math:`n=0,1,\ldots,N_t-1`. This numerical scheme corresponds to
the `Forward Euler <http://en.wikipedia.org/wiki/Forward_Euler_method>`__
scheme when :math:`\theta=0`,
the `Backward Euler <http://en.wikipedia.org/wiki/Backward_Euler_method>`__
scheme when :math:`\theta=1`,
and the `Crank-Nicolson <http://en.wikipedia.org/wiki/Crank-Nicolson>`__
scheme when :math:`\theta=1/2`.
The initial condition :eq:`softeng1:u0` is key to start
the recursion with a value for :math:`u^0`.

.. _softeng1:basic:impl1:

A first, quick implementation
-----------------------------

Solving :eq:`softeng1:utheta` in a program is very straightforward:
just make a loop over :math:`n` and evaluate the formula. The :math:`u(t_n`)
values for discrete :math:`n` can be stored in an array. This makes it easy
to also plot the solution. We may with little work add the exact
solution :math:`u(t)=Ie^{-at}` to the plot. A typical program is listed
below.

.. code-block:: python

        from numpy import *
        from matplotlib.pyplot import *
        
        A = 1
        a = 2
        T = 4
        dt = 0.2
        N = int(round(T/dt))
        y = zeros(N+1)
        t = linspace(0, T, N+1)
        theta = 1
        y[0] = A
        for n in range(0, N):
            y[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*y[n]
        
        y_e = A*exp(-a*t) - y
        error = y_e - y
        E = sqrt(dt*sum(error**2))
        print 'Norm of the error: %.3E' % E
        plot(t, y, 'r--o')
        t_e = linspace(0, T, 1001)
        y_e = A*exp(-a*t_e)
        plot(t_e, y_e, 'b-')
        legend(['numerical, theta=%g' % theta, 'exact'])
        xlabel('t')
        ylabel('y')
        show()

This program is very easy to read, and as long it is correct, many will
claim that it has sufficient quality. Nevertheless, this program suffers
from serious bad habits that might be crucial for writing correct
programs for more complicated mathematical problems. First we list
two really serious issues:

1. The notation in the program does not correspond exactly to
   the notation in the mathematical problem: the solution is called
   ``y`` and corresponds to :math:`u` in the mathematical description,
   the variable ``A`` corresponds to the mathematical parameter :math:`I`,
   ``N`` in the program is called :math:`N_t` in the mathematics.

2. There are no comments in the program.

Fixing notation and comments results in

.. code-block:: python

        from numpy import *
        from matplotlib.pyplot import *
        
        I = 1
        a = 2
        T = 4
        dt = 0.2
        Nt = int(round(T/dt))     # no of time intervals
        u = zeros(Nt+1)           # array of u[n] values
        t = linspace(0, T, Nt+1)  # time mesh
        theta = 1                 # Backward Euler method
        
        u[0] = I                  # assign initial condition
        for n in range(0, Nt):    # n=0,1,...,Nt-1
            u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]
        
        # Compute norm of the error
        u_e = I*exp(-a*t) - u     # exact u at the mesh points
        error = u_e - u
        E = sqrt(dt*sum(error**2))
        print 'Norm of the error: %.3E' % E
        
        # Compare numerical (u) and exact solution (u_e) in a plot
        plot(t, u, 'r--o')               # red dashes w/circles
        t_e = linspace(0, T, 1001)       # very fine mesh for u_e
        u_e = I*exp(-a*t_e)
        plot(t_e, u_e, 'b-')             # blue line for u_e
        legend(['numerical, theta=%g' % theta, 'exact'])
        xlabel('t')
        ylabel('u')
        show()

At first sight, this is a good starting point for playing around
with the example: we can just change parameters and rerun.
Let us embed the program in an IPython notebook such that we
can get the plot up in the notebook, see Figure :ref:`softeng1:ipynb`.

.. _softeng1:ipynb:

.. figure:: ipynb_flat.png
   :width: 700

   *Flat experimental code in a notebook*

Although such an interactive session is good for initial exploration,
one will soon extend the experiments and start developing the code
further. Say we want to compare :math:`\theta =0,1,0.5` in the same
plot. This extension requires changes all over the code and quickly
lead to errors. To do something serious with
this program we have to break it into smaller pieces and make sure
each piece is well tested, is general, and can be reused in new
contexts without changes.
The next natural step is therefore to isolate the numerical computations and
the visualization in separate functions.

.. _softeng1:basic:func:

Isolating the numerical algorithm in a function
-----------------------------------------------

The solution formula :eq:`softeng1:utheta` is completely general and
should be available as a Python function with all input data as
function arguments and all output data returned to the calling code:

.. code-block:: python

        def solver(I, a, T, dt, theta):
            """Solve u'=-a*u, u(0)=I, for t in (0,T] with steps of dt."""
            dt = float(dt)               # avoid integer division
            Nt = int(round(T/dt))        # no of time intervals
            T = Nt*dt                    # adjust T to fit time step dt
            u = np.zeros(Nt+1)           # array of u[n] values
            t = np.linspace(0, T, Nt+1)  # time mesh
        
            u[0] = I                  # assign initial condition
            for n in range(0, Nt):    # n=0,1,...,Nt-1
                u[n+1] = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)*u[n]
            return u, t


.. admonition:: Tip: Always use a doc string to document a function

   Python has a convention for documenting the purpose and usage of
   a function in a *doc string*: simply place the documentation
   in a one- or multi-line triple-quoted string right after the
   function header.





.. admonition:: Be careful with unintended integer division

   Note that we in the ``solver`` function explicitly covert ``dt`` to a
   ``float`` object. If not, the updating formula for ``u[n+1]`` may evaluate
   to zero because of integer division when ``theta``, ``a``, and ``dt`` are integers!




With the aid of the ``solver`` function, we can solve any problem
of the type :eq:`softeng1:ode`-:eq:`softeng1:u0` by a one-line
statement:

.. code-block:: python

        u, t = solver(I=1, a=2, T=4, dt=0.2, theta=0.5)

One of the most serious flaws in computational work is to have several
slightly different implementations of the same computational algorithms
lying around in various program files. This is very likely to happen,
because busy scientists often want to test a slight variation of a code to see
what happens. A quick copy and edit do the task, but such quick hacks have
a tendency to survive. When a real correction is needed in the implementation,
it is difficult to ensure that the correction is done in all relevant files.
In fact, this is a general problem in programming, which has led to
an important principle.


.. admonition:: The DRY principle: Don't repeat yourself

   When implementing a particular functionality in a computer program, make sure
   this functionality and its variations are implemented in just one piece
   of code. That is, if you need to revise the implementation, there should be
   *one and only one* place to edit. It follows that you should never
   duplicate code (don't repeat yourself!), and code snippets that are
   similar should be factored into one piece (function) and parameterized (by
   function arguments).




.. _softeng1:basic:module:

Making a module
---------------

As soon as you start making Python functions in a program, you should
make sure the program file fulfills the requirement of a module.
This means that you can import and reuse your functions in other
programs too. For example, if our ``solver`` function resides in a
module ``decay`` in a module file ``decay.py``, we can in any program
do

.. code-block:: python

        from decay import solver
        # Solve a decay problem
        u, t = solver(I=1, a=2, T=4, dt=0.2, theta=0.5)

or prefix function names by the module name:

.. code-block:: python

        import decay
        # Solve a decay problem
        u, t = decay.solver(I=1, a=2, T=4, dt=0.2, theta=0.5)

The requirements for a program to qualify for a module are simple:

1. The filename without ``.py`` must be a valid Python variable name.

2. The main program must be executed (through statements or
   a function call) in the *test block*.

The *test block* is normally placed at the end of a module file:

.. code-block:: python

        if __name__ == '__main__':
            # Statements

When the module file is executed as a stand-alone program, the if test
is true and the indented statements are run, but when the module file
is imported, ``__name__`` equals the module name and the test block
is not executed.

To explain the importance of the test block, consider the trivial module
file ``hello.py`` with one function and a call to this function as main program:

.. code-block:: python

        def hello(arg='World!'):
            print 'Hello, ' + arg
        
        if __name__ == '__main__':
            hello()

Without the test block,

.. code-block:: python

        def hello(arg='World!'):
            print 'Hello, ' + arg
        
        hello()

any attempt to import ``hello`` will also execute the call ``hello()`` and
hence write `Hello, World!' to the screen.
Such output is not desired when importing a module! However,
with the test block, ``hello()`` is not called during import, but
running the file as ``python hello.py`` will make the block active
and lead to the desired printing.


.. admonition:: All coming functions are placed in a module

   The many functions to be explained in the following text are
   put in one module file `decay.py <http://tinyurl.com/nm5587k/decay/decay.py>`__.




What more than the ``solver`` function is needed in our ``decay`` module
to do everything we did in the previous, flat program?
We need import statements for ``numpy`` and ``matplotlib`` as well as
another function for producing the plot. It can also be convenient
to put the exact solution in a Python function.
Our module ``decay.py`` then looks like this:

.. code-block:: python

        from numpy import *
        from matplotlib.pyplot import *
        
        def solver(I, a, T, dt, theta):
            ...
        
        def exact_solution(t, I, a):
            return I*exp(-a*t)
        
        def experiment_compare_numerical_and_exact():
            I = 1;  a = 2;  T = 4;  dt = 0.4;  theta = 1
            u, t = solver(I, a, T, dt, theta)
        
            t_e = linspace(0, T, 1001)       # very fine mesh for u_e
            u_e = exact_solution(t_e, I, a)
        
            plot(t,   u,   'r--o')           # dashed red line with circles
            plot(t_e, u_e, 'b-')             # blue line for u_e
            legend(['numerical, theta=%g' % theta, 'exact'])
            xlabel('t')
            ylabel('u')
            plotfile = 'tmp'
            savefig(plotfile + '.png');  savefig(plotfile + '.pdf')
        
            error = exact_solution(t, I, a) - u
            E = sqrt(dt*sum(error**2))
            print 'Error norm:', E
        
        if __name__ == '__main__':
            experiment_compare_numerical_and_exact()

This module file does exactly the same as the previous, flat program,
but it becomes much easier to extend the code with other plots or
experiments in new functions.  And even more important, the numerical
algorithm is coded and tested once and for all in the ``solver``
function, and any need to solve the mathematical problem is a matter
of one function call.

.. (not copying initialization statements and a loop

.. to a new program for ad hoc editing!).

.. _softeng1:basic:modprefix:

Prefixing imported functions by the module name
-----------------------------------------------

.. index:: importing modules

Import statements of the form ``from module import *`` import
functions and variables in ``module.py`` into the current file.
For example, when doing

.. code-block:: python

        from numpy import *
        from matplotlib.pyplot import *

we get mathematical functions like ``sin`` and ``exp``
as well as MATLAB-style functions like ``linspace`` and ``plot``,
which can be called by these well-known names.
Unfortunately, it sometimes becomes confusing to
know where a particular function comes from. Is it from ``numpy``? Or
``matplotlib.pyplot``?
Or is it our own function?

An alternative import is

.. code-block:: python

        import numpy
        import matplotlib.pyplot

and such imports require functions to be prefixed by the module name, e.g.,

.. code-block:: python

        t = numpy.linspace(0, T, Nt+1)
        u_e = I*numpy.exp(-a*t)
        matplotlib.pyplot.plot(t, u_e)

This is normally regarded as a better habit because it is explicitly stated
from which module a function comes from.

The modules ``numpy`` and ``matplotlib.pyplot`` are so frequently used,
and their full names quite tedious to write, so two standard abbreviations
have evolved in the Python scientific computing community:

.. code-block:: python

        import numpy as np
        import matplotlib.pyplot as plt
        
        t = np.linspace(0, T, Nt+1)
        u_e = I*np.exp(-a*t)
        plt.plot(t, u_e)

A version of the ``decay_mod`` module where we use the ``np`` and ``plt``
prefixes is found in the file
`decay_mod_prefix.py <http://tinyurl.com/nm5587k/softeng1/decay_mod_prefix.py>`__.

The downside of prefixing functions by the module name is that
mathematical expressions like :math:`e^{-at}\sin(2\pi t)` get
cluttered with module names,

.. code-block:: python

        numpy.exp(-a*t)*numpy.sin(2(numpy.pi*t)
        # or
        np.exp(-a*t)*np.sin(2*np.pi*t)

Such an expression looks like ``exp(-a*t)*sin(2*pi*t)`` in most
other programming languages. Similarly,
``np.linspace`` and ``plt.plot`` look less familiar to people who are
used to MATLAB and who have not adopted Python's prefix style.
Whether to do ``from module import *`` or ``import module`` depends
on personal taste and the problem at hand. In these writings we use
``from module import`` in more basic, shorter programs where similarity with
MATLAB could be an advantage. Prefix of mathematical
functions in formulas is something we often avoid to obtain
a one-to-one correspondence between
mathematical formulas and the Python code.

Our ``decay`` module can be edited to use the module prefix for
``matplotlib.pyplot`` and ``numpy``:

.. code-block:: python

        import numpy as np
        import matplotlib.pyplot as plt
        
        def solver(I, a, T, dt, theta):
            ...
        
        def exact_solution(t, I, a):
            return I*np.exp(-a*t)
        
        def experiment_compare_numerical_and_exact():
            I = 1;  a = 2;  T = 4;  dt = 0.4;  theta = 1
            u, t = solver(I, a, T, dt, theta)
        
            t_e = np.linspace(0, T, 1001)       # very fine mesh for u_e
            u_e = exact_solution(t_e, I, a)
        
            plt.plot(t,   u,   'r--o')       # dashed red line with circles
            plt.plot(t_e, u_e, 'b-')         # blue line for u_e
            plt.legend(['numerical, theta=%g' % theta, 'exact'])
            plt.xlabel('t')
            plt.ylabel('u')
            plotfile = 'tmp'
            plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')
        
            error = exact_solution(t, I, a) - u
            E = np.sqrt(dt*np.sum(error**2))
            print 'Error norm:', E
        
        if __name__ == '__main__':
            experiment_compare_numerical_and_exact()

We remark that some would prefer to get rid of the prefix in
mathematical formulas:

.. code-block:: python

        from numpy import exp, sum, sqrt
        
        def exact_solution(t, I, a):
            return I*exp(-a*t)
        
        error = exact_solution(t, I, a) - u
        E = sqrt(dt*sum(error**2))

.. _softeng1:basic:experiment2:

Comparing numerical schemes in one plot
---------------------------------------

Let us specifically demonstrate one extension of the
flat program in Section ref
that would require substantial editing of the flat code, while
in a structured module, we can simply add a new function without
affecting the existing code and with reusing the implementation
of the numerics.

Our aim is to make a comparison between the numerical solutions
for various schemes (:math:`\theta` values) and the exact solution:

.. figure:: compare.png
   :width: 600


.. admonition:: Stop a minute

   Look at the flat program in
   the section :ref:`softeng1:basic:impl1`,
   and try to imagine which edits that are required to solve this new problem.




With the ``solver`` function at hand, we can simply create a function
with a loop over ``theta`` values and add the necessary plot statements:

.. code-block:: python

        def experiment_compare_schemes():
            """Compare theta=0,1,0.5 in the same plot."""
            I = 1;  a = 2;  T = 4;  dt = 0.4
            legends = []
            for theta in [0, 1, 0.5]:
                u, t = solver(I, a, T, dt, theta)
                plt.plot(t, u, '--o')            # dashed lines with circles
                legends.append('theta=%g' % theta)
            t_e = np.linspace(0, T, 1001)       # very fine mesh for u_e
            u_e = exact_solution(t_e, I, a)
            plt.plot(t_e, u_e, 'b-')             # blue line for u_e
            legends.append('exact')
            plt.legend(legends, loc='upper right')
            plotfile = 'tmp'
            plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')

A call to this ``experiment_compare_schemes`` function must be placed
in the test block, or you can run the program from IPython instead:

.. code-block:: ipy

        In[1]: from decay import *
        
        In[2]: experiment_compare_schemes()

User interfaces
===============

It is good programming practice to let programs read input from the
user rather than require the user to edit the source code when trying
out new values of input parameters. One reason is that any edit of the
code has a danger of introducing bugs. Another reason is that it is
easier and less manual work to supply data to a program instead of
editing the program code. A third reason is that a program that reads
input can easily be run by another program, and in this way we can
automate a large number of runs in scientific investigations.

Reading input data can be done in many ways. We have to decide on a
desired *user interface*, i.e., how we want to operate the program
when providing input, and then use appropriate tools to implement
the user interface. There are four basic types of user interface
of relevance to our programs, listed here with increasing complexity
of the implementation:

1. Questions and answers in the terminal window

2. Command-line arguments

3. Reading data from file

4. Graphical user interfaces (GUIs)

Below, we shall address alternative 2 and 4, which are most
appropriate for the present problem and also in general the most
popular types of user interfaces.

Command-line arguments
----------------------

The command-line arguments are all the words that appear on the
command line after the program name. Running a program ``prog``
as ``prog arg1 arg2`` means that there are two command-line arguments
(separated by white space): ``arg1`` and ``arg2``.
Python stores all the command-line arguments in
the list ``sys.argv``, and there are, in principle, two ways of programming with
command-line arguments in Python:

 * Decide upon a sequence of parameters on the command line and read
   their values directly from the ``sys.argv[1:]`` list (``sys.argv[0]`` is
   the just program name).

 * Use option-value pairs (``--option value``) on
   the command line to override default values of input parameters,
   and utilize the ``argparse.ArgumentParser`` tool to interact with
   the command line.

Suppose we want to run our program ``decay.py`` with
specification of :math:`a` and :math:`\Delta t` on the command line.
With positional command-line arguments we write

.. code-block:: text

        Terminal> python decay.py 2 0.5

knowing that the first argument ``2`` is ``a`` (:math:`a`) and the second `0.5`is
``dt`` (:math:`\Delta t`).

With option-value pairs we can run

.. code-block:: text

        Terminal> python decay.py --a 2 --dt 0.5

Both ``a`` and ``dt`` are supposed to have default values in the program,
so we need to specify only the parameter that is to be changed from
its default value, e.g.,

.. code-block:: text

        Terminal> python decay.py --a 2      # a=2, default dt
        Terminal> python decay.py --dt 0.7   # dt-0.7, default a
        Terminal> python decay.py            # default a and dt

As example, we want to read :math:`I`, :math:`a`, :math:`T`, :math:`\theta`,
and a range of :math:`\Delta t` values from the command line.
A plot is then to be made, comparing
the different numerical solutions for different :math:`\Delta t` values
against the exact solution.

Positional command-line arguments
---------------------------------

.. index:: list comprehension

.. index:: sys.argv

The simplest way of reading the input parameters is to
decide on their sequence on the command line and just index
the ``sys.argv`` list accordingly.
Say the sequence is :math:`I`, :math:`a`, :math:`T`, :math:`\theta` followed by an
arbitrary number of :math:`\Delta t` values. This code extract
these *positional* command-line arguments:

.. code-block:: python

        import sys
        I = float(sys.argv[1])
        a = float(sys.argv[2])
        T = float(sys.argv[3])
        theta = float(sys.argv[4])
        dt_values = [float(arg) for arg in sys.argv[5:]]


.. admonition:: Command-line arguments are strings

   Note that all elements in ``sys.argv`` are string objects.
   If the values will enter mathematical computations, we need
   to explicitly convert the strings to numbers.




Instead of specifying the :math:`\theta` value, we could be a bit more
sophisticated and let the user write the name of the scheme:
``BE`` for Backward Euler, ``FE`` for Forward Euler, and ``CN``
for Crank-Nicolson. Then we must map this string to the proper
:math:`\theta` value, an operation elegantly done by a dictionary:

.. code-block:: python

        scheme = sys.argv[4]
        scheme2theta = {'BE': 1, 'CN': 0.5, 'FE': 0}
        if scheme in scheme2theta:
            theta = scheme2theta[scheme]
        else:
            print 'Invalid scheme name:', scheme; sys.exit(1)

Option-value pairs on the command line
--------------------------------------

.. index:: argparse (Python module)

.. index:: ArgumentParser (Python class)

.. index:: option-value pairs (command line)

.. index:: command-line options and values

.. index:: reading the command line

Now we want specify option-value pairs on the command line,
using ``--I`` for ``I`` (:math:`I`), ``--a`` for ``a`` (:math:`a`), ``--T`` for ``T`` (:math:`T`),
``--scheme`` for the scheme name (``BE``, ``FE``, ``CN``),
and ``--dt`` for the sequence of ``dt`` (:math:`\Delta t`) values.
Each parameter must have a sensible default value so
that we specify the option on the command line only when the default
value is not suitable. Here is a typical run:

.. code-block:: text

        Terminal> python decay.py --I 2.5 --dt 0.1 0.2 0.01 --a 0.4

Observe the major advantage over positional command-line arguments:
the input is much easier to read and much easier to write.
With positional arguments it is easy to mess up the sequence of
the input parameters and quite challenging to detect errors too,
unless there are just a couple of arguments.

Python's ``ArgumentParser`` tool in the ``argparse`` module makes it easy
to create a professional command-line interface to any program. The
documentation of `ArgumentParser <http://docs.python.org/library/argparse.html>`__ demonstrates its
versatile applications, so we shall here just list an example
containing basic features. It always pays off to use ``ArgumentParser``
rather than trying to inspect and interpret ``sys.argv`` manually!

The use of ``ArgumentParser`` typically involves three steps:

.. code-block:: python

        import argparse
        parser = argparse.ArgumentParser()
        
        # Step 1: add arguments
        parser.add_argument('--option_name', ...)
        
        # Step 2: interpret the command line
        args = parser.parse_args()
        
        # Step 3: extract values
        value = args.option_name

A function for setting up all the options is handy:

.. code-block:: python

        def define_command_line_options():
            import argparse
            parser = argparse.ArgumentParser()
            parser.add_argument(
                '--I', '--initial_condition', type=float,
                default=1.0, help='initial condition, u(0)',
                metavar='I')
            parser.add_argument(
                '--a', type=float, default=1.0,
                help='coefficient in ODE', metavar='a')
            parser.add_argument(
                '--T', '--stop_time', type=float,
                default=1.0, help='end time of simulation',
                metavar='T')
            parser.add_argument(
                '--scheme', type=str, default='CN',
                help='FE, BE, or CN')
            parser.add_argument(
                '--dt', '--time_step_values', type=float,
                default=[1.0], help='time step values',
                metavar='dt', nargs='+', dest='dt_values')
            return parser

Each command-line option is defined through the ``parser.add_argument``
method. Alternative options, like the short ``--I`` and the more
explaining version ``--initial_condition`` can be defined. Other arguments
are ``type`` for the Python object type, a default value, and a help
string, which gets printed if the command-line argument ``-h`` or ``--help`` is
included. The ``metavar`` argument specifies the value associated with
the option when the help string is printed. For example, the option for
:math:`I` has this help output:

.. code-block:: text

        Terminal> python decay_argparse.py -h
          ...
          --I I, --initial_condition I
                                initial condition, u(0)
          ...

The structure of this output is

.. code-block:: text

          --I metavar, --initial_condition metavar
                                help-string

Finally, the ``--dt`` option demonstrates how to allow for more than one
value (separated by blanks) through the ``nargs='+'`` keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the ``dist`` keyword argument, which for the ``--dt`` option is
``dt_values``. Without the ``dest`` argument, the value of an option ``--opt``
is stored as the attribute ``opt``.

The code below demonstrates how to read the command line and extract
the values for each option:

.. code-block:: python

        def read_command_line_argparse():
            parser = define_command_line_options()
            args = parser.parse_args()
            scheme2theta = {'BE': 1, 'CN': 0.5, 'FE': 0}
            data = (args.I, args.a, args.T, scheme2theta[args.scheme],
                    args.dt_values)
            return data

As seen, the values of the command-line options are available as
attributes in ``args``: ``args.opt`` holds the value of option ``--opt``, unless
we used the ``dest`` argument (as for ``--dt_values``) for specifying the
attribute name. The ``args.opt`` attribute has the object type specified
by ``type`` (``str`` by default).

The making of the plot is not dependent on whether we read data from
the command line as positional arguments or option-value pairs:

.. code-block:: python

        def experiment_compare_dt(option_value_pairs=False):
            I, a, T, theta, dt_values = \ 
               read_command_line_argparse() if option_value_pairs else \ 
               read_command_line_positional()
        
            legends = []
            for dt in dt_values:
                u, t = solver(I, a, T, dt, theta)
                plt.plot(t, u)
                legends.append('dt=%g' % dt)
            t_e = np.linspace(0, T, 1001)       # very fine mesh for u_e
            u_e = exact_solution(t_e, I, a)
            plt.plot(t_e, u_e, '--')            # dashed line for u_e
            legends.append('exact')
            plt.legend(legends, loc='upper right')
            plt.title('theta=%g' % theta)
            plotfile = 'tmp'
            plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')

Creating a graphical web user interface
---------------------------------------

The Python package `Parampool <https://github.com/hplgit/parampool>`__
can be used to automatically generate a web-based *graphical user interface*
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our ``decay_mod`` module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface.

Making a compute function
~~~~~~~~~~~~~~~~~~~~~~~~~

The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the *compute function* in
Parampool terminology. The purpose of this function is to take
values of :math:`I`, :math:`a`, :math:`T` together with a sequence of :math:`\Delta t` values
and a sequence of :math:`\theta` and plot the numerical against the
exact solution for each pair of :math:`(\theta, \Delta t)`.
The plots can be arranged as a table with the columns being scheme type
(:math:`\theta` value) and the rows reflecting the discretization parameter
(:math:`\Delta t` value). Figure :ref:`softeng1:fig:GUI` displays of the
graphical web interface may look like after results are computed
(there are :math:`3\times 3` plots in the GUI, but only :math:`2\times 2` are
visible in the figure).

.. _softeng1:fig:GUI:

.. figure:: web_GUI.png
   :width: 800

   *Automatically generated graphical web interface*

To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
compute function, here called ``main_GUI``:

.. code-block:: python

        def main_GUI(I=1.0, a=.2, T=4.0,
                     dt_values=[1.25, 0.75, 0.5, 0.1],
                     theta_values=[0, 0.5, 1]):

The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show a
table of plots.
Assume for now that the HTML code for one plot and the value of the
norm of the error can be computed by some other function ``compute4web``.
The ``main_GUI`` function can then loop over :math:`\Delta t` and :math:`\theta`
values and put each plot in an HTML table. Appropriate code goes like

.. code-block:: python

        def main_GUI(I=1.0, a=.2, T=4.0,
                     dt_values=[1.25, 0.75, 0.5, 0.1],
                     theta_values=[0, 0.5, 1]):
            # Build HTML code for web page. Arrange plots in columns
            # corresponding to the theta values, with dt down the rows
            theta2name = {0: 'FE', 1: 'BE', 0.5: 'CN'}
            html_text = '<table>\n'
            for dt in dt_values:
                html_text += '<tr>\n'
                for theta in theta_values:
                    E, html = compute4web(I, a, T, dt, theta)
                    html_text += """
        <td>
        <center><b>%s, dt=%g, error: %.3E</b></center><br>
        %s
        </td>
        """ % (theta2name[theta], dt, E, html)
                html_text += '</tr>\n'
            html_text += '</table>\n'
            return html_text

Making one plot is done in ``compute4web``. The statements should be
straightforward from earlier examples, but there is one new feature:
we use a tool in Parampool to embed the PNG code for a plot file
directly in an HTML image tag. The details are hidden from the
programmer, who can just rely on
relevant HTML code in the string ``html_text``. The function looks like

.. code-block:: python

        def compute4web(I, a, T, dt, theta=0.5):
            """
            Run a case with the solver, compute error measure,
            and plot the numerical and exact solutions in a PNG
            plot whose data are embedded in an HTML image tag.
            """
            u, t = solver(I, a, T, dt, theta)
            u_e = exact_solution(t, I, a)
            e = u_e - u
            E = np.sqrt(dt*np.sum(e**2))
        
            plt.figure()
            t_e = np.linspace(0, T, 1001)    # fine mesh for u_e
            u_e = exact_solution(t_e, I, a)
            plt.plot(t,   u,   'r--o')       # red dashes w/circles
            plt.plot(t_e, u_e, 'b-')         # blue line for exact sol.
            plt.legend(['numerical', 'exact'])
            plt.xlabel('t')
            plt.ylabel('u')
            plt.title('theta=%g, dt=%g' % (theta, dt))
            # Save plot to HTML img tag with PNG code as embedded data
            from parampool.utils import save_png_to_str
            html_text = save_png_to_str(plt, plotwidth=400)
        
            return E, html_text

Generating the user interface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The web GUI is automatically generated by
the following code, placed in a file `decay_GUI_generate.py <http://tinyurl.com/nm5587k/softeng1/decay_GUI_generate.py>`__

.. code-block:: python

        from parampool.generator.flask import generate
        from decay import main_GUI
        generate(main_GUI,
                 filename_controller='decay_GUI_controller.py',
                 filename_template='decay_GUI_view.py',
                 filename_model='decay_GUI_model.py')

Running the ``decay_GUI_generate.py`` program results in three new
files whose names are specified in the call to ``generate``:

 1. ``decay_GUI_model.py`` defines HTML widgets to be used to set
    input data in the web interface,

 2. ``templates/decay_GUI_views.py`` defines the layout of the web page,

 3. ``decay_GUI_controller.py`` runs the web application.

We only need to run the last program, and there is no need to look into
these files.

Running the web application
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The web GUI is started by

.. code-block:: text

        Terminal> python decay_GUI_controller.py

Open a web browser at the location ``127.0.0.1:5000``. Input fields for
``I``, ``a``, ``T``, ``dt_values``, and ``theta_values`` are presented.  Figure
:ref:`softeng1:fig:GUI` shows a part of the resulting page if we run
with the default values for the input parameters.
With the techniques demonstrated here, one can
easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

Tests for verifying implementations
===================================

Any module with functions should have a set of tests that check the
implementations.
There exists
well-established procedures and corresponding tools for automating
the execution of such tests. One can in this way, with a one-line command,
run large test sets and confirm that the software works (as far as the
tests tells). Here we shall illustrate two important
software testing techniques: *doctest* and *unit testing*.
The first one is Python specific, while unit testing is the dominating
test technique for computer software today.

Doctests
--------

.. index:: doctests

.. index::
   single: software testing; doctests

A doc string, the first string after the function header, is used to
document the purpose of functions and their arguments
(see the section :ref:`softeng1:basic:func`). Very often it
is instructive to include an example on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from function calls. For example,
we can in the ``solver`` function include an example on calling
this function and printing the computed ``u`` and ``t`` arrays:

.. code-block:: python

        def solver(I, a, T, dt, theta):
            """
            Solve u'=-a*u, u(0)=I, for t in (0,T] with steps of dt.
        
        
            >>> u, t = solver(I=0.8, a=1.2, T=1.5, dt=0.5, theta=0.5)
            >>> for t_n, u_n in zip(t, u):
            ...     print 't=%.1f, u=%.14f' % (t_n, u_n)
            t=0.0, u=0.80000000000000
            t=0.5, u=0.43076923076923
            t=1.0, u=0.23195266272189
            t=1.5, u=0.12489758761948
            """
            ...

When such interactive demonstrations are inserted in doc strings,
Python's `doctest <http://docs.python.org/library/doctest.html>`__
module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to run the module file ``decay.py`` with

.. code-block:: python

        Terminal> python -m doctest decay.py

This command imports the ``doctest`` module, which runs all
doctests found in the file.


.. admonition:: Doctests prevent command-line arguments

   No additional command-line argument is allowed when running doctests.
   If your program relies on command-line input, make sure the tests
   can be run with such input.




The execution command above will report any problem if a test fails.
For example, changing the last digit ``8`` in the output of the doctest
to ``7`` triggers a report:

.. code-block:: text

        Terminal> python -m doctest decay.py
        ********************************************************
        File "decay.py", line ...
        Failed example:
            for t_n, u_n in zip(t, u):
                print 't=%.1f, u=%.14f' % (t_n, u_n)
        Expected:
            t=0.0, u=0.80000000000000
            t=0.5, u=0.43076923076923
            t=1.0, u=0.23195266272189
            t=1.5, u=0.12489758761947
        Got:
            t=0.0, u=0.80000000000000
            t=0.5, u=0.43076923076923
            t=1.0, u=0.23195266272189
            t=1.5, u=0.12489758761948


.. admonition:: Pay attention to the number of digits in doctest results

   Note that in the output of ``t`` and ``u`` we write ``u`` with 14 digits.
   Writing all 16 digits is not a good idea: if the tests are run on
   different hardware, round-off errors might be different, and
   the ``doctest`` module detects that the numbers are not precisely the same
   and reports failures. In the present application, where :math:`0 < u(t) \leq 0.8`,
   we expect round-off errors to be of size :math:`10^{-16}`, so comparing 15
   digits would probably be reliable, but we compare 14 to be on the
   safe side. On the other hand, comparing a small number of digits may
   hide software errors.




Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.


.. admonition:: Caution

   Doctests requires careful coding if they use command-line input or
   print results to the terminal window. Command-line input must
   be simulated by filling ``sys.argv`` correctly, e.g.,
   ``sys.argv = '--I 1.0 --a 5'.split``.
   The output lines of print statements inside doctests
   must be copied exactly as they
   appear when running the statements in an interactive Python shell.




Unit tests and test functions
-----------------------------

.. index:: nose tests

.. index:: pytest tests

.. index:: unit testing

.. index::
   single: software testing; nose

.. index::
   single: software testing; pytest

The unit testing technique consists of identifying small units
of code, say a function, and write one or more tests for
each unit. One test should, ideally, not depend on the outcome of
other tests. The recommended practice is actually to
design and write the unit tests first and *then* implement the functions!

In scientific computing it is not always obvious how to best perform
unit testing. The units is naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit, such as our ``solver`` function.

.. index:: test function

.. index::
   single: software testing; test function

Test frameworks: nose and pytest
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python offers two very easy-to-use software frameworks for implementing
unit tests: nose and pytest. These work (almost) in the same way,
but my recommendation is to go for pytest.

Test function requirements
~~~~~~~~~~~~~~~~~~~~~~~~~~

Each test can in these frameworks be realized as a *test function*
that follows three rules:

 1. The name must start with ``test_``.

 2. Function arguments are not allowed.

 3. An ``AssertionError`` exception must be raised if the test fails.

A specific example might be illustrative before proceeding.
Given a function that doubles the argument,

.. code-block:: python

        def double(n):
            return 2*n

a corresponding test function may look like this:

.. code-block:: python

        def test_double():
            """Test that double(n) works for one specific n."""
            n = 4
            expected = 2*4
            computed = double(4)
            if expected != computed:
                raise AssertionError

The last two lines, however, are never written like this in unit tests.
Instead, use Python's ``assert`` statement: ``assert success, msg``, where
``success`` is a boolean variable, here ``False`` if the test fails, and
``msg`` is *an optional* message string that is printed when the test fails.
In detail, the test function looks like

.. code-block:: python

        def test_double():
            """Test that double(n) works for one specific n."""
            n = 4
            expected = 2*4
            computed = double(4)
            msg = 'expected %g, computed %g' % (expected, computed)
            success = expected == computed
            assert success, msg

Comparison of real numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~

In scientific computing we very often have to deal with real numbers and
round-off errors so the ``==`` operator must be replaced by a comparison
within a tolerance. Consider testing this function instead,

.. code-block:: python

        def third(x):
            return x/3.

We write a test function where the expected result is computed as
:math:`\frac{1}{3}x` rather than :math:`x/3`:

.. code-block:: python

        def test_third():
            x = 0.1
            expected = (1/3.)*x
            computed = third(x)
            success = expected == computed
            assert success

This ``test_third`` function executes silently, i.e., no failure, for ``x = 0.1``,
but not if we set ``x = 0.15``. The latter ``x`` value gives a round-off error.
The solution to this problem is to compare ``expected`` and ``computed``
with a small tolerance:

.. code-block:: python

        def test_third():
            x = 0.15
            expected = (1/3.)*x
            computed = third(x)
            tol = 1E-15
            success = abs(expected - computed) < tol
            assert success

Special assert functions from nose
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The nose test framework contains more tailored
*assert functions* that can be called instead of using the ``assert``
statement. For example, comparing two objects within
a tolerance, as in the present
case, can be done by ``assert_almost_equal``:

.. code-block:: python

        import nose.tools as nt
        
        def test_third():
            x = 0.15
            expected = (1/3.)*x
            computed = third(x)
            nt.assert_almost_equal(
                expected, computed, delta=1E-15,
                msg='diff=%.17E' % (expected - computed))

Locating test functions
~~~~~~~~~~~~~~~~~~~~~~~

Test functions can reside in a module together with the functions they
are supposed to verify, or the test functions can be collected in
separate files having names starting with ``test``. Actually,
nose and pytest can automatically recursively run all test functions
in all ``test*.py``
files in the current and all subdirectories!

The `decay.py <http://tinyurl.com/nm5587k/softeng1/decay.py>`__ module file features
test functions in the module, but we could equally well have made
a subdirectory ``tests`` and put the test functions in
(say) ``tests/test_decay.py``.

Running tests
~~~~~~~~~~~~~

To run all test functions in the file ``decay.py`` do

.. code-block:: text

        Terminal> nosetests -s -v decay.py
        Terminal> py.test -s -v decay.py

The ``-s`` option ensures that output from the test functions is printed
in the terminal window, and ``-v`` prints the outcome of each individual
test function.

Alternatively, if the test functions are in some ``test*.py`` files,
we can just write ``py.test -s -v``
to *recursively* run *all* test functions in the current
directory tree. The corresponding ``nosetests -s -v`` command
does the same, but requires subdirectory names to start
with ``test`` or end with ``_test`` or ``_tests`` (which is a good habit anyway).
An example of a ``tests`` directory with a ``test*.py``
file is found in `src/softeng1/tests <http://tinyurl.com/nm5587k/softeng1/tests>`__.

Installing nose and pytest
~~~~~~~~~~~~~~~~~~~~~~~~~~

With ``pip`` available, it is trivial to install nose and/or pytest:
``sudo pip install nose`` and ``sudo pip install pytest``.

Test function for the solver
----------------------------

Finding good test problems for verifying the implementation of numerical
methods is a topic on its own. The challenge is that we very seldom know
what the numerical errors are. For the present model problem
:eq:`softeng1:ode`-:eq:`softeng1:u0` solved by
:eq:`softeng1:utheta` one can, fortunately, derive a formula for
the numerical approximation:

.. math::
         u^n = I\left(
        \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}
        \right)^n{\thinspace .}

Then we know that the implementation should
produce numbers that agree with this formula to machine precision.
The formula for :math:`u^n` is known as an *exact discrete solution* of the
problem:

.. code-block:: python

        def exact_discrete_solution(n, I, a, theta, dt):
            """Return exact discrete solution of the numerical schemes."""
            dt = float(dt)  # avoid integer division
            A = (1 - (1-theta)*a*dt)/(1 + theta*dt*a)
            return I*A**n

A test function can evaluate this solution on a time mesh
and check that the ``u`` values produced by the ``solver`` function
do not deviate with more than a small tolerance:

.. code-block:: python

        def test_exact_discrete_solution():
            """Check that solver reproduces the exact discr. sol."""
            theta = 0.8; a = 2; I = 0.1; dt = 0.8
            Nt = int(8/dt)  # no of steps
            u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
            # Evaluate exact discrete solution on the mesh
            u_de = np.array([exact_discrete_solution(n, I, a, theta, dt)
                             for n in range(Nt+1)])
            diff = np.abs(u_de - u).max()  # largest deviation
            tol = 1E-14
            success = diff < tol
            assert success

An important topic to address in test functions is potentially
problematic input to functions. For example, if :math:`a`, :math:`\Delta t`, and
:math:`\theta` are integers, one may face problems with unintended integer
division in the numerical solution algorithm for the present mathematical
problem. We should therefore add a test to make sure our ``solver``
function does not fall into this potential trap:

.. code-block:: python

        def test_potential_integer_division():
            """Choose variables that can trigger integer division."""
            theta = 1; a = 1; I = 1; dt = 2
            Nt = 4
            u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
            u_de = np.array([exact_discrete_solution(n, I, a, theta, dt)
                             for n in range(Nt+1)])
            diff = np.abs(u_de - u).max()
            assert diff < 1E-14

Test function for reading positional command-line arguments
-----------------------------------------------------------

The function ``read_command_line_positional`` extracts numbers from the
command line. To test it, decide on a set of numbers, fill ``sys.argv``
appropriately, and check that we get the expected numbers:

.. code-block:: python

        def test_read_command_line_positional():
            # Decide on a data set of input parameters
            I = 1.6;  a = 1.8;  T = 2.2;  theta = 0.5
            dt_values = [0.1, 0.2, 0.05]
            # Expected return from read_command_line_positional
            expected = [I, a, T, theta, dt_values]
            # Construct corresponding sys.argv array
            sys.argv = [sys.argv[0], str(I), str(a), str(T), 'CN'] + \ 
                       [str(dt) for dt in dt_values]
            computed = read_command_line_positional()
            for expected_arg, computed_arg in zip(expected, computed):
                assert expected_arg == computed_arg

Note that ``sys.argv[0]`` is always the program name and that we have to
copy that string from the original ``sys.argv`` array to the new one we
construct in the test function. (Actually, the test function destroys
the original ``sys.argv`` that Python fetched from the command line.)

Any numerical code writer should always be skeptical to the use of the exact
equality operator ``==`` in test functions, since round-off errors often
come into play. Here, however, we set some real values, convert them
to strings and convert back again to real numbers (of the same precision).
This string-number conversion does not involve approximation so we
can safely use ``==`` in tests. Note also that the last element in
``expected`` and ``computed`` is the list ``dt_values``, and ``==`` works
for comparing two lists too.

Test function for reading option-value pairs
--------------------------------------------

Testing the function ``read_command_line_argparse`` follows the
set up for the similar function for positional command-line arguments.
However, the construction of the command line is a bit more complicated.
We find it convenient to construct the line as a string and then
split the line into words to get the desired list ``sys.argv``:

.. code-block:: python

        def test_read_command_line_argparse():
            I = 1.6;  a = 1.8;  T = 2.2;  theta = 0.5
            dt_values = [0.1, 0.2, 0.05]
            # Expected return from read_command_line_positional
            expected = [I, a, T, theta, dt_values]
            # Construct corresponding sys.argv array
            cml = '%s --a %s --I %s --T %s --scheme CN --dt ' % \ 
                  (sys.argv[0], a, I, T)
            cml = cml + ' '.join([str(dt) for dt in dt_values])
            sys.argv = cml.split()
            computed = read_command_line_argparse()
            for expected_arg, computed_arg in zip(expected, computed):
                assert expected_arg == computed_arg


.. admonition:: Let silent test functions speak up during development

   When you develop test functions in a module, it is common to use IPython
   to reload the module and call the test function as it gets developed:
   
   .. code-block:: ipy
   
           In[1]: import decay
           
           In[2]: decay.test_read_command_line_argparse()
           
           In[3]: reload(decay)  # force new import
           
           In[2]: decay.test_read_command_line_argparse()  # test again
   
   However, a working test function is completely silent! Many
   find it psychologically annoying to convince themselves that a
   completely silent function is doing the right things. It can therefore,
   during development of a test function, be convenient to insert
   print statements in the function to monitor that the function body
   is indeed executed... For example, one can print the expected and
   computed values in the terminal window.




.. _softeng1:basic:unittest:

Classical class-based unit testing
----------------------------------

.. index:: unit testing

.. index:: unittest

.. index::
   single: software testing; unit testing (class-based)

The test functions written for the nose and pytest frameworks are
very straightforward and to the point, with no framework-required boilerplate
code. We just write the statements we need to make the computations and
comparisons and then make the require ``assert``.

The classical way implementing unit tests derives from the JUnit
tool in Java and leads to much more comprehensive implementations with
much more boilerplate code.
Python comes with a built-in module ``unittest`` for doing this type of
unit tests. Although I strongly recommend to use nose or pytest over
``unittest``, class-based unit testing in the style of ``unittest``
has a very strong position in computer science and is so widespread
that even computational scientists should have an idea how such
unit test code is written. A short demo of ``unittest`` is therefore
included next.

.. index:: unittest

.. index:: TestCase (class in unittest)

Suppose we have a function ``double(x)`` in a module file ``mymod.py``:

.. code-block:: python

        def double(x):
            return 2*x

Unit testing with the aid of the ``unittest`` module
consists of writing a file ``test_mymod.py`` for testing the functions
in ``mymod.py``. The individual tests must be methods with names
starting with ``test_`` in a class derived from class ``TestCase`` in
``unittest``. With one test method for the function ``double``, the
``test_mymod.py`` file becomes

.. code-block:: python

        import unittest
        import mymod
        
        class TestMyCode(unittest.TestCase):
            def test_double(self):
                x = 4
                expected = 2*x
                computed = mymod.double(x)
                self.assertEqual(expected, computed)
        
        if __name__ == '__main__':
            unittest.main()

The test is run by executing the test file ``test_mymod.py`` as a standard
Python program. There is no support in ``unittest`` for automatically
locating and running all tests in all test files in a directory tree.

We could use the basic ``assert`` statement as we did with nose and pytest
functions, but those who write code based on ``unittest`` almost
exclusively use the wide range of built-in assert functions such
as ``assertEqual``, ``assertNotEqual``, ``assertAlmostEqual``, to mention
some of them.

Translation of ``test_exact_discrete_solution``,
``test_potential_integer_division``, and the other test functions in ``decay.py``
to ``unittest`` means making a new file ``test_decay.py`` file with a
test class ``TestDecay`` where the stand-alone functions for
nose/pytest now become methods in this class.

.. code-block:: python

        import unittest
        import decay
        import numpy as np
        
        def exact_discrete_solution(n, I, a, theta, dt):
            ...
        
        class TestDecay(unittest.TestCase):
        
            def test_exact_discrete_solution(self):
                theta = 0.8; a = 2; I = 0.1; dt = 0.8
                Nt = int(8/dt)  # no of steps
                u, t = decay.solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
                # Evaluate exact discrete solution on the mesh
                u_de = np.array([exact_discrete_solution(n, I, a, theta, dt)
                                 for n in range(Nt+1)])
                diff = np.abs(u_de - u).max()  # largest deviation
                self.assertAlmostEqual(diff, 0, delta=1E-14)
        
            def test_potential_integer_division(self):
                ...
                self.assertAlmostEqual(diff, 0, delta=1E-14)
        
            def test_read_command_line_positional(self):
                ...
                for expected_arg, computed_arg in zip(expected, computed):
                    self.assertEqual(expected_arg, computed_arg)
        
            def test_read_command_line_argparse(self):
                ...
        
        if __name__ == '__main__':
            unittest.main()

.. _softeng1:prog:se:class:

Classes for problem and solution method
=======================================

The :math:`\theta`-rule was compactly and conveniently implemented in
a function ``solver`` in the section :ref:`softeng1:basic:math`.
In more complicated problems it might
be beneficial to use classes and introduce a class ``Problem`` to
hold the definition of the physical problem, and a class ``Solver``
to hold the data and methods needed to numerically solve the problem.
This idea will now be illustrated, resulting in code that represents
an alternative to the ``solver`` and ``experiment_*`` functions found
in the ``decay`` module.

Explaining the details of class programming in Python is considered
beyond the scope of this text.  Readers who are unfamiliar with Python
class programming should first consult one of the many electronic
Python tutorials or textbooks to come up to speed with concepts and
syntax of Python classes before reading on. The author has a gentle
introduction to class programming for scientific applications
in [Ref1]_, see Chapter 7 and 9 and Appendix E.
Other useful resources are

 * The Python Tutorial: `<http://docs.python.org/2/tutorial/classes.html>`_

 * Wiki book on Python Programming: `<http://en.wikibooks.org/wiki/Python_Programming/Classes>`_

 * tutorialspoint.com: `<http://www.tutorialspoint.com/python/python_classes_objects.htm>`_

The problem class  (1)
----------------------

.. index:: problem class

The purpose of the problem class is to store all information about
the mathematical model. This usually means the physical parameters
and formulas
in the problem. Looking at our model problem
:eq:`softeng1:ode`-:eq:`softeng1:u0`, the physical data cover
:math:`I`, :math:`a`, and :math:`T`. Since we have an analytical solution of
the ODE problem, we may add this solution in terms of a Python
function (or method) to the problem class as well.
A possible problem class is therefore

.. code-block:: python

        from numpy import exp
        
        class Problem:
            def __init__(self, I=1, a=1, T=10):
                self.T, self.I, self.a = I, float(a), T
        
            def u_exact(self, t):
                I, a = self.I, self.a
                return I*exp(-a*t)

We could in the ``u_exact`` method have written
``self.I*exp(-self.a*t)``, but using local variables ``I`` and ``a`` allows
the formula ``I*exp(-a*t)`` which looks closer to the mathematical
expression :math:`Ie^{-at}`.  This is not an important issue with the
current compact formula, but is beneficial in more complicated
problems with longer formulas to obtain the closest possible
relationship between code and mathematics. My coding style is to strip
off the ``self`` prefix when the code expresses mathematical formulas.

The class data can be set either as arguments in the constructor or
at any time later, e.g.,

.. code-block:: python

        problem = Problem(T=5)
        problem.T = 8
        problem.dt = 1.5

(Some programmers prefer ``set`` and ``get`` functions for setting and getting
data in classes, often implemented via *properties* in Python, but
I consider that overkill when we just have a few data items in a class.)

It would be convenient if class ``Problem`` could also initialize
the data from the command line. To this end, we add a method for
defining a set of command-line options and a method that sets the
local attributes equal to what was found on the command line.
The default values associated with the command-line options are taken
as the values provided to the constructor. Class ``Problem`` now becomes

.. code-block:: python

        class Problem:
            def __init__(self, I=1, a=1, T=10):
                self.T, self.I, self.a = I, float(a), T
        
            def define_command_line_options(self, parser=None):
                """Return updated (parser) or new ArgumentParser object."""
                if parser is None:
                    import argparse
                    parser = argparse.ArgumentParser()
        
                parser.add_argument(
                    '--I', '--initial_condition', type=float,
                    default=1.0, help='initial condition, u(0)',
                    metavar='I')
                parser.add_argument(
                    '--a', type=float, default=1.0,
                    help='coefficient in ODE', metavar='a')
                parser.add_argument(
                    '--T', '--stop_time', type=float,
                    default=1.0, help='end time of simulation',
                    metavar='T')
                return parser
        
            def init_from_command_line(self, args):
                """Load attributes from ArgumentParser into instance."""
                self.I, self.a, self.T = args.I, args.a, args.T
        
            def u_exact(self, t):
                """Return the exact solution u(t)=I*exp(-a*t)."""
                I, a = self.I, self.a
                return I*exp(-a*t)

Observe that if the user already has an ``ArgumentParser`` object it can be
supplied, but if she does not have any, class ``Problem`` makes one.
Python's ``None`` object is used to indicate that a variable is not
initialized with a proper value.

The solver class  (1)
---------------------

.. index:: solver class

.. index:: wrapper (code)

The solver class stores data related to the numerical solution method
and provides a function ``solve`` for solving the problem.
A problem object must be given to the constructor so that the solver
can easily look up physical data. In the present example, the
data related to the numerical solution method consists of :math:`\Delta t`
and :math:`\theta`. We add, as in the problem class, functionality for
reading :math:`\Delta t` and :math:`\theta` from the command line:

.. code-block:: python

        class Solver:
            def __init__(self, problem, dt=0.1, theta=0.5):
                self.problem = problem
                self.dt, self.theta = float(dt), theta
        
            def define_command_line_options(self, parser):
                """Return updated (parser) or new ArgumentParser object."""
                parser.add_argument(
                    '--scheme', type=str, default='CN',
                    help='FE, BE, or CN')
                parser.add_argument(
                    '--dt', '--time_step_values', type=float,
                    default=[1.0], help='time step values',
                    metavar='dt', nargs='+', dest='dt_values')
                return parser
        
            def init_from_command_line(self, args):
                """Load attributes from ArgumentParser into instance."""
                self.dt, self.theta = args.dt, args.theta
        
            def solve(self):
                self.u, self.t = solver(
                    self.problem.I, self.problem.a, self.problem.T,
                    self.dt, self.theta)
        
            def error(self):
                """Return norm of error at the mesh points."""
                u_e = self.problem.u_exact(self.t)
                e = u_e - self.u
                E = sqrt(self.dt*sum(e**2))
                return E

Note that the ``solve`` method is just a *wrapper*
of the previously developed stand-alone ``solver`` function.

Combining the objects
~~~~~~~~~~~~~~~~~~~~~

Eventually we need to show how the classes ``Problem`` and ``Solver``
play together:

.. code-block:: python

        def experiment_classes():
            problem = Problem()
            solver = Solver(problem)
        
            # Read input from the command line
            parser = problem.define_command_line_options()
            parser = solver. define_command_line_options(parser)
            args = parser.parse_args()
            problem.init_from_command_line(args)
            solver. init_from_command_line(args)
        
            # Solve and plot
            solver.solve()
            import matplotlib.pyplot as plt
            t_e = np.linspace(0, T, 1001)    # very fine mesh for u_e
            u_e = problem.u_exact(t_e)
        
            plt.plot(t,   u,   'r--o')       # dashed red line with circles
            plt.plot(t_e, u_e, 'b-')         # blue line for u_e
            plt.legend(['numerical, theta=%g' % theta, 'exact'])
            plt.xlabel('t')
            plt.ylabel('u')
            plotfile = 'tmp'
            plt.savefig(plotfile + '.png');  plt.savefig(plotfile + '.pdf')
        
            error = problem.u_exact(t) - u
            E = np.sqrt(dt*np.sum(error**2))
            print 'Error norm:', E
            plt.show()
        
        
        if __name__ == '__main__':
            experiment_compare_dt(True)
            plt.show()

.. _softeng1:prog:se:class2:

Improving the problem and solver classes
----------------------------------------

The previous ``Problem`` and ``Solver`` classes containing parameters
soon get much repetitive code when the number of parameters increases.
Much of this code can be parameterized and be made more compact.
For this purpose, we decide to collect all parameters in a dictionary,
``self.prm``, with two associated dictionaries ``self.type`` and
``self.help`` for holding associated object types and help strings.
For the specific ODE example we deal with, such dictionaries are

.. code-block:: python

        # Problem data
        self.prm  = dict(I=1, a=1, T=10)
        self.type = dict(I=float, a=float, T=float)
        self.help = dict(I='initial condition, u(0)',
                         a='coefficient in ODE',
                         T='end time of simulation')
        # Solver data
        self.prm  = dict(dt=0.5, theta=0.5)
        self.type = dict(dt=float, theta=float)
        self.help = dict(dt='time step value',
                         theta='time discretization parameter')

Provided a problem or solver class defines these three
dictionaries in the constructor, using default or user-supplied values
of the parameters, we can create a super class ``Parameters`` with general code
for defining command-line options and reading them as well as
methods for setting and getting a parameter. A ``Problem`` or ``Solver`` for
a particular mathematical problem can then
inherit most of the needed functionality and code
from the ``Parameters`` class.

A generic class for parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A simplified version of the parameter class looks as follows:

.. code-block:: python

        class Parameters:
            def set(self, **parameters):
                for name in parameters:
                    if name in self.prm:
                        self.prm[name] = parameters[name]
                    else:
                        raise NameError('Illegal parameter name %s' % name)
        
            def get(self, name):
                """Return value of parameter with given name."""
                return self.prm[name]
        
            def define_command_line_options(self, parser=None):
                """Automatic registering of options."""
                if parser is None:
                    import argparse
                    parser = argparse.ArgumentParser()
        
                for name in self.prm:
                    tp = self.type[name] if name in self.type else str
                    help = self.help[name] if name in self.help else None
                    parser.add_argument(
                        '--' + name, default=self.get(name), metavar=name,
                        type=tp, help=help)
        
                return parser
        
            def init_from_command_line(self, args):
                for name in self.prm:
                    self.prm[name] = getattr(args, name)

The file `decay_oo.py <http://tinyurl.com/nm5587k/softeng1/decay_oo.py>`__ contains
a slightly more advanced version of class ``Parameters`` where we
in the ``set`` and ``get`` functions test for valid parameter names and
raise exceptions with informative messages if any name is not registered.

The problem class  (2)
~~~~~~~~~~~~~~~~~~~~~~

.. index:: problem class

A class ``Problem`` for the problem :math:`u'=-au`, :math:`u(0)=I`, :math:`t\in (0,T]`, with
parameters input :math:`a`, :math:`I`, and :math:`T` can now be coded as

.. code-block:: python

        class Problem(Parameters):
            """
            Physical parameters for the problem u'=-a*u, u(0)=I,
            with t in [0,T].
            """
            def __init__(self):
                self.prm  = dict(I=1, a=1, T=10)
                self.type = dict(I=float, a=float, T=float)
                self.help = dict(I='initial condition, u(0)',
                                 a='coefficient in ODE',
                                 T='end time of simulation')
        
            def u_exact(self, t):
                I, a = self.get('I'), self.get('a')
                return I*np.exp(-a*t)

The solver class  (2)
~~~~~~~~~~~~~~~~~~~~~

.. index:: solver class

Also the solver class is derived from class ``Parameters`` and works with
the ``prms``, ``types``, and ``help`` dictionaries in the same way as class
``Problem``. Otherwise, the code is very similar to the previous class ``Solver``:

.. code-block:: python

        class Solver(Parameters):
            def __init__(self, problem):
                self.problem = problem
                self.prm  = dict(dt=0.5, theta=0.5)
                self.type = dict(dt=float, theta=float)
                self.help = dict(dt='time step value',
                                 theta='time discretization parameter')
        
            def solve(self):
                from decay_mod import solver
                self.u, self.t = solver(
                    self.problem.get('I'),
                    self.problem.get('a'),
                    self.problem.get('T'),
                    self.get('dt'),
                    self.get('theta'))
        
            def error(self):
                try:
                    u_e = self.problem.u_exact(self.t)
                    e = u_e - self.u
                    E = np.sqrt(self.get('dt')*np.sum(e**2))
                except AttributeError:
                    E = None
                return E

The advantage with the ``Parameters`` class is that it scales to problems
with a large number of physical and numerical parameters:
as long as the parameters are defined once via a dictionary,
the compact code in class ``Parameters`` can handle any collection of
parameters of any size.

.. _softeng1:experiments:

Automating scientific experiments
=================================

Empirical scientific investigations based on running computer programs
require careful design of the experiments and accurate reporting of results.
Although there is a strong tradition to do such investigations manually,
the extreme requirements to scientific accuracy make a program much
better suited to conduct the experiments. We shall in this section outline
how we can write such programs, often called *scripts*, for running other
programs and archiving the results.


.. admonition:: Scientific investigation

   The purpose of the investigations is to explore the quality of numerical
   solutions to an ordinary differential equation. More specifically, we
   solve the initial-value problem
   
   .. _Eq:softeng1:experiments:model:

.. math::
   :label: softeng1:experiments:model
           
           u^\prime(t) = -au(t),\quad u(0)=I,\quad t\in (0,T],
           
           
   
   by the :math:`\theta`-rule:
   
   .. _Eq:softeng1:experiments:theta:

.. math::
   :label: softeng1:experiments:theta
           
           u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
           \quad u^0=I{\thinspace .}
           
           
   
   This scheme corresponds to well-known methods: :math:`\theta=0` gives the
   Forward Euler (FE) scheme, :math:`\theta=1` gives the Backward Euler (BE) scheme,
   and :math:`\theta=\frac{1}{2}` gives the Crank-Nicolson
   (CN) or midpoint/centered scheme.
   
   For fixed :math:`I`, :math:`a`, and :math:`T`, we run the three schemes for various
   values of :math:`\Delta t`, and present in a report the following results:
   
   1. visual comparison of the numerical and exact solution in a plot for
      each :math:`\Delta t` and :math:`\theta=0,1,\frac{1}{2}`,
   
   2. a table and a plot of the norm of the numerical error versus :math:`\Delta t`
      for :math:`\theta=0,1,\frac{1}{2}`.
   
   The report will also document the mathematical details of the problem under
   investigation.




Available software
------------------

Appropriate software for implementing :eq:`softeng1:experiments:theta`
is available in a program `model.py <http://hplgit.github.io/teamods/writing_reports/doconce_src/model.py>`__, which is run as

.. code-block:: text

        Terminal> python model.py --I 1.5 --a 0.25 --T 6 --dt 1.25 0.75 0.5

The command-line input corresponds to setting :math:`I=1.5`, :math:`a=0.25`, :math:`T=6`,
and run three values of :math:`\Delta t`: 1.25, 0.75, ad 0.5.

The results of running this ``model.py`` command are text in the
terminal window and a set of plot files.
The plot files have names ``M_D.E``, where ``M`` denotes the method
(``FE``, ``BE``, ``CN`` for :math:`\theta=0,1,\frac{1}{2}`), ``D``
the time step length (here ``1.25``, ``0.75``, or ``0.5``), and ``E``
is the plot file extension ``png`` or ``pdf``.
The text output looks like

.. code-block:: text

        0.0   1.25:    5.998E-01
        0.0   0.75:    1.926E-01
        0.0   0.50:    1.123E-01
        0.0   0.10:    1.558E-02
        0.5   1.25:    6.231E-02
        0.5   0.75:    1.543E-02
        0.5   0.50:    7.237E-03
        0.5   0.10:    2.469E-04
        1.0   1.25:    1.766E-01
        1.0   0.75:    8.579E-02
        1.0   0.50:    6.884E-02
        1.0   0.10:    1.411E-02

The first column is the :math:`\theta` value, the next the :math:`\Delta t` value,
and the final column represents the numerical error :math:`E` (the
norm of discrete error function on the mesh).

Required new results
--------------------

The results we need for our investigations are slightly different than
what is directly produced by ``model.py``:

1. We need to collect all the plots for one
   numerical method (FE, BE, CN) in a single plot.
   For example, if 4 :math:`\Delta t` values are run, the summarizing plot
   for the BE method has :math:`2\times 2` subplots, with the subplot corresponding
   to the largest :math:`\Delta t` is in the upper left corner and the smallest
   is in the bottom right corner.

2. We need to have a table containing
   :math:`\Delta t` values in the first column and the numerical error
   :math:`E` for :math:`\theta0,0.5,1`
   in the next three columns. This table should be available as a
   standard CSV file.

3. We need to plot the numerical error :math:`E` versus :math:`\Delta t`
   in a log-log plot.

Consequently, we need to write a program (script)
that can run ``model.py`` as described and
produce the results 1-3 above. This requires combining multiple plot files into
a file and interpreting the output from ``model.py`` as data for plotting and
file storage.

If the script's name is ``exper1.py``, we run it with the desired :math:`\Delta t`
values as positional command-line arguments:

.. code-block:: text

        Terminal> python exper1.py 0.5 0.25 0.1 0.05

This run will then generate eight plot files: ``FE.png`` and ``FE.pdf`` summarizing
the plots with the FE method, ``BE.png`` and ``BE.pdf`` with
the BE method, ``CN.png`` and ``CN.pdf`` with the CN method, and ``error.png``
and ``error.pdf`` with the log-log plot of the numerical error versus :math:`\Delta t`.
In addition, the table with numerical errors is written to a
file ``error.csv``.


.. admonition:: Reproducible science

   A script that automates running our computer experiments
   will ensure
   that the experiments can easily be rerun by ourselves or others in
   the future, either to check the results or redo the experiments with
   other input data. Also, whatever we did to produce the results is
   documented in every detail in the script.
   Automating scripts are therefore essential to making our
   research *reproducible*, which is a fundamental principle in science.




Combining plot files
--------------------

Image files can be combined to new files using the
`montage <http://www.imagemagick.org/script/montage.php>`__
and
`convert <http://www.imagemagick.org/script/convert.php>`__ programs in
the ImageMagick software suite. However, these programs are best suited for
PNG files. For vector plots in PDF format one needs other tools
to preserve the quality: ``pdftk``, ``pdfnup``, and ``pdfcrop``.
Suppose you have four files ``f1.png``, ``f2.png``, ``f3.png``, and ``f4.png``
and want to combine them into a :math:`2\times 2` table of subplots in a new
file ``f.png``, see
Figure :ref:`softeng1:experiments:fig:BE4a` for an example.

.. _softeng1:experiments:fig:BE4a:

.. figure:: BE4a.png
   :width: 600

   *Illustration of the Backward Euler method for four time step values*

The appropriate ImageMagick commands are

.. code-block:: text

        Terminal> montage -background white -geometry 100% -tile 2x \ 
                  f1.png f2.png f3.png f4.png f.png
        Terminal> convert -trim f.png f.png
        Terminal> convert f.png -transparent white f.png

The first command mounts the four files in one, the next ``convert`` command
removes unnecessary surrounding white space, and the final ``convert`` command
makes the white background transparent.

High-quality montage of PDF files ``f1.pdf``,
``f2.pdf``, ``f3.pdf``, and ``f4.pdf`` into ``f.pdf`` goes like

.. code-block:: text

        Terminal> pdftk f1.pdf f2.pdf f3.pdf f4.pdf output tmp.pdf
        Terminal> pdfnup --nup 2x2 --outfile tmp.pdf tmp.pdf
        Terminal> pdfcrop tmp.pdf f.pdf
        Terminal> rm -f tmp.pdf

Running a program from Python
-----------------------------

Suppose you want to run some operating system command stored in a string
``cmd``. For example, ``cmd`` could be ``python model.py --I 1 --dt 0.5 0.2``.
The following Python code
executes ``cmd`` and loads the text output into a string ``output``:

.. code-block:: python

        from subprocess import Popen, PIPE, STDOUT
        p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)
        output, dummy = p.communicate()
        
        # Check if run was successful
        failure = p.returncode
        if failure:
            print 'Command failed:', cmd; sys.exit(1)

In our case, we need to interpret the contents of ``output`` and store
the data in an appropriate data structure.
Since the content is basically a table and will be transformed to
a spread sheet format, we let the columns in the table be lists,
and we collect the columns in a dictionary whose keys are natural
column names: ``dt`` and the three values of :math:`\theta`.
The following code translates ``output`` to such a dictionary of lists:

.. code-block:: python

        errors = {'dt': dt_values, 1: [], 0: [], 0.5: []}
        for line in output.splitlines():
            words = line.split()
            if words[0] in ('0.0', '0.5', '1.0'):  # line with E?
                # typical line: 0.0   1.25:    7.463E+00
                theta = float(words[0])
                E = float(words[2])
                errors[theta].append(E)

The automating script
---------------------

Running ``model.py`` for a set of :math:`\Delta t` values and producing files as
described above, can be done by the following code:

.. code-block:: python

        import os, sys, glob
        import matplotlib.pyplot as plt
        
        def run_experiments(I=1, a=2, T=5):
            # The command line must contain dt values
            if len(sys.argv) > 1:
                dt_values = [float(arg) for arg in sys.argv[1:]]
            else:
                print 'Usage: %s dt1 dt2 dt3 ...' %  sys.argv[0]
                sys.exit(1)  # abort
        
            # Run module file and grab output
            cmd = 'python model.py --I %g --a %g --T %g' % (I, a, T)
            dt_values_str = ' '.join([str(v) for v in dt_values])
            cmd += ' --dt %s' % dt_values_str
            print cmd
            from subprocess import Popen, PIPE, STDOUT
            p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT)
            output, dummy = p.communicate()
            failure = p.returncode
            if failure:
                print 'Command failed:', cmd; sys.exit(1)
        
            errors = {'dt': dt_values, 1: [], 0: [], 0.5: []}
            for line in output.splitlines():
                words = line.split()
                if words[0] in ('0.0', '0.5', '1.0'):  # line with E?
                    # typical line: 0.0   1.25:    7.463E+00
                    theta = float(words[0])
                    E = float(words[2])
                    errors[theta].append(E)
        
            # Find min/max for the axis
            E_min = 1E+20; E_max = -E_min
            for theta in 0, 0.5, 1:
                E_min = min(E_min, min(errors[theta]))
                E_max = max(E_max, max(errors[theta]))
        
            plt.loglog(errors['dt'], errors[0], 'ro-')
            #plt.hold('on')  # Matlab style...
            plt.loglog(errors['dt'], errors[0.5], 'b+-')
            plt.loglog(errors['dt'], errors[1], 'gx-')
            plt.legend(['FE', 'CN', 'BE'], loc='upper left')
            plt.xlabel('log(time step)')
            plt.ylabel('log(error)')
            plt.axis([min(dt_values), max(dt_values), E_min, E_max])
            plt.title('Error vs time step')
            plt.savefig('error.png')
            plt.savefig('error.pdf')
            # Write out a table in CSV format
            f = open('error.csv', 'w')
            f.write(r'$\Delta t$,$\theta=0$,$\theta=0.5$,$\theta=1$' + '\n')
            for _dt, _fe, _cn, _be in zip(
                errors['dt'], errors[0], errors[0.5], errors[1]):
                f.write('%.2f,%.4f,%.4f,%.4f\n' % (_dt, _fe, _cn, _be))
            f.close()
        
            # Combine images into rows with 2 plots in each row
            image_commands = []
            for method in 'BE', 'CN', 'FE':
                pdf_files = ' '.join(['%s_%g.pdf' % (method, dt)
                                      for dt in dt_values])
                png_files = ' '.join(['%s_%g.png' % (method, dt)
                                      for dt in dt_values])
                image_commands.append(
                    'montage -background white -geometry 100%' +
                    ' -tile 2x %s %s.png' % (png_files, method))
                image_commands.append(
                    'convert -trim %s.png %s.png' % (method, method))
                image_commands.append(
                    'convert %s.png -transparent white %s.png' %
                    (method, method))
                image_commands.append(
                    'pdftk %s output tmp.pdf' % pdf_files)
                num_rows = int(round(len(dt_values)/2.0))
                image_commands.append(
                    'pdfnup --nup 2x%d --outfile tmp.pdf tmp.pdf' % num_rows)
                image_commands.append(
                    'pdfcrop tmp.pdf %s.pdf' % method)
        
            for cmd in image_commands:
                print cmd
                failure = os.system(cmd)
                if failure:
                    print 'Command failed:', cmd; sys.exit(1)
        
            # Remove the files generated above and by model.py
            from glob import glob
            filenames = glob('*_*.png') + glob('*_*.pdf') + glob('tmp*.pdf')
            for filename in filenames:
                os.remove(filename)
        
        if __name__ == '__main__':
            run_experiments(I=1, a=2, T=5)
            plt.show()  # at the end of the program

.. index:: Unix wildcard notation

.. index:: wildcard notation (Unix)

.. index:: os.system

We may comment upon many useful constructs in this script:

 * ``[float(arg) for arg in sys.argv[1:]]`` builds a list of real numbers
   from all the command-line arguments.

 * ``failure = os.system(cmd)`` runs an operating system command, e.g.,
   another program. The execution is successful only if ``failure`` is zero.

 * Unsuccessful execution usually makes it meaningless to continue
   the program, and therefore we abort the program with ``sys.exit(1)``.
   Any argument different from 0 signifies to the computer's operating system
   that our program stopped with a failure.

 * ``['%s_%s.png' % (method, dt) for dt in dt_values]`` builds a list of
   filenames from a list of numbers (``dt_values``).

 * All ``montage``, ``convert``, ``pdftk``, ``pdfnup``, and ``pdfcrop``
   commands for creating
   composite figures are stored in a
   list and later executed in a loop.

 * ``glob('*_*.png')`` returns a list of the names of all files in the
   current directory where the filename matches the `Unix wildcard notation <http://en.wikipedia.org/wiki/Glob_(programming)>`__
   ``*_*.png`` (meaning any text, underscore, any text, and then ``.png``).

 * ``os.remove(filename)`` removes the file with name ``filename``.

.. _softeng1:exper:report:

Making a report
---------------

The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in that script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at an
example at `<http://hplgit.github.io/teamods/writing_reports/sphinx-cloud/>`_  to see what we have in
mind.

Plain HTML
~~~~~~~~~~

Scientific reports can be written in a variety of formats. Here we
begin with the `HTML <http://en.wikipedia.org/wiki/HTML>`__ format
which allows efficient viewing of all the experiments in any web
browser. The program
`exper1_html.py <http://hplgit.github.io/teamods/writing_reports/report_generation/exper1_html.py>`__ calls
``exper1.py`` to perform the experiments and then runs
statements for creating an HTML file with a summary, a
section on the mathematical problem, a section on the numerical
method, a section on the ``solver`` function implementing the
method, and a section with subsections containing figures that show
the results of experiments where :math:`\Delta t` is varied for
:math:`\theta=0,0.5,1`. The mentioned
Python file contains all the details for writing
this `HTML report <http://hplgit.github.io/teamods/writing_reports/_static/report_html.html.html>`__.
You can view the report on `<http://hplgit.github.io/teamods/writing_reports/_static/report_html.html>`_.

HTML with MathJax
~~~~~~~~~~~~~~~~~

Scientific reports usually need mathematical formulas and hence
mathematical typesetting. In plain HTML, as used in the
``exper1_html.py`` file, we have to use just the keyboard
characters to write mathematics. However, there is an extension to
HTML, called `MathJax <http://www.mathjax.org/>`__, which allows
formulas and equations to be typeset with LaTeX syntax and nicely
rendered in web browsers, see Figure
:ref:`softeng1:exper:report:fig:mathjax`.  A relatively small subset of
LaTeX environments is supported, but the syntax for formulas is quite
rich. Inline formulas are look like ``\( u'=-au \)`` while equations are
surrounded by ``$$`` signs.  Inside such signs, one can use ``\[ u'=-au
\]`` for unnumbered equations, or ``\begin{equation}`` and
``\end{equation}`` surrounding ``u'=-au`` for numbered equations, or
``\begin{equation}`` and ``\end{equation}`` for multiple aligned equations.  You
need to be familiar with `mathematical typesetting in LaTeX <http://en.wikibooks.org/wiki/LaTeX/Mathematics>`__.

The file `exper1_mathjax.py <http://hplgit.github.io/teamods/writing_reports/report_generation/exper1_html.py>`__ contains all the
details for turning the previous plain HTML report into `web pages
with nicely typeset mathematics <http://hplgit.github.io/teamods/writing_reports/_static/report_mathjax.html>`__.  The
`corresponding HTML code <http://hplgit.github.io/teamods/writing_reports/_static/report_mathjax.html.html>`__ be studied
to see all details of the mathematical typesetting.

.. _softeng1:exper:report:fig:mathjax:

.. figure:: report_mathjax.png
   :width: 600

   *Report in HTML format with MathJax*

LaTeX
~~~~~

.. "http://en.wikibooks.org/wiki/LaTeX"

The *de facto* language for mathematical typesetting and scientific
report writing is `LaTeX <http://en.wikipedia.org/wiki/LaTeX>`__. A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the `PDF format <http://hplgit.github.io/teamods/writing_reports/_static/report.pdf>`__, see Figure
:ref:`softeng1:exper:report:fig:latex` for an example, LaTeX is the
definite choice when it comes to quality. The LaTeX language used to
write the reports has typically a lot of commands involving
`backslashes and braces <http://hplgit.github.io/teamods/writing_reports/_static/report.tex.html>`__.  For output on the web,
using HTML (and not the PDF directly in the browser window), LaTeX
struggles with delivering high quality typesetting. Other tools,
especially Sphinx, give better results and can also produce
nice-looking PDFs.  The file `exper1_latex.py <http://hplgit.github.io/teamods/writing_reports/report_generation/exper1_latex.py>`__ shows how to
generate the LaTeX source from a program.

.. _softeng1:exper:report:fig:latex:

.. figure:: report_latexpdf.png
   :width: 600

   *Report in PDF format generated from LaTeX source*

Sphinx
~~~~~~

.. give pointers to source pages

`Sphinx <http://sphinx.pocoo.org/>`__ is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize LaTeX for mathematical
formulas and equations (via MathJax or PNG images). Unfortunately, the
subset of LaTeX mathematics supported is less than in full MathJax (in
particular, numbering of multiple equations in an ``align`` type
environment is not supported).  The `Sphinx syntax <http://hplgit.github.io/teamods/writing_reports/_static/report_sphinx.rst.html>`__ is an extension of
the reStructuredText language. An attractive feature of Sphinx is its
rich support for `fancy layout of web pages <http://hplgit.github.io/teamods/writing_reports/_static/sphinx-cloud/index.html>`__. In particular,
Sphinx can easily be combined with various layout *themes* that give a
certain look and feel to the web site and that offers table of
contents, navigation, and search facilities, see Figure
:ref:`softeng1:exper:report:fig:sphinx`.

.. _softeng1:exper:report:fig:sphinx:

.. figure:: report_sphinx.png
   :width: 600

   *Report in HTML format generated from Sphinx source*

Markdown
~~~~~~~~

A recently popular format for easy writing of web pages is
`Markdown <http://daringfireball.net/projects/markdown/>`__.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool `Pandoc <http://johnmacfarlane.net/pandoc/>`__ one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice, MediaWiki, and MS Word are some other possibilities.

Wiki formats
~~~~~~~~~~~~

A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and add
content. Apart from `MediaWiki <http://www.mediawiki.org/wiki/MediaWiki>`__ (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.

DocOnce
~~~~~~~

Since it is difficult to choose the right tool or format for writing a
scientific report, it is advantageous to write the content in a format
that easily translates to LaTeX, HTML, Sphinx, Markdown, and various
wikis. `DocOnce <https://github.com/hplgit/doconce>`__ is such a
tool. It is similar to Pandoc, but offers some special convenient
features for writing about mathematics and programming.  The `tagging
is modest <http://hplgit.github.io/teamods/writing_reports/_static/report.do.txt.html>`__, somewhere
between LaTeX and Markdown.  The program `exper1_do.py <http://hplgit.github.io/teamods/writing_reports/report_generation/exper1_do.py>`__ demonstrates how
to generate (and write) DocOnce code for a report.

Worked example
~~~~~~~~~~~~~~

The HTML, LaTeX (PDF), Sphinx, and DocOnce formats for the scientific
report whose content is outlined above, are exemplified
with source codes and results at the
web pages associated with this teaching material:
`<http://hplgit.github.io/teamods/writing_reports>`_.

.. project with exploring instability (help with matplotlib contour plots, and maybe show such a plot)

.. _softeng1:exper:github:

Publishing a complete project
-----------------------------

A report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.
This possibility is important for *reproducible research* and
hence reaching reliable scientific conclusions.

One way of documenting a complete project is to make a directory tree
with all relevant files. Preferably, the tree is published at
some project hosting site like `Bitbucket or GitHub <http://hplgit.github.com/teamods/bitgit/html/>`__ so that others can download it
as a tarfile, zipfile, or clone the files directly using the Git version control
system.
For the investigations outlined in the section :ref:`softeng1:exper:report`,
we can create a directory tree with files

.. code-block:: text

        setup.py
        ./src:
           model.py
        ./doc:
           ./src:
              exper1_mathjax.py
              make_report.sh
              run.sh
           ./pub:
              report.html

The ``src`` directory holds source code (modules) to be reused in other projects,
the ``setup.py`` builds and installs such software,
the ``doc`` directory contains the documentation, with ``src`` for the
source of the documentation and ``pub`` for ready-made, published documentation.
The ``run.sh`` file is a simple Bash script listing the ``python`` command
we used to run ``exper1_mathjax.py`` to generate the experiments and
the ``report.html`` file.

.. Point to DocOnce version

Exercises
=========

.. --- begin exercise ---

.. _softeng1:exer:derivative:

Problem 1: Make a tool for differentiating curves
-------------------------------------------------

Suppose we have a curve specified through a set
of discrete coordinates :math:`(x_i,y_i)`, :math:`i=0,\ldots,n`, where the :math:`x_i`
values are uniformly distributed with spacing :math:`\Delta x`: :math:`x_i=\Delta x`.
The derivative of this curve, defined as a new curve with points
:math:`(x_i, d_i)`, can be computed via finite differences:

.. math::
        
        d_0 = \frac{y_1-y_0}{\Delta x},
        

.. math::
          
        d_i = \frac{y_{i+1}-y_{i-1}}{2\Delta x},\quad i=1,\ldots,n-1,
        

.. math::
          
        d_n = \frac{y_n-y_{n-1}}{\Delta x}{\thinspace .}
        

**a)**
Write a function
``differentiate(x, y)`` for differentiating a curve
   with coordinates in the arrays ``x`` and ``y``, using the
   formulas above. The function should return the coordinate arrays
of the resulting differentiated curve.

**b)**
Write a test function for the function in a).

**c)**
Start with a curve corresponding to :math:`y=\sin(\pi x)` and :math:`n+1`
points in :math:`[0,1]`. Apply ``differentiate`` four times and plot the
resulting curve and the exact :math:`y=\sin\pi x` for :math:`n=6, 11, 21, 41`.

.. Using a 2nd-order backward formula at x=1 does not improve the

.. results much, one gets large errors at the end points.

Filename: ``curvediff.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _softeng1:exer:integral:flat:

Problem 2: Make solid software for the Trapezoidal rule
-------------------------------------------------------

An integral

.. math::
         \int_a^b f(x)dx 

can be numerically approximated by the Trapezoidal rule,

.. math::
         \int_a^b f(x)dx \approx \frac{h}{2}(f(a) + f(b)) + h\sum_{i=1}^{n-1} f(x_i),
        

where :math:`x_i` is a set of uniformly spaced points in :math:`[a,b]`:

.. math::
         h = \frac{b-a}{n},\quad x_i=a + ih,\ i=1,\ldots,n-1{\thinspace .} 

Somebody has used this rule to compute the integral :math:`\int_0^\pi sin^2x dx`:

.. code-block:: python

        from math import pi, sin
        n = 20
        h = pi/n
        I = 0
        for i in range(1, n):
            I += sin(i*h)**2
        print I

**a)**
The "flat" implementation above suffers from three serious flaws:

1. A general numerical algorithm (the Trapezoidal rule) is implemented
   in a specialized form where the formula for :math:`f` is inserted directly
   into the code for the general integration formula.

2. A general numerical algorithm is not encapsulated as a general
   function, with appropriate parameters, which can be reused
   across a wide range of applications.

3. The lazy programmer dropped the first terms in the general formula
   since :math:`\sin(0)=\sin(\pi)=0`.

Write a function ``trapezoidal`` that fixes these flaws.
Place the function in a module ``trapezoidal``.

**b)**
Write a test function ``test_trapezoidal``. Call the test function
explicitly to check that it works. Remove the call and run pytest
on the module:

.. code-block:: text

        Terminal> py.test -s -v trapezoidal

.. --- begin hint in exercise ---

**Hint.**
Note that even if you know the value of the integral, you do not know
the error in the approximation produced by the Trapezoidal rule.
However, the Trapezoidal rule will integrate linear functions,
and piecewise linear functions, with discontinuities at the :math:`x_i`
points, exactly (i.e., to machine precision). Base a test function
on such linear functions :math:`f(x)`.

.. --- end hint in exercise ---

**c)**
Add functionality for computing :math:`\int_a^b f(x)dx` by providing
:math:`f`, :math:`a`, :math:`b`, and :math:`n` as positional command-line arguments:

.. code-block:: text

        Terminal> python trapezoidal.py 'sin(x)**2' 0 pi 20

Note that the ``trapezoidal.py`` must still be a valid module file, so the
interpretation of command-line data and computation of the integral
must be performed from calls in a test block.

.. --- begin hint in exercise ---

**Hint.**
To translate a string formula on the command line, like ``sin(x)**2``,
into a Python function, you can wrap a function declaration around
the formula and run ``exec`` on the string to turn it into live Python code:

.. code-block:: python

        import math, sys
        formula = sys.argv[1]
        f_code = """
        def f(x):
            return %s
        """ % formula
        exec(code, math.__dict__)

The result is the same as if we had hardcoded

.. code-block:: python

        def f(x):
            return sin(x)**2

in the program. Note that ``exec`` needs the namespace
``math.__dict__``, i.e., all names in the ``math`` module, such that
it understands ``sin`` and other mathematical functions.
Similarly, to allow :math:`a` and :math:`b` to be ``math`` values like ``pi``,
do

.. code-block:: text

        a = eval(sys.argv[2], math.__dict__)
        b = eval(sys.argv[2], math.__dict__)

.. --- end hint in exercise ---

**d)**
Write a test function for verifying the implementation of the
reading data from the command line.

Filename: ``trapezoidal.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _softeng1:exer:integral:flat2:

Problem 3: Implement classes for the Trapezoidal rule
-----------------------------------------------------

We consider the same problem setting as in :ref:`softeng1:exer:integral:flat`. Make a module with a class ``Problem``
representing the mathematical problem to be solved and a class
``Solver`` representing the solution method.  The rest of the
functionality of the module, including test functions and reading data
from the command line, should be as in :ref:`softeng1:exer:integral:flat`.
Filename: ``trapezoidal_class.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _softeng1:exer:doctest1:

Problem 4: Write a doctest
--------------------------

Type in the following program and equip the ``roots`` function with a doctest:

.. code-block:: python

        import sys
        # This sqrt(x) returns real if x>0 and complex if x<0
        from numpy.lib.scimath import sqrt
        
        def roots(a, b, c):
            """
            Return the roots of the quadratic polynomial
            p(x) = a*x**2 + b*x + c.
        
            The roots are real or complex objects.
            """
            q = b**2 - 4*a*c
            r1 = (-b + sqrt(q))/(2*a)
            r2 = (-b - sqrt(q))/(2*a)
            return r1, r2
        
        a, b, c = [float(arg) for arg in sys.argv[1:]]
        print roots(a, b, c)

Make sure to test both real and complex roots.
Write out numbers with 14 digits or less.
Filename: ``doctest_roots.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _softeng1:exer:nosetest1:

Problem 5: Write a nose test
----------------------------

Make a test function for the ``roots`` function in
:ref:`softeng1:exer:doctest1`.
Filename: ``test_roots.py``.

.. --- end exercise ---

.. --- begin exercise ---

.. _softeng1:exer:class:dts:

Exercise 6: Make use of a class implementation
----------------------------------------------

Implement the ``experiment_compare_dt`` function from ``decay.py``
using class ``Problem`` and class ``Solver`` from
the section :ref:`softeng1:prog:se:class`.
The parameters ``I``, ``a``, ``T``, the scheme name, and a series of
``dt`` values should be read from the command line.
Filename: ``experiment_compare_dt_class.py``.

.. --- end exercise ---

