<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to computing with finite difference methods">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,representative (mesh function),array arithmetics,array computing,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,stability,amplification factor,A-stable methods,L-stable methods,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),convergence rate,verification,implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order method,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order method,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,terminal velocity,geometric mean,averaging geometric,scaling">

<title>Introduction to computing with finite difference methods</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods  ',
               1,
               'decay:basics',
               'decay:basics'),
              (' A basic model for exponential decay ',
               2,
               'decay:model',
               'decay:model'),
              (' The Forward Euler scheme ',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              (' Step 1: Discretizing the domain ', 3, None, '___sec3'),
              (' Step 2: Fulfilling the equation at discrete time points ',
               3,
               None,
               '___sec4'),
              (' Step 3: Replacing derivatives by finite differences ',
               3,
               None,
               '___sec5'),
              (' Step 4: Formulating a recursive algorithm ',
               3,
               None,
               '___sec6'),
              (' The Backward Euler scheme ',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              (' The Crank-Nicolson scheme ',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              (' The unifying $\\theta$-rule ',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              (' Constant time step ', 2, None, '___sec10'),
              (' Mathematical derivation of finite difference formulas ',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              (' The forward difference ', 3, None, '___sec12'),
              (' The backward difference ', 3, None, '___sec13'),
              (' The centered difference ', 3, None, '___sec14'),
              (' Compact operator notation for finite differences ',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              (' Implementation ', 1, 'decay:impl1', 'decay:impl1'),
              (' Making a solver function ', 2, 'decay:py1', 'decay:py1'),
              (' Function for computing the numerical solution ',
               3,
               None,
               '___sec18'),
              (' Integer division ', 3, None, '___sec19'),
              (' Doc strings ', 3, None, '___sec20'),
              (' Formatting of numbers ', 3, None, '___sec21'),
              (' Running the program ', 3, None, '___sec22'),
              (' Plotting the solution ', 3, None, '___sec23'),
              (' Verifying the implementation ', 2, None, '___sec24'),
              (' Running a few algorithmic steps by hand ',
               3,
               None,
               '___sec25'),
              (' Computing the numerical error as a mesh function ',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              (' Computing the norm of the numerical error ',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              (' Scalar computing ', 3, None, '___sec28'),
              (' Experiments with computing and plotting ',
               2,
               None,
               '___sec29'),
              (' Combining plot files ', 3, None, '___sec30'),
              (' Plotting with SciTools ', 3, None, '___sec31'),
              (' Memory-saving implementation ', 2, None, '___sec32'),
              (' Exercises ', 1, None, '___sec33'),
              (' Exercise 1: Differentiate a function ',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              (' Exercise 2: Experiment with integer division ',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              (' Exercise 3: Experiment with wrong computations ',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              (' Exercise 4: Plot the error function ',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              (' Exercise 5: Change formatting of numbers and debug ',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              (' Analysis of finite difference equations ',
               1,
               'decay:analysis',
               'decay:analysis'),
              (' Experimental investigation of oscillatory solutions ',
               2,
               None,
               '___sec40'),
              (' Exact numerical solution ', 2, None, '___sec41'),
              (' Stability ', 2, None, '___sec42'),
              (' Comparing amplification factors ', 2, None, '___sec43'),
              (' Series expansion of amplification factors ',
               2,
               None,
               '___sec44'),
              (' The fraction of numerical and exact amplification factors ',
               2,
               None,
               '___sec45'),
              (' The global error at a point ',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              (' Integrated errors ', 2, None, '___sec47'),
              (' Truncation error ', 2, None, '___sec48'),
              (' Consistency, stability, and convergence ',
               2,
               None,
               '___sec49'),
              (' Exercises ', 1, None, '___sec50'),
              (' Exercise 6: Visualize the accuracy of finite differences ',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              (' Exercise 7: Explore the $\\theta$-rule for exponential growth ',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              (' Model extensions ', 1, None, '___sec53'),
              (' Generalization: including a variable coefficient ',
               2,
               None,
               '___sec54'),
              (' Generalization: including a source term ',
               2,
               'decay:source',
               'decay:source'),
              (' Schemes ', 3, None, '___sec56'),
              (' Implementation of the generalized model problem ',
               2,
               'decay:general',
               'decay:general'),
              (' Deriving the $\\theta$-rule formula ', 3, None, '___sec58'),
              (' The Python code ', 3, None, '___sec59'),
              (' Coding of variable coefficients ', 3, None, '___sec60'),
              (' Verifying a constant solution ',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              (' Verification via manufactured solutions ',
               2,
               'decay:MMS',
               'decay:MMS'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec64'),
              (' Implementation ', 3, None, '___sec65'),
              (' Extension to systems of ODEs ', 2, None, '___sec66'),
              (' General first-order ODEs ', 1, None, '___sec67'),
              (' Generic form of first-order ODEs ', 2, None, '___sec68'),
              (' The $\\theta$-rule ', 2, None, '___sec69'),
              (' An implicit 2-step backward scheme ', 2, None, '___sec70'),
              (' Leapfrog schemes ', 2, None, '___sec71'),
              (' The ordinary Leapfrog scheme ', 3, None, '___sec72'),
              (' The filtered Leapfrog scheme ', 3, None, '___sec73'),
              (' The 2nd-order Runge-Kutta method ', 2, None, '___sec74'),
              (' A 2nd-order Taylor-series method ', 2, None, '___sec75'),
              (' The 2nd- and 3rd-order Adams-Bashforth schemes ',
               2,
               None,
               '___sec76'),
              (' The 4th-order Runge-Kutta method ',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              (' The Odespy software ', 2, None, '___sec78'),
              (' Example: Runge-Kutta methods  ', 2, None, '___sec79'),
              (' Remark about using the $\\theta$-rule in Odespy ',
               3,
               None,
               '___sec80'),
              (' Example: Adaptive Runge-Kutta methods  ',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              (' Exercises ', 1, None, '___sec82'),
              (' Exercise 8: Experiment with precision in tests and the size of $u$ ',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              (' Exercise 9: Implement the 2-step backward scheme ',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              (' Exercise 10: Implement the 2nd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              (' Exercise 11: Implement the 3rd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              (' Exercise 12: Analyze explicit 2nd-order methods ',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              (' Problem 13: Implement and investigate the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              (' Problem 14: Make a unified implementation of many schemes ',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              (' Applications of exponential decay models ',
               1,
               'decay:app',
               'decay:app'),
              (' Scaling ', 2, 'decay:app:scaling', 'decay:app:scaling'),
              (' Evolution of a population ',
               2,
               'decay:app:pop',
               'decay:app:pop'),
              (' Compound interest and inflation ',
               2,
               'decay:app:interest',
               'decay:app:interest'),
              (' Radioactive decay ',
               2,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              (' Deterministic model ', 3, None, '___sec95'),
              (' Stochastic model ', 3, None, '___sec96'),
              (' Relation between stochastic and deterministic models ',
               3,
               None,
               '___sec97'),
              (" Newton's law of cooling ",
               2,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              (' Decay of atmospheric pressure with altitude ',
               2,
               'decay:app:atm',
               'decay:app:atm'),
              (' Multiple atmospheric layers ', 3, None, '___sec100'),
              (' Simplification: $L=0$ ', 3, None, '___sec101'),
              (' Simplification: one-layer model ', 3, None, '___sec102'),
              (' Compaction of sediments ',
               2,
               'decay:app:sediment',
               'decay:app:sediment'),
              (' Vertical motion of a body in a viscous fluid ',
               2,
               'decay:app:drag',
               'decay:app:drag'),
              (' Overview of forces ', 3, None, '___sec105'),
              (' Equation of motion ', 3, None, '___sec106'),
              (' Terminal velocity ', 3, None, '___sec107'),
              (' A Crank-Nicolson scheme ', 3, None, '___sec108'),
              (' Physical data ', 3, None, '___sec109'),
              (' Verification ', 3, None, '___sec110'),
              (' Scaling ', 3, None, '___sec111'),
              (' Decay ODEs from solving a PDE by Fourier expansions ',
               2,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              (' Exercises ', 1, None, '___sec113'),
              (" Exercise 15: Derive schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              (" Exercise 16: Implement schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              (' Exercise 17: Find time of murder from body temperature ',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              (' Exercise 18: Simulate an oscillating cooling process ',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              (' Exercise 19: Radioactive decay of Carbon-14 ',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              (' Exercise 20: Simulate stochastic radioactive decay ',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              (' Exercise 21: Radioactive decay of two substances ',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              (' Exercise 22: Simulate the pressure drop in the atmosphere ',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              (' Exercise 23: Make a program for vertical motion in a fluid ',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              (' Project 24: Simulate parachuting ',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              (' Exercise 25: Formulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              (' Exercise 26: Simulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              (' Exercise 27: Compute $y=|x|$ by solving an ODE ',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              (' Exercise 28: Simulate growth of a fortune with random interest rate ',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              (' Exercise 29: Simulate a population in a changing environment ',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              (' Exercise 30: Simulate logistic growth ',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              (' Exercise 31: Rederive the equation for continuous compound interest ',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              (' Summarizing multiple-choice questions ',
               1,
               None,
               '___sec131'),
              (' Exercise 32: Characterize a finite difference ',
               2,
               'decay:quiz:fd:FE',
               'decay:quiz:fd:FE'),
              (' Exercise 33: Characterize a finite difference ',
               2,
               'decay:quiz:fd:CN',
               'decay:quiz:fd:CN'),
              (' Exercise 34: The $\\theta$ rule ',
               2,
               'decay:quiz:thetarule',
               'decay:quiz:thetarule'),
              (' Exercise 35: What is the problem with this program? ',
               2,
               'decay:quiz:program',
               'decay:quiz:program'),
              (' Exercise 36: Is the solution correct? ',
               2,
               'decay:quiz:stability',
               'decay:quiz:stability'),
              (' Exercise 37: Is this a proper test function? ',
               2,
               'decay:quiz:testfunc',
               'decay:quiz:testfunc'),
              (' Exercise 38: Recognize a programming language ',
               2,
               'decay:quiz:prog:m',
               'decay:quiz:prog:m'),
              (' Exercise 39: Recognize a programming language ',
               2,
               'decay:quiz:prog:py',
               'decay:quiz:prog:py'),
              (' Exercise 40: Recognize a programming language ',
               2,
               'decay:quiz:prog:f77',
               'decay:quiz:prog:f77'),
              (' Exercise 41: Recognize a programming language ',
               2,
               'decay:quiz:prog:c',
               'decay:quiz:prog:c'),
              (' Exercise 42: What is SymPy? ',
               2,
               'decay:quiz:sympy1',
               'decay:quiz:sympy1'),
              (' Exercise 43: What kind of scheme is this? ',
               2,
               'decay:quiz:scheme:BE',
               'decay:quiz:scheme:BE'),
              (' Exercise 44: What kind of scheme is this? ',
               2,
               'decay:quiz:scheme:leapfrog',
               'decay:quiz:scheme:leapfrog'),
              (' Bibliography ', 1, None, '___sec145')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<a name="part0007"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec131">Summarizing multiple-choice questions </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:fd:FE">Exercise 32: Characterize a finite difference</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> We can approximate the derivative at a point using two function values:

<p>
<center><p><img src="fig-decay/fd_forward.png" align="bottom" width=400></p></center>

<p>
What is this type of difference called and how large is the error?</p>

<p><div title="Wrong! No, a centered difference would have the two function values equally displaced to either side of the target point \( t_n \)."><b>Choice A:</b>
This is a centered difference with error proportional to \( \Delta t^2 \).
</div></p>

<p><div title="Right! The name is forward difference, or Forward Euler difference in the context of differential equations. In such contexts the formula is also known as Euler's method or formula."><b>Choice B:</b>
This is a forward difference with error proportional to \( \Delta t \).
</div></p>

<p><div title="Wrong! One may well call this a Forward Euler difference, but the error is not as &quot;good&quot; as \( \Delta t^3 \)."><b>Choice C:</b>
This is a Forward Euler difference with error proportional to \( \Delta t^3 \).
</div></p>

<p><div title="Wrong! Since we use the points \( t_{n+1} \) and \( t_n \) when constructing the difference, we go  forward  in time, not backward. Therefore, this is a forward difference."><b>Choice D:</b>
This is a Backward Euler finite difference with error proportional to \( \Delta t \).
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:fd:CN">Exercise 33: Characterize a finite difference</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> We can approximate the derivative at a point using two function values:

<p>
<center><p><img src="fig-decay/fd_centered_CN.png" align="bottom" width=400></p></center>

<p>
What is this type of difference called and how large is the error?</p>

<p><div title="Right! "><b>Choice A:</b>
This is a centered difference with error proportional to \( \Delta t^2 \).
</div></p>

<p><div title="Wrong! A forward difference makes use of the point itself, \( t_n \), and a point  forward  in time, \( t_{n+1} \). This is not the case here: we use points to the left and right, and the derivative is approximated in the center point. Also, a forward difference would not have an error \( \mathcal{O}(\Delta t^2) \)."><b>Choice B:</b>
This is a forward difference with error proportional to \( \Delta t^2 \).
</div></p>

<p><div title="Wrong! It is centered, but the error is only \( \mathcal{O}(\Delta t^2) \)."><b>Choice C:</b>
This is a centered difference with error proportional to \( \Delta t^4 \).
</div></p>

<p><div title="Wrong! Since we use the points \( t_{n+1} \) and \( t_n \) when constructing the difference at \( t_{n+1/2} \), the derivative is in the  center  of the two points, and the difference is therefore a  centered  difference. A backward difference, or Backward Euler difference, would use \( t_{n+1/2} \) in this case and some point \( t_{n-1/2} \)  backward  in time."><b>Choice D:</b>
This is a Backward Euler finite difference with error proportional to \( \Delta t \).
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:thetarule">Exercise 34: The \( \theta \) rule</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> Why is the \( \theta \)-rule a convenient method? For example, \( u'=-au \) can
be solved by

$$ \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n}) $$</p>

<p><div title="Wrong! This is true, but only if \( \theta =1/2 \). Otherwise, it has the same accuracy as the Forward and Backward Euler schemes."><b>Choice A:</b>
It is more accurate than the Forward Euler and Backward Euler schemes.
</div></p>

<p><div title="Wrong! The formula has slightly more complexity than the Forward and Backward Euler schemes, but cannot be said to be easier to implement - all of them are very simple formulas to program."><b>Choice B:</b>
It is easier to implement than, e.g., the Forward and Backward Euler schemes.
</div></p>

<p><div title="Right! Yes, this is the advantage."><b>Choice C:</b>
It offers the Forward and Backward Euler schemes, the Crank-Nicolson scheme, and more variants in a single formula.
</div></p>

<p><div title="Wrong! True, but that is true for almost all other finite difference schemes too."><b>Choice D:</b>
It can be used for other equations than \( u'=-au \).
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:program">Exercise 35: What is the problem with this program?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> We want to solve

$$ u ' = -au, \quad u(0)=1, $$

by a Forward Euler scheme,

$$ u^{n+1} = u^n - a\Delta t\, u^n,$$

and the following program

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
u = zeros(<span style="color: #B452CD">10</span>)
u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1</span>
dt = <span style="color: #B452CD">0.1</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">10</span>):
    u[i+<span style="color: #B452CD">1</span>] = u[i] - dt*a*u[n]
</pre></div>
<p>
What is the major problem with this program?</p>

<p><div title="Wrong! True, these are recommended rules, but it is not a problem to do the &quot;star import&quot;: it is legal and convenient."><b>Choice A:</b>
<code>from numpy import *</code> is not recommended; one should import explicitly the functions needed or do <code>import numpy as np</code>.
</div></p>

<p><div title="Right! True,  a  is not defined. This is the only reason why one cannot execute the program."><b>Choice B:</b>
The program aborts with a <code>NameError</code>.
</div></p>

<p><div title="Wrong! That is definitely a good idea, but it is not a major problem for computing the solution of the differential equation."><b>Choice C:</b>
The program is &quot;flat&quot;. It should be wrapped in a function <code>solver(U0, dt, N, a)</code>.
</div></p>

<p><div title="Wrong! Actually, this can be true. Since  a  is not defined, it may happen that  dt=0.1  is a too long time step for the stability restrictions of the Forward Euler method for this differential equation. We need \( \Delta t\leq 1/a \). However, the answer is wrong in the sense that this  potential  instability is not the major problem with the program - it is a bigger problem that  a  is not defined."><b>Choice D:</b>
The scheme is unstable!
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:stability">Exercise 36: Is the solution correct?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> You have solved \( u'=-au \) by the Crank-Nicolson scheme and tested
your program thoroughly. Suddenly you run the program with \( I=1 \), \( a=10 \), \( T=1 \), and \( \Delta t=0.225 \). You get somewhat unexpected results:

<p>
<center><p><img src="fig-decay/CN_osc.png" align="bottom" width=500></p></center>

<p>
The results are unexpected because we know the exact solution should be
monotone and decreasing, while this numerical solution also shows an
increasing stage. What is the problem?</p>

<p><div title="Wrong! No, this computation is in fact correct - numerically."><b>Choice A:</b>
The program is not tested well enough - yet another bug is there.
</div></p>

<p><div title="Wrong! The analytical solution \( u(t)=Ie^{-at} \) covers all possible cases."><b>Choice B:</b>
The numerical solution method is more general than the analytical one,
and this is an example where the solution can increase, but the analytical
solution technique is not capable of dealing with this situation.
</div></p>

<p><div title="Right! True. One needs \( \Delta t \leq 2/a = 0.2 \) in this case to avoid oscillations."><b>Choice C:</b>
The time step is too large and cause an instability in the form of non-physical oscillations.
</div></p>

<p><div title="Wrong! 1: The first part is true if unconditionally stable means that the solution is bounded and decays with time, but one may also argue that oscillations, which are non-physical, are a kind of instability, and these occur if \( \Delta t >2/a \). 2: Round-off errors are  very  small in this problem, compared to the discretization errors, and cannot cause an oscillating solution."><b>Choice D:</b>
The Crank-Nicolson scheme is unconditionally stable and can be used with all time-step sizes, but the problem here is that round-off errors due to a &quot;too large&quot; \( a \) (10, not around 1) accumulate to the effect seen in the plot.
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:testfunc">Exercise 37: Is this a proper test function?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> Suppose we have some function <code>compute</code> that we want to test. We construct
a unit test and implement an associated test function (according to the
rules for test functions in the nose or pytest test frameworks):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_compute</span>(n):
    expected = (n**<span style="color: #B452CD">2</span>)/<span style="color: #B452CD">4.5</span> - <span style="color: #B452CD">1</span>
    computed = compute(n)
    <span style="color: #8B008B; font-weight: bold">assert</span> expected != computed
</pre></div>
<p>
The question is if this test function can be used as is or if improvements
must be implemented.</p>

<p><div title="Wrong! It is true that an &quot;almost equal&quot; type of assert function is appropriate, but there is nothing in the rules that requires use of special assert functions. The requirement is that an  AssertionError  is raised if the test fails. That is done by a plain  assert  as used here."><b>Choice A:</b>
One should use special assert functions from <code>nose.tools</code>, here <code>nose.tools.assert_almost_equal</code>.
</div></p>

<p><div title="Wrong! This depends on what is inside  compute . If it has several branches depending on the value of  n , one must test for a visit to each branch, which requires multiple  n  values, but if it is a formula (the test might indicate so), one value can be sufficient."><b>Choice B:</b>
One cannot test <code>compute(n)</code> for only one <code>n</code> value. Many are required for good evidence that the function works.
</div></p>

<p><div title="Right! The formula for  expected  indicates that this is a real number that is subject to potential round-off errors, so one should use a tolerance:  abs(expected - computed) &lt; 1E-14 . Also, test functions should never take arguments."><b>Choice C:</b>
The test function does not test <code>expected != computed</code> with a tolerance
and the <code>n</code> parameter cannot be an argument.
</div></p>

<p><div title="Wrong! This is always a good idea, but not a requirement."><b>Choice D:</b>
The <code>assert</code> statement also needs a message explaining what is wrong when the test fails.
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:prog:m">Exercise 38: Recognize a programming language</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> What kind of programming language is this?

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">function</span><span style="color: #bbbbbb"> </span>integral =<span style="color: #bbbbbb"> </span><span style="color: #008b45">trapezoidal</span>(f, a, b, n)<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span><span style="color: #228B22">%% Integrate f from a to b with n intervals</span>
    h = (b-a)/n;
    result = <span style="color: #B452CD">0.5</span>*f(a) + <span style="color: #B452CD">0.5</span>*f(b);
    <span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">i</span> = <span style="color: #B452CD">1</span>:(n-<span style="color: #B452CD">1</span>)
        result = result + f(a + <span style="color: #658b00">i</span>*h);
    <span style="color: #8B008B; font-weight: bold">end</span>
    integral = h*result;
<span style="color: #8B008B; font-weight: bold">end</span>
</pre></div>
<p></p>

<p><div title="Wrong! "><b>Choice A:</b>
Python
</div></p>

<p><div title="Right! "><b>Choice B:</b>
MATLAB or Octave
</div></p>

<p><div title="Wrong! "><b>Choice C:</b>
Cython
</div></p>

<p><div title="Wrong! "><b>Choice D:</b>
FORTRAN 77
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:prog:py">Exercise 39: Recognize a programming language</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> What kind of programming language is this?

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">def trapezoidal(f, a, b, n):
    # Integrate f from a to b with n intervals
    h = (b-a)/float(n)
    result = <span style="color: #B452CD">0.5</span>*f(a) + <span style="color: #B452CD">0.5</span>*f(b)
    <span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">i</span> in range(<span style="color: #B452CD">1</span>, n):
        result += f(a + <span style="color: #658b00">i</span>*h)
    <span style="color: #8B008B; font-weight: bold">return</span> h*result
</pre></div>
<p></p>

<p><div title="Right! "><b>Choice A:</b>
Python
</div></p>

<p><div title="Wrong! "><b>Choice B:</b>
MATLAB or Octave
</div></p>

<p><div title="Wrong! "><b>Choice C:</b>
Cython
</div></p>

<p><div title="Wrong! "><b>Choice D:</b>
FORTRAN 77
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:prog:f77">Exercise 40: Recognize a programming language</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> What kind of programming language is this?

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> <span style="color: #8B008B; font-weight: bold">function </span>trapezoidal(f, a, b, n)
C     Integrate f from a to b with n intervals
      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> h, <span style="color: #8B008B; font-weight: bold">result</span>, f
      <span style="color: #8B008B; font-weight: bold">external </span>f
      h = (b-a)/n
      <span style="color: #8B008B; font-weight: bold">result</span> = <span style="color: #B452CD">0.5</span>*f(a) + <span style="color: #B452CD">0.5</span>*f(b)
      <span style="color: #8B008B; font-weight: bold">do </span>i = <span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>
        <span style="color: #8B008B; font-weight: bold">result</span> = <span style="color: #8B008B; font-weight: bold">result</span> + f(a + i*h)
      <span style="color: #8B008B; font-weight: bold">end do</span>
<span style="color: #8B008B; font-weight: bold">      </span>trapezoidal = h*<span style="color: #8B008B; font-weight: bold">result</span>
<span style="color: #8B008B; font-weight: bold">      return</span>
<span style="color: #8B008B; font-weight: bold">      end</span>
</pre></div>
<p></p>

<p><div title="Wrong! "><b>Choice A:</b>
Python
</div></p>

<p><div title="Wrong! "><b>Choice B:</b>
MATLAB or Octave
</div></p>

<p><div title="Wrong! "><b>Choice C:</b>
Cython
</div></p>

<p><div title="Right! "><b>Choice D:</b>
FORTRAN 77
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:prog:c">Exercise 41: Recognize a programming language</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> What kind of programming language is this?

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">double trapezoidal(
    double (*f)(double), double a, double b, int n)
{
    double h, result;
    h = (b-a)/n;
    result = <span style="color: #B452CD">0.5</span>*f(a) + <span style="color: #B452CD">0.5</span>*f(b);
    <span style="color: #8B008B; font-weight: bold">for</span> (<span style="color: #658b00">i</span>=<span style="color: #B452CD">1</span>; <span style="color: #658b00">i</span>++; <span style="color: #658b00">i</span> &lt;= n-<span style="color: #B452CD">1</span>) {
        result += f(a + <span style="color: #658b00">i</span>*h);
    }
    <span style="color: #8B008B; font-weight: bold">return</span> h*result;
}
</pre></div>
<p></p>

<p><div title="Right! "><b>Choice A:</b>
C
</div></p>

<p><div title="Wrong! "><b>Choice B:</b>
C++
</div></p>

<p><div title="Wrong! "><b>Choice C:</b>
Cython
</div></p>

<p><div title="Wrong! "><b>Choice D:</b>
Octave dialect
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:sympy1">Exercise 42: What is SymPy?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> What is SymPy?</p>

<p><div title="Wrong! SymPy can compute with symmetric matrices, so that is true, but it can do very much more."><b>Choice A:</b>
A Python module for computing with symmetric matrices.
</div></p>

<p><div title="Right! "><b>Choice B:</b>
A Python package for doing symbolic computations (exact/analytical differentiation, integration, equation solves, etc.).
</div></p>

<p><div title="Wrong! It's the opposite: analytical, not numerical."><b>Choice C:</b>
A Python package for numerical approximations to differentiation, integration, equation solving, etc.
</div></p>

<p><div title="Wrong! Could be viewed as such, but Mathematica is a much more advanced tool for symbolic computing."><b>Choice D:</b>
A free, open source version of Mathematica.
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:scheme:BE">Exercise 43: What kind of scheme is this?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> We want to solve \( y'=g(x, y) \) for \( y(x) \) and have the scheme

$$ y^{i+1} = y^i + \Delta t\, g(x_{i+1}, y^{i+1})\tp$$

<p>
What is this scheme called?</p>

<p><div title="Wrong! There is no midpoint \( i+1/2 \) involved here."><b>Choice A:</b>
The implicit midpoint scheme.
</div></p>

<p><div title="Right! "><b>Choice B:</b>
The Backward Euler scheme or just the backward scheme.
</div></p>

<p><div title="Wrong! This is true if we had \( g(x_i, y^{i}) \)."><b>Choice C:</b>
The Forward Euler scheme, Euler's method, or just the forward scheme.
</div></p>

<p><div title="Wrong! "><b>Choice D:</b>
The implicit Adams scheme of order one.
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:quiz:scheme:leapfrog">Exercise 44: What kind of scheme is this?</h2>

<p>
<!-- --- previous heading type: exercise -->
<!-- begin quiz -->
<hr>
<p>
<b>Question:</b> We want to solve \( y'=g(x, y) \) for \( y(x) \) and have the scheme

$$ y^{i+1} = y^{i-1} + 2\Delta t\, g(x_{i}, y^{i})\tp$$

<p>
What is this scheme called?</p>

<p><div title="Wrong! It is a midpoint scheme, but it is explicit rather than implicit."><b>Choice A:</b>
The implicit midpoint scheme.
</div></p>

<p><div title="Wrong! "><b>Choice B:</b>
The two-step backward scheme.
</div></p>

<p><div title="Wrong! No, that looks quite different and is based on a centered difference over \( [x_i,x_{i+1}] \), not \( x_{i-1},x_{i+1}] \)."><b>Choice C:</b>
The Crank-Nicolson scheme.
</div></p>

<p><div title="Right! "><b>Choice D:</b>
The leapfrog scheme.
</div></p>
<hr>
<!-- end quiz -->


<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._decay-solarized006.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._decay-solarized008.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    
