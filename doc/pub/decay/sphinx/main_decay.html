

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction to computing with finite difference methods</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to computing with finite difference methods" href="index.html" />
    <link rel="prev" title="Introduction to computing with finite difference methods" href="index.html" />
 
  
   <style type="text/css">
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Introduction to computing with finite difference methods"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="introduction-to-computing-with-finite-difference-methods">
<h1>Introduction to computing with finite difference methods<a class="headerlink" href="#introduction-to-computing-with-finite-difference-methods" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Aug 21, 2014</td>
</tr>
</tbody>
</table>
<p>Finite difference methods for partial differential equations (PDEs)
employ a range of concepts and tools that can be introduced and
illustrated in the context of simple ordinary differential equation
(ODE) examples.  This is what we do in the present document.  By
first working with ODEs, we keep the mathematical problems to be
solved as simple as possible (but no simpler), thereby allowing full
focus on understanding the key concepts and tools.  The choice of
topics in the forthcoming treatment of ODEs is therefore solely
dominated by what carries over to numerical methods for PDEs.</p>
<p>Theory and practice are primarily illustrated by solving the
very simple ODE <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>, where <span class="math">\(a&gt;0\)</span> is a constant,
but we also address the generalized problem <span class="math">\(u'=-a(t)u + b(t)\)</span>
and the nonlinear problem <span class="math">\(u'=f(u,t)\)</span>.
The following topics are introduced:</p>
<blockquote>
<div><ul class="simple">
<li>How to think when constructing finite difference methods, with special focus
on the Forward Euler, Backward Euler, and Crank-Nicolson (midpoint)
schemes</li>
<li>How to formulate a computational algorithm and translate it into
Python code</li>
<li>How to make curve plots of the solutions</li>
<li>How to compute numerical errors</li>
<li>How to compute convergence rates</li>
<li>How to verify an implementation and automate verification
through nose tests in Python</li>
<li>How to structure code in terms of functions, classes, and modules</li>
<li>How to work with Python concepts such as arrays, lists, dictionaries,
lambda functions, functions in functions (closures), doctests,
unit tests, command-line interfaces, graphical user interfaces</li>
<li>How to perform array computing and understand the difference from
scalar computing</li>
<li>How to conduct and automate large-scale numerical experiments</li>
<li>How to generate scientific reports</li>
<li>How to uncover numerical artifacts in the computed solution</li>
<li>How to analyze the numerical schemes mathematically to understand
why artifacts occur</li>
<li>How to derive mathematical expressions for various measures of
the error in numerical methods, frequently by using the <tt class="docutils literal"><span class="pre">sympy</span></tt> software
for symbolic computation</li>
<li>Introduce concepts such as finite difference operators,
mesh (grid), mesh functions,
stability, truncation error, consistency, and convergence</li>
<li>Present additional methods for the general nonlinear ODE <span class="math">\(u'=f(u,t)\)</span>,
which is either a scalar ODE or a system of ODEs</li>
<li>How to access professional packages for solving ODEs</li>
<li>How the model equation <span class="math">\(u'=-au\)</span> arises in a wide range
of phenomena in physics, biology, and finance</li>
</ul>
</div></blockquote>
<div class="admonition-the-exposition-in-a-nutshell admonition">
<p class="first admonition-title">The exposition in a nutshell</p>
<p>Everything we cover is put into a practical, hands-on context. All
mathematics is translated into working computing codes, and all the
mathematical theory of finite difference methods presented here is
motivated from a strong need to understand strange behavior of programs.
Two fundamental questions saturate the text:</p>
<blockquote class="last">
<div><ul class="simple">
<li>How to we solve a differential equation problem and produce numbers?</li>
<li>How to we trust the answer?</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="finite-difference-methods">
<span id="decay-basics"></span><h2>Finite difference methods<a class="headerlink" href="#finite-difference-methods" title="Permalink to this headline">¶</a></h2>
<div class="admonition-goal admonition">
<p class="first admonition-title">Goal</p>
<p class="last">We explain the basic ideas of finite difference methods
using a simple ordinary differential equation <span class="math">\(u'=-au\)</span> as
primary example.
Emphasis is put on the reasoning when discretizing the problem and
introduction of key concepts such as mesh, mesh function,
finite difference approximations, averaging in a mesh,
derivation of algorithms, and discrete operator notation.</p>
</div>
<div class="section" id="a-basic-model-for-exponential-decay">
<span id="decay-model"></span><h3>A basic model for exponential decay<a class="headerlink" href="#a-basic-model-for-exponential-decay" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><p id="index-1">Our model problem is perhaps the simplest ordinary differential
equation (ODE):</p>
<div class="math">
\[u'(t) = -au(t),\]</div>
<p>Here, <span class="math">\(a&gt;0\)</span> is a constant and <span class="math">\(u'(t)\)</span> means differentiation with
respect to time <span class="math">\(t\)</span>. This type of equation arises in a number of
widely different phenomena where some quantity <span class="math">\(u\)</span> undergoes
exponential reduction. Examples include radioactive decay, population
decay, investment decay, cooling of an object, pressure decay in the
atmosphere, and retarded motion in fluids (for some of these models,
<span class="math">\(a\)</span> can be negative as well), see the section <a class="reference internal" href="#decay-app"><em>Applications of exponential decay models</em></a> for details
and motivation.  We have chosen this particular ODE not only because
its applications are relevant, but even more because studying
numerical solution methods for this simple ODE gives important insight
that can be reused in much more complicated settings, in particular
when solving diffusion-type partial differential equations.</p>
<p>The analytical solution of the ODE is found by the method of
separation of variables, which results in</p>
<div class="math">
\[u(t) = Ce^{-at},\]</div>
<p>for any arbitrary constant <span class="math">\(C\)</span>.
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of <span class="math">\(C\)</span>.
This condition is known as the <em>initial condition</em> and stated as
<span class="math">\(u(0)=I\)</span>. That is, we know the
value <span class="math">\(I\)</span> of <span class="math">\(u\)</span> when the process starts at <span class="math">\(t=0\)</span>. The exact solution
is then <span class="math">\(u(t)=Ie^{-at}\)</span>.</p>
<p>We seek the solution <span class="math">\(u(t)\)</span> of the ODE for <span class="math">\(t\in (0,T]\)</span>. The point <span class="math">\(t=0\)</span> is not
included since we know <span class="math">\(u\)</span> here and assume that the equation governs
<span class="math">\(u\)</span> for <span class="math">\(t&gt;0\)</span>. The complete ODE problem then reads: find <span class="math">\(u(t)\)</span>
such that</p>
<div class="math" id="equation-decay:problem">
<span class="eqno">(1)</span>\[     u' = -au,\ t\in (0,T], \quad u(0)=I{\thinspace .}\]</div>
<p>This is known as a <em>continuous problem</em> because the parameter <span class="math">\(t\)</span>
varies continuously from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>. For each <span class="math">\(t\)</span> we have a corresponding
<span class="math">\(u(t)\)</span>. There are hence infinitely many values of <span class="math">\(t\)</span> and <span class="math">\(u(t)\)</span>.
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.</p>
</div>
<div class="section" id="the-forward-euler-scheme">
<span id="decay-schemes-fe"></span><h3>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>Solving an ODE like <a href="#equation-decay:problem">(1)</a> by a finite difference method
consists of the following four steps:</p>
<ol class="arabic simple">
<li>discretizing the domain,</li>
<li>fulfilling the equation at discrete time points,</li>
<li>replacing derivatives by finite differences,</li>
<li>formulating a recursive algorithm.</li>
</ol>
<span class="target" id="index-2"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-3"></span><h4>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h4>
<p>The time domain <span class="math">\([0,T]\)</span> is represented by a finite number of
<span class="math">\(N_t+1\)</span> points</p>
<div class="math">
\[\begin{split}0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T{\thinspace .}\end{split}\]</div>
<p>The collection of points <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span> constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain <span class="math">\([0,T]\)</span>, which means that the spacing <span class="math">\(t_{n+1}-t_n\)</span> is
the same for all <span class="math">\(n\)</span>. This spacing is often denoted by <span class="math">\(\Delta t\)</span>,
in this case <span class="math">\(t_n=n\Delta t\)</span>.</p>
<p id="index-4">We seek the solution <span class="math">\(u\)</span> at the mesh points:
<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>. Note that <span class="math">\(u^0\)</span> is already known as <span class="math">\(I\)</span>.
A notational short-form for <span class="math">\(u(t_n)\)</span>,
which will be used extensively, is <span class="math">\(u^{n}\)</span>. More precisely, we let
<span class="math">\(u^n\)</span> be the <em>numerical approximation</em> to the exact solution <span class="math">\(u(t_n)\)</span>
at <span class="math">\(t=t_n\)</span>. The numerical approximation is a <em>mesh function</em>,
here defined only at the mesh points.
When we need to clearly distinguish between the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in <span class="math">\({u_{\small\mbox{e}}}(t_n)\)</span>. Figure <a class="reference internal" href="#decay-fdu-e"><em>Time mesh with discrete solution values</em></a> shows the
<span class="math">\(t_n\)</span> and <span class="math">\(u_n\)</span> points for <span class="math">\(n=0,1,\ldots,N_t=7\)</span> as well as <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>
as the dashed line. The goal of a numerical method for ODEs is
to compute the mesh function by solving a finite set of
<em>algebraic equations</em> derived from the original ODE problem.</p>
<div class="figure" id="decay-fdu-e">
<a class="reference internal image-reference" href="_images/fdm_u_ue.png"><img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 600px;" /></a>
<p class="caption"><em>Time mesh with discrete solution values</em></p>
</div>
<p>Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of <span class="math">\(u\)</span> between mesh points. The simplest
(and most widely used) interpolation method is to assume that
<span class="math">\(u\)</span> varies linearly between the mesh points, see
Figure <a class="reference internal" href="#decay-fdu-ei"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></a>. Given <span class="math">\(u^{n}\)</span>
and <span class="math">\(u^{n+1}\)</span>, the value of <span class="math">\(u\)</span> at some <span class="math">\(t\in [t_{n}, t_{n+1}]\)</span>
is by linear interpolation</p>
<div class="math">
\[u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n){\thinspace .}\]</div>
<div class="figure" id="decay-fdu-ei">
<a class="reference internal image-reference" href="_images/fdm_u_ui.png"><img alt="_images/fdm_u_ui.png" src="_images/fdm_u_ui.png" style="width: 600px;" /></a>
<p class="caption"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></p>
</div>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h4>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h4>
<p>The ODE is supposed to hold for all <span class="math">\(t\in (0,T]\)</span>, i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span> are a natural
(but not the only) choice of points.
The original ODE is then reduced to  the following <span class="math">\(N_t\)</span> equations:</p>
<div class="math" id="equation-decay:step2">
<span class="eqno">(2)</span>\[     u'(t_n) = -au(t_n),\quad n=0,\ldots,N_t{\thinspace .}\]</div>
</div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-5"></span><h4>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h4>
<p>The next and most essential step of the method is to replace the
derivative <span class="math">\(u'\)</span> by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a class="reference internal" href="#decay-sketch-fe"><em>Illustration of a forward difference</em></a>),</p>
<span class="target" id="index-6"></span><div class="math" id="equation-decay:FEdiff">
<span id="index-7"></span><span class="eqno">(3)</span>\[     u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}{\thinspace .}\]</div>
<p>Inserting this approximation in <a href="#equation-decay:step2">(2)</a> results in</p>
<div class="math" id="equation-decay:step3">
<span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1{\thinspace .}\]</div>
<p>Later it will be absolutely clear that if we want to compute the solution
up to time level <span class="math">\(N_t\)</span>,
we only need <a href="#equation-decay:step2">(2)</a> to hold for <span class="math">\(n=0,\ldots,N_t-1\)</span> since
<a href="#equation-decay:step3">(4)</a> for <span class="math">\(n=N_t-1\)</span> creates an equation for the final
value <span class="math">\(u^{N_t}\)</span>.</p>
<p>Equation <a href="#equation-decay:step3">(4)</a>
is the discrete counterpart to the original ODE problem
<a href="#equation-decay:problem">(1)</a>, and often referred to as <em>finite difference scheme</em>
or more generally as the <em>discrete equations</em> of the problem.
The fundamental feature of these equations is that they are <em>algebraic</em>
and can hence be straightforwardly solved to produce the mesh function, i.e.,
the values of <span class="math">\(u\)</span> at
the mesh points (<span class="math">\(u^n\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>).</p>
<div class="figure" id="decay-sketch-fe">
<a class="reference internal image-reference" href="_images/fd_forward.png"><img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 400px;" /></a>
<p class="caption"><em>Illustration of a forward difference</em></p>
</div>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span></div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<span id="index-12"></span><h4>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h4>
<p>The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#equation-decay:step3">(4)</a> can be used to compute <span class="math">\(u^{n+1}\)</span> if <span class="math">\(u^n\)</span> is known.
Starting with <span class="math">\(n=0\)</span>, <span class="math">\(u^0\)</span> is known since <span class="math">\(u^0=u(0)=I\)</span>, and
<a href="#equation-decay:step3">(4)</a> gives an equation for <span class="math">\(u^1\)</span>. Knowing <span class="math">\(u^1\)</span>,
<span class="math">\(u^2\)</span> can be found from <a href="#equation-decay:step3">(4)</a>. In general, <span class="math">\(u^n\)</span>
in <a href="#equation-decay:step3">(4)</a> can be assumed known, and then we can easily solve for
the unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:FE">
<span class="eqno">(5)</span>\[     u^{n+1} = u^n - a(t_{n+1} -t_n)u^n{\thinspace .}\]</div>
<p>We shall refer to <a href="#equation-decay:FE">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#equation-decay:FE">(5)</a> are known as
<em>difference equations</em> since they express how differences in
<span class="math">\(u\)</span>, like <span class="math">\(u^{n+1}-u^n\)</span>, evolve with <span class="math">\(n\)</span>.
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.</p>
<p>Computation with <a href="#equation-decay:FE">(5)</a> is straightforward:</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 &amp; = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &amp;= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),\end{split}\]</div>
<p>and so on until we reach <span class="math">\(u^{N_t}\)</span>.
Very often, <span class="math">\(t_{n+1}-t_n\)</span> is constant for all <span class="math">\(n\)</span>, so we can introduce
the common symbol <span class="math">\(\Delta t\)</span> for the time step:
<span class="math">\(\Delta t = t_{n+1}-t_n\)</span>, <span class="math">\(n=0,1,\ldots,N_t-1\)</span>.
Using a constant time step <span class="math">\(\Delta t\)</span> in the above calculations gives</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = I(1-a\Delta t),\\
u_2 &amp; = I(1-a\Delta t)^2,\\
u^3 &amp;= I(1-a\Delta t)^3,\\
&amp;\vdots\\
u^{N_t} &amp;= I(1-a\Delta t)^{N_t}{\thinspace .}\end{split}\]</div>
<p>This means that we have found a closed formula for <span class="math">\(u^n\)</span>, and there is
no need to let a computer generate the sequence <span class="math">\(u^1, u^2, u^3, \ldots\)</span>.
However, finding such a formula for <span class="math">\(u^n\)</span> is possible only for a few very
simple problems, so in general finite difference equations must be
solved on a computer.</p>
<p>As the next sections will show, the scheme <a href="#equation-decay:FE">(5)</a> is just one
out of many alternative finite difference (and other) methods for
the model problem <a href="#equation-decay:problem">(1)</a>.</p>
</div>
</div>
<div class="section" id="the-backward-euler-scheme">
<span id="decay-schemes-be"></span><h3>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-13"></span><p id="index-14">There are several choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is</p>
<div class="math" id="equation-decay:BEdiff">
<span class="eqno">(6)</span>\[     u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}{\thinspace .}\]</div>
<p>Since this difference is based on going backward in time (<span class="math">\(t_{n-1}\)</span>)
for information, it is known as the Backward Euler difference.
Figure <a class="reference internal" href="#decay-sketch-be"><em>Illustration of a backward difference</em></a> explains the idea.</p>
<div class="figure" id="decay-sketch-be">
<a class="reference internal image-reference" href="_images/fd_backward.png"><img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 400px;" /></a>
<p class="caption"><em>Illustration of a backward difference</em></p>
</div>
<span class="target" id="index-15"></span><p id="index-16">Inserting <a href="#equation-decay:BEdiff">(6)</a> in <a href="#equation-decay:step2">(2)</a> yields
the Backward Euler (BE) scheme:</p>
<div class="math" id="equation-decay:BE0">
<span class="eqno">(7)</span>\[     \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n{\thinspace .}\]</div>
<p>We assume, as explained under step 4 in the section <a class="reference internal" href="#decay-schemes-fe"><em>The Forward Euler scheme</em></a>,
that we have computed <span class="math">\(u^0, u^1, \ldots, u^{n-1}\)</span> such that
<a href="#equation-decay:BE0">(7)</a> can be used to compute <span class="math">\(u^n\)</span>.
For direct similarity with the Forward Euler scheme <a href="#equation-decay:FE">(5)</a>
we replace <span class="math">\(n\)</span> by <span class="math">\(n+1\)</span> in <a href="#equation-decay:BE0">(7)</a> and solve for the
unknown value <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:BE">
<span class="eqno">(8)</span>\[     u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n{\thinspace .}\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<span id="decay-schemes-cn"></span><h3>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-17"></span><span class="target" id="index-18"></span><p id="index-19">The finite difference approximations used to derive the schemes
<a href="#equation-decay:FE">(5)</a> and <a href="#equation-decay:BE">(8)</a> are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at <span class="math">\(t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1})\)</span>, or
<span class="math">\(t_{n+1/2}=(n+\frac{1}{2})\Delta t\)</span> if the mesh spacing is uniform in time.
The approximation reads</p>
<div class="math" id="equation-decay:CNdiff">
<span class="eqno">(9)</span>\[     u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}{\thinspace .}\]</div>
<p>Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#equation-decay:FEdiff">(3)</a> and
the Backward Euler approximation <a href="#equation-decay:BEdiff">(6)</a> (with
<span class="math">\(n\)</span> replaced by <span class="math">\(n+1\)</span>). The accuracy of this fraction as an approximation
to the derivative of <span class="math">\(u\)</span> depends on <em>where</em> we seek the derivative:
in the center of the interval <span class="math">\([t_{n},t_{n+1}]\)</span> or at the end points.</p>
<p>With the formula <a href="#equation-decay:CNdiff">(9)</a>, where <span class="math">\(u'\)</span> is evaluated at
<span class="math">\(t_{n+1/2}\)</span>, it is natural to demand the
ODE to be fulfilled at the time points <em>between</em> the mesh points:</p>
<div class="math" id="equation-decay:step2m">
<span class="eqno">(10)</span>\[     u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,
     \ldots,N_t-1{\thinspace .}\]</div>
<p>Using <a href="#equation-decay:CNdiff">(9)</a> in <a href="#equation-decay:step2m">(10)</a> results in</p>
<div class="math" id="equation-decay:CN0">
<span class="eqno">(11)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},\]</div>
<p>where <span class="math">\(u^{n+\frac{1}{2}}\)</span> is a short form for <span class="math">\(u(t_{n+\frac{1}{2}})\)</span>.
The problem is that we aim to compute <span class="math">\(u^n\)</span> for integer <span class="math">\(n\)</span>, implying that
<span class="math">\(u^{n+\frac{1}{2}}\)</span> is not a quantity computed by our method. It must
therefore be
expressed by the quantities that we actually produce, i.e.,
the numerical solution at the
mesh points. One possibility is to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>
as an arithmetic mean of the <span class="math">\(u\)</span> values at the neighboring mesh points:</p>
<div class="math" id="equation-decay:uhalfavg">
<span id="index-20"></span><span class="eqno">(12)</span>\[     u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1}){\thinspace .}\]</div>
<p>Using <a href="#equation-decay:uhalfavg">(12)</a> in <a href="#equation-decay:CN0">(11)</a> results in</p>
<div class="math" id="equation-decay:CN1">
<span class="eqno">(13)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1}){\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#decay-sketch-cn"><em>Illustration of a centered difference</em></a> sketches the geometric interpretation of
such a centered difference.</p>
<div class="figure" id="decay-sketch-cn">
<a class="reference internal image-reference" href="_images/fd_centered_CN.png"><img alt="_images/fd_centered_CN.png" src="_images/fd_centered_CN.png" style="width: 400px;" /></a>
<p class="caption"><em>Illustration of a centered difference</em></p>
</div>
<p>We assume that <span class="math">\(u^n\)</span> is already computed so that <span class="math">\(u^{n+1}\)</span> is the
unknown, which we can solve for:</p>
<div class="math" id="equation-decay:CN">
<span class="eqno">(14)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n{\thinspace .}\]</div>
<p>The finite difference scheme <a href="#equation-decay:CN">(14)</a> is often called
the Crank-Nicolson (CN) scheme or a midpoint or centered scheme.</p>
</div>
<div class="section" id="the-unifying-rule">
<span id="decay-schemes-theta"></span><h3>The unifying <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-unifying-rule" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><p id="index-23">The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter <span class="math">\(\theta\)</span>:</p>
<div class="math" id="equation-decay:th0">
<span class="eqno">(15)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})\]\[     {\thinspace .}\]</div>
<p>Observe:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\theta =0\)</span> gives the Forward Euler scheme</li>
<li><span class="math">\(\theta =1\)</span> gives the Backward Euler scheme, and</li>
<li><span class="math">\(\theta =\frac{1}{2}\)</span> gives the Crank-Nicolson scheme.</li>
<li>We may alternatively choose any other value of <span class="math">\(\theta\)</span> in <span class="math">\([0,1]\)</span>.</li>
</ul>
</div></blockquote>
<p>As before, <span class="math">\(u^n\)</span> is considered known and <span class="math">\(u^{n+1}\)</span> unknown, so
we solve for the latter:</p>
<div class="math" id="equation-decay:th">
<span class="eqno">(16)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}{\thinspace .}\]</div>
<p>This scheme is known as the <span class="math">\(\theta\)</span>-rule, or alternatively written as
the &#8220;theta-rule&#8221;.</p>
<div class="admonition-derivation admonition">
<p class="first admonition-title">Derivation</p>
<p>We start with replacing <span class="math">\(u'\)</span> by the fraction</p>
<div class="math">
\[\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\]</div>
<p>in the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. Then we observe that
the difference between the methods concerns which point this
fraction approximates the derivative. Or in other words, at which point we
sample the ODE. So far this has been the
end points or the midpoint of <span class="math">\([t_n,t_{n+1}]\)</span>. However, we may choose any point
<span class="math">\(\tilde t \in [t_n,t_{n+1}]\)</span>.
The difficulty
is that evaluating the right-hand side <span class="math">\(-au\)</span> at an arbitrary point
faces the same problem as in
the section <a class="reference internal" href="#decay-schemes-cn"><em>The Crank-Nicolson scheme</em></a>: the point value must be expressed
by the discrete <span class="math">\(u\)</span> quantities that we compute by the scheme, i.e.,
<span class="math">\(u^n\)</span> and <span class="math">\(u^{n+1}\)</span>. Following the averaging idea from
the section <a class="reference internal" href="#decay-schemes-cn"><em>The Crank-Nicolson scheme</em></a>,
the value of <span class="math">\(u\)</span> at an arbitrary point <span class="math">\(\tilde t\)</span> can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic mean
<span class="math">\(\frac{1}{2} u^n + {\frac{1}{2}}u^{n+1}\)</span>.
If we express <span class="math">\(\tilde t\)</span> as a weighted average</p>
<div class="math">
\[t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span> is the weighting factor, we can write</p>
<div class="math" id="equation-decay:thetaavg">
<span class="eqno">(17)</span>\[     u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
     \theta u^{n+1} + (1-\theta) u^{n}{\thinspace .}\]</div>
<p class="last">We can now let the ODE hold at the point
<span class="math">\(\tilde t\in [t_n,t_{n+1}]\)</span>, approximate <span class="math">\(u'\)</span> by the fraction
<span class="math">\((u^{n+1}-u^{n})/(t_{n+1}-t_n)\)</span>, and approximate the right-hand
side <span class="math">\(-au\)</span> by the weighted average <a href="#equation-decay:thetaavg">(17)</a>.
The result is <a href="#equation-decay:th0">(15)</a>.</p>
</div>
</div>
<div class="section" id="constant-time-step">
<h3>Constant time step<a class="headerlink" href="#constant-time-step" title="Permalink to this headline">¶</a></h3>
<p>All schemes up to now have been formulated for a general non-uniform
mesh in time: <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>. Non-uniform meshes are highly relevant
since one can use many points in regions where <span class="math">\(u\)</span> varies rapidly, and
save points in regions where <span class="math">\(u\)</span> is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.</p>
<p>However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
<span class="math">\(t_n=n\Delta t\)</span>, where <span class="math">\(\Delta t\)</span> is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known.</p>
<div class="admonition-summary-of-schemes-for-constant-time-step admonition">
<p class="first admonition-title">Summary of schemes for constant time step</p>
<div class="math" id="equation-decay:FE:u">
<span class="eqno">(18)</span>\[     u^{n+1} = (1 - a\Delta t )u^n  \quad (\hbox{FE})\]</div>
<div class="math" id="equation-decay:BE:u">
<span class="eqno">(19)</span>\[     u^{n+1} = \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})\]</div>
<div class="math" id="equation-decay:CN:u">
<span class="eqno">(20)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad (\hbox{CN})\]</div>
<div class="last math" id="equation-decay:th:u">
<span class="eqno">(21)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})\]</div>
</div>
<p>Not surprisingly, we present these three alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.</p>
<div class="admonition-test-the-understanding admonition">
<p class="first admonition-title">Test the understanding</p>
<p class="last">At this point it can be good training to apply the explained
finite difference discretization techniques to a slightly
different equation. <a class="reference internal" href="#decay-app-exer-cooling-schemes"><em>Exercise 10: Derive schemes for Newton&#8217;s law of cooling</em></a>
is therefore highly recommended to check that the key concepts
are understood.</p>
</div>
</div>
<div class="section" id="compact-operator-notation-for-finite-differences">
<span id="decay-fd-op"></span><h3>Compact operator notation for finite differences<a class="headerlink" href="#compact-operator-notation-for-finite-differences" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-24"></span><p id="index-25">Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation. A forward difference approximation is denoted
by the <span class="math">\(D_t^+\)</span> operator:</p>
<div class="math" id="equation-fd:D:f">
<span class="eqno">(22)</span>\[     [D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     {\thinspace .}\]</div>
<p>The notation consists of an operator that approximates
differentiation with respect to an independent variable, here <span class="math">\(t\)</span>.
The operator is built of the symbol <span class="math">\(D\)</span>, with the variable as subscript
and a superscript denoting the type of difference. The superscript <span class="math">\(\,{}^+\)</span>
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.</p>
<p>The corresponding operator notation for a centered difference and
a backward difference reads</p>
<div class="math" id="equation-fd:D:c">
<span class="eqno">(23)</span>\[     [D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
     \approx \frac{d}{dt} u(t_n),\]</div>
<p>and</p>
<div class="math" id="equation-fd:D:b">
<span class="eqno">(24)</span>\[     [D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     {\thinspace .}\]</div>
<p>Note that the superscript <span class="math">\(\,{}^-\)</span> denotes the backward
difference, while no superscript implies a central difference.</p>
<p>An averaging operator is also convenient to have:</p>
<div class="math" id="equation-fd:mean:a">
<span class="eqno">(25)</span>\[     [\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
     \approx u(t_n)\]</div>
<p>The superscript <span class="math">\(t\)</span> indicates that the average is taken along the time
coordinate. The common average <span class="math">\((u^n + u^{n+1})/2\)</span> can now be
expressed as <span class="math">\([\overline{u}^{t}]^{n+\frac{1}{2}}\)</span>. (When also spatial coordinates
enter the problem, we need the explicit specification of the coordinate
after the bar.)</p>
<p>The Backward Euler finite difference approximation to <span class="math">\(u'=-au\)</span> can be written
as follows utilizing the compact notation:</p>
<div class="math">
\[[D_t^-u]^n = -au^n {\thinspace .}\]</div>
<p>In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:</p>
<div class="math">
\[[D_t^- u  = -au]^n {\thinspace .}\]</div>
<p>The Forward Euler scheme takes the form</p>
<div class="math">
\[[D_t^+ u  = -au]^n,\]</div>
<p>while the Crank-Nicolson scheme is written as</p>
<div class="math" id="equation-fd:compact:ex:CN">
<span class="eqno">(26)</span>\[     [D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<div class="admonition-question admonition">
<p class="first admonition-title">Question</p>
<p class="last">Apply <a href="#equation-fd:D:c">(23)</a> and <a href="#equation-fd:mean:a">(25)</a> and write out the
expressions to see that <a href="#equation-fd:compact:ex:CN">(26)</a> is indeed the
Crank-Nicolson scheme.</p>
</div>
<p>The <span class="math">\(\theta\)</span>-rule can be specified by</p>
<div class="math" id="equation-decay:fd1:op:theta">
<span class="eqno">(27)</span>\[     [\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},\]</div>
<p>if we define a new time difference</p>
<div class="math" id="equation-decay:fd1:Du:theta">
<span class="eqno">(28)</span>\[     \lbrack\bar D_t u\rbrack^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},\]</div>
<p>and a <em>weighted averaging operator</em></p>
<div class="math" id="equation-decay:fd1:wmean:a">
<span class="eqno">(29)</span>\[     \lbrack\overline{u}^{t,\theta}\rbrack^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
     \approx u(t_{n+\theta}),\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span>. Note that for <span class="math">\(\theta =\frac{1}{2}\)</span> we recover
the standard centered difference and the standard arithmetic mean.
The idea in <a href="#equation-decay:fd1:op:theta">(27)</a> is to sample the equation at
<span class="math">\(t_{n+\theta}\)</span>, use a skew difference at that
point <span class="math">\([\bar D_t u]^{n+\theta}\)</span>, and a skew mean value.
An alternative notation is</p>
<div class="math">
\[[D_t u]^{n+\frac{1}{2}} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}{\thinspace .}\]</div>
<p>Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation effectively communicates the
reasoning behind turning a differential equation into a difference
equation.</p>
</div>
</div>
<div class="section" id="implementation">
<span id="decay-impl1"></span><h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="admonition-goal admonition">
<p class="first admonition-title">Goal</p>
<p>We want make a computer program for solving</p>
<div class="math">
\[u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,\]</div>
<p class="last">by finite difference methods. The program should also display
the numerical solution as a curve on the
screen, preferably together with the
exact solution.</p>
</div>
<span class="target" id="index-26"></span><p id="index-27">All programs referred to in this section are found in the
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay">src/decay</a> directory (we use the classical
Unix term <em>directory</em> for what many others nowadays call <em>folder</em>).</p>
<p><strong>Mathematical problem.</strong>
We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational point of view, it is advantageous to
implement the <span class="math">\(\theta\)</span>-rule</p>
<div class="math">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,\]</div>
<p>since it can generate the three other schemes by various of
choices of <span class="math">\(\theta\)</span>: <span class="math">\(\theta=0\)</span> for Forward Euler, <span class="math">\(\theta =1\)</span> for
Backward Euler, and <span class="math">\(\theta =1/2\)</span> for Crank-Nicolson.
Given <span class="math">\(a\)</span>, <span class="math">\(u^0=I\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(\Delta t\)</span>,
our task is to use the <span class="math">\(\theta\)</span>-rule to
compute <span class="math">\(u^1, u^2,\ldots,u^{N_t}\)</span>, where <span class="math">\(t_{N_t}=N_t\Delta t\)</span>, and
<span class="math">\(N_t\)</span> the closest integer to <span class="math">\(T/\Delta t\)</span>.</p>
<p><strong>Computer Language: Python.</strong>
Any programming language can be used to generate the <span class="math">\(u^{n+1}\)</span> values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:</p>
<blockquote>
<div><ul class="simple">
<li>Python has a very clean, readable syntax (often known as
&#8220;executable pseudo-code&#8221;).</li>
<li>Python code is very similar to MATLAB code (and MATLAB has a
particularly widespread use for scientific computing).</li>
<li>Python is a full-fledged, very powerful programming language.</li>
<li>Python is similar to, but much simpler to work with and
results in more reliable code than C++.</li>
<li>Python has a rich set of modules for scientific computing, and its
popularity in scientific computing is rapidly growing.</li>
<li>Python was made for being combined with compiled languages
(C, C++, Fortran) to reuse existing numerical software and to
reach high computational performance of new implementations.</li>
<li>Python has extensive support for administrative task
needed when doing large-scale computational investigations.</li>
<li>Python has extensive support for graphics (visualization,
user interfaces, web applications).</li>
<li>FEniCS, a very powerful tool for solving PDEs by
the finite element method, is most human-efficient to operate
from Python.</li>
</ul>
</div></blockquote>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the forthcoming examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.</p>
<p>Readers who feel the Python examples are too hard to follow will probably
benefit from reading a tutorial, e.g.,</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://docs.python.org/2/tutorial/">The Official Python Tutorial</a></li>
<li><a class="reference external" href="http://www.tutorialspoint.com/python/">Python Tutorial on tutorialspoint.com</a></li>
<li><a class="reference external" href="http://www.learnpython.org/">Interactive Python tutorial site</a></li>
<li><a class="reference external" href="http://en.wikibooks.org/wiki/A_Beginner's_Python_Tutorial">A Beginner&#8217;s Python Tutorial</a></li>
</ul>
</div></blockquote>
<p>The author also has a comprehensive book <a class="reference internal" href="#ref1" id="id1">[Ref1]</a> that teaches
scientific programming with Python from the ground up.</p>
<div class="section" id="making-a-solver-function">
<span id="decay-py1"></span><h3>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h3>
<p>We choose to have an array <tt class="docutils literal"><span class="pre">u</span></tt> for storing the <span class="math">\(u^n\)</span> values, <span class="math">\(n=0,1,\ldots,N_t\)</span>.
The algorithmic steps are</p>
<blockquote>
<div><ol class="arabic simple">
<li>initialize <span class="math">\(u^0\)</span></li>
<li>for <span class="math">\(t=t_n\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>: compute <span class="math">\(u_n\)</span> using
the <span class="math">\(\theta\)</span>-rule formula</li>
</ol>
</div></blockquote>
<div class="section" id="function-for-computing-the-numerical-solution">
<h4>Function for computing the numerical solution<a class="headerlink" href="#function-for-computing-the-numerical-solution" title="Permalink to this headline">¶</a></h4>
<p>The following Python function takes the input data of the problem
(<span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, <span class="math">\(\theta\)</span>) as arguments and returns two arrays with
the solution <span class="math">\(u^0,\ldots,u^{N_t}\)</span> and the mesh points <span class="math">\(t_0,\ldots,t_{N_t}\)</span>,
respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">numpy</span></tt> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">zeros(Nt+1)</span></tt> for creating an array of a size <tt class="docutils literal"><span class="pre">Nt+1</span></tt>
and initializing the elements to zero</li>
<li><tt class="docutils literal"><span class="pre">linspace(0,</span> <span class="pre">T,</span> <span class="pre">Nt+1)</span></tt> for creating an array with <tt class="docutils literal"><span class="pre">Nt+1</span></tt>
coordinates uniformly distributed between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt></li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop deserves a comment, especially for newcomers to Python.
The construction <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">Nt,</span> <span class="pre">s)</span></tt> generates all integers from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">Nt</span></tt>
in steps of <tt class="docutils literal"><span class="pre">s</span></tt>, <em>but not including</em> <tt class="docutils literal"><span class="pre">Nt</span></tt>. Omitting <tt class="docutils literal"><span class="pre">s</span></tt> means <tt class="docutils literal"><span class="pre">s=1</span></tt>.
For example, <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">6,</span> <span class="pre">3)</span></tt>
gives <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt>, while <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">Nt)</span></tt> generates <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ..., <tt class="docutils literal"><span class="pre">Nt-1</span></tt>.
Our loop implies the following assignments to <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>: <tt class="docutils literal"><span class="pre">u[1]</span></tt>, <tt class="docutils literal"><span class="pre">u[2]</span></tt>, ...,
<tt class="docutils literal"><span class="pre">u[Nt]</span></tt>, which is what we want since <tt class="docutils literal"><span class="pre">u</span></tt> has length <tt class="docutils literal"><span class="pre">Nt+1</span></tt>.
The first index in Python arrays or lists is <em>always</em> <tt class="docutils literal"><span class="pre">0</span></tt> and the
last is then <tt class="docutils literal"><span class="pre">len(u)-1</span></tt>. The length of an array <tt class="docutils literal"><span class="pre">u</span></tt> is obtained by
<tt class="docutils literal"><span class="pre">len(u)</span></tt> or <tt class="docutils literal"><span class="pre">u.size</span></tt>.</p>
<p>To compute with the <tt class="docutils literal"><span class="pre">solver</span></tt> function, we need to <em>call</em> it. Here
is a sample call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-division">
<h4>Integer division<a class="headerlink" href="#integer-division" title="Permalink to this headline">¶</a></h4>
<p>The shown implementation of the <tt class="docutils literal"><span class="pre">solver</span></tt> may face problems and
wrong results if <tt class="docutils literal"><span class="pre">T</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">dt</span></tt>, and <tt class="docutils literal"><span class="pre">theta</span></tt> are given as integers,
see <em class="xref std std-ref">decay:exer:intdiv</em> and <em class="xref std std-ref">decay:exer:decay1err</em>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, C++, and many other computer languages): <tt class="docutils literal"><span class="pre">1/2</span></tt> becomes <tt class="docutils literal"><span class="pre">0</span></tt>,
while <tt class="docutils literal"><span class="pre">1.0/2</span></tt>, <tt class="docutils literal"><span class="pre">1/2.0</span></tt>, or <tt class="docutils literal"><span class="pre">1.0/2.0</span></tt> all become <tt class="docutils literal"><span class="pre">0.5</span></tt>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <tt class="docutils literal"><span class="pre">float</span></tt> object)
to ensure correct mathematical division. Inserting
a conversion <tt class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">float(dt)</span></tt>
guarantees that <tt class="docutils literal"><span class="pre">dt</span></tt> is
<tt class="docutils literal"><span class="pre">float</span></tt> and avoids problems in <em class="xref std std-ref">decay:exer:decay1err</em>.</p>
<p>Another problem with computing <span class="math">\(N_t=T/\Delta t\)</span> is that we should
round <span class="math">\(N_t\)</span> to the nearest integer. With <tt class="docutils literal"><span class="pre">Nt</span> <span class="pre">=</span> <span class="pre">int(T/dt)</span></tt> the <tt class="docutils literal"><span class="pre">int</span></tt>
operation picks the largest integer smaller than <tt class="docutils literal"><span class="pre">T/dt</span></tt>. Correct
mathematical rounding as known from school is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete version of our improved, safer <tt class="docutils literal"><span class="pre">solver</span></tt> function then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="doc-strings">
<h4>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h4>
<p id="index-28">Right below the header line in the <tt class="docutils literal"><span class="pre">solver</span></tt> function there is a
Python string enclosed in triple double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve</span>

<span class="sd">        u&#39;(t) = -a*u(t),</span>

<span class="sd">    with initial condition u(0)=I, for t in the time interval</span>
<span class="sd">    (0,T]. The time interval is divided into time steps of</span>
<span class="sd">    length dt.</span>

<span class="sd">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span class="sd">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span class="sd">    Nicolson method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.</p>
<p>It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.</p>
</div>
<div class="section" id="formatting-of-numbers">
<h4>Formatting of numbers<a class="headerlink" href="#formatting-of-numbers" title="Permalink to this headline">¶</a></h4>
<p>Having computed the discrete solution <tt class="docutils literal"><span class="pre">u</span></tt>, it is natural to look at
the numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Write out a table of t and u values:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>This compact <tt class="docutils literal"><span class="pre">print</span></tt> statement gives unfortunately quite ugly output
because the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages inherited from C. Another choice is
Python&#8217;s recent <em>format string syntax</em>.</p>
<p id="index-29">Writing <tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> in two nicely formatted columns is done like
this with the printf format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The percentage signs signify &#8220;slots&#8221; in the text where the variables
listed at the end of the statement are inserted. For each &#8220;slot&#8221; one
must specify a format for how the variable is going to appear in the
string: <tt class="docutils literal"><span class="pre">s</span></tt> for pure text, <tt class="docutils literal"><span class="pre">d</span></tt> for an integer, <tt class="docutils literal"><span class="pre">g</span></tt> for a real number
written as compactly as possible, <tt class="docutils literal"><span class="pre">9.3E</span></tt> for scientific notation with
three decimals in a field of width 9 characters (e.g., <tt class="docutils literal"><span class="pre">-1.351E-2</span></tt>),
or <tt class="docutils literal"><span class="pre">.2f</span></tt> for standard decimal notation with two decimals
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.</p>
<p id="index-30">The alternative <em>format string syntax</em> looks like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t={t:6.3f} u={u:g}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>As seen, this format allows logical names in the &#8220;slots&#8221; where
<tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> are to be inserted. The &#8220;slots&#8221; are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.</p>
</div>
<div class="section" id="running-the-program">
<h4>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h4>
<p>The function and main program shown above must be placed in a file,
say with name <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_v1.py">decay_v1.py</a> (<tt class="docutils literal"><span class="pre">v1</span></tt> for 1st version of this program).  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python decay_v1.py
</pre></div>
</div>
<p>The text <tt class="docutils literal"><span class="pre">Terminal&gt;</span></tt> just indicates a prompt in a
Unix/Linux or DOS terminal window. After this prompt, which will look
different in your terminal window, depending on the terminal application
and how it is set up, commands like <tt class="docutils literal"><span class="pre">python</span> <span class="pre">decay_v1.py</span></tt> can be issued.
These commands are interpreted by the operating system.</p>
<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <tt class="docutils literal"><span class="pre">ipython</span></tt> in the terminal window.
Inside the IPython shell, our program <tt class="docutils literal"><span class="pre">decay_v1.py</span></tt> is run by the command
<tt class="docutils literal"><span class="pre">run</span> <span class="pre">decay_v1.py</span></tt>:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ipython

In [1]: run decay_v1.py
t= 0.000 u=1
t= 0.800 u=0.384615
t= 1.600 u=0.147929
t= 2.400 u=0.0568958
t= 3.200 u=0.021883
t= 4.000 u=0.00841653
t= 4.800 u=0.00323713
t= 5.600 u=0.00124505
t= 6.400 u=0.000478865
t= 7.200 u=0.000184179
t= 8.000 u=7.0838e-05

In [2]:
</pre></div>
</div>
<p>The advantage of running programs in IPython are many: previous commands
are easily recalled with the up arrow, <tt class="docutils literal"><span class="pre">%pdb</span></tt> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython &#8211; to mention a few of the most
useful features.</p>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> and run programs through
a typesetting like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python programname
</pre></div>
</div>
<p>The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.</p>
<span class="target" id="index-31"></span></div>
<div class="section" id="plotting-the-solution">
<span id="index-32"></span><h4>Plotting the solution<a class="headerlink" href="#plotting-the-solution" title="Permalink to this headline">¶</a></h4>
<p>Having the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> arrays, the approximate solution <tt class="docutils literal"><span class="pre">u</span></tt> is visualized
by the intuitive command <tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It will be illustrative to also plot <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> for comparison. We first
need to make a function for computing the analytical solution <span class="math">\({u_{\small\mbox{e}}}(t)=Ie^{-at}\)</span>
of the model problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>It is tempting to just do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">u_e</span><span class="p">)</span>
</pre></div>
</div>
<p>However, this is not exactly what we want: the <tt class="docutils literal"><span class="pre">plot</span></tt> function draws
straight lines between the discrete points <tt class="docutils literal"><span class="pre">(t[n],</span> <span class="pre">u_e[n])</span></tt> while
<span class="math">\({u_{\small\mbox{e}}}(t)\)</span> varies as an exponential function between the mesh points.
The technique for showing the &#8220;exact&#8221; variation of <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> between
the mesh points is to introduce a very fine mesh for <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>      <span class="c"># fine mesh</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also plot the curves with different colors and styles, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>         <span class="c"># blue line for u_e</span>
     <span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>       <span class="c"># red dashes w/circles</span>
</pre></div>
</div>
<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete function for creating
the comparison plot becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">plot_numerical_and_exact</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare the numerical and exact solution in a plot.&quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>        <span class="c"># fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">,</span>            <span class="c"># red dashes w/circles</span>
         <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>              <span class="c"># blue line for exact sol.</span>
    <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;plot_</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>

<span class="n">plot_numerical_and_exact</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">savefig</span></tt> here creates a PNG file whose name reflects the
values of <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> so that we can easily distinguish
files from different runs with <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>The complete code is found in the file
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_v2.py">decay_v2.py</a>. The resulting plot
is shown in Figure <em class="xref std std-ref">decay:fig:v2</em>. As seen, there is quite some
discrepancy between the exact and the numerical solution.
Fortunately, the numerical solution approaches the exact one as
<span class="math">\(\Delta t\)</span> is reduced.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/decay_v2.png"><img alt="_images/decay_v2.png" src="_images/decay_v2.png" style="width: 500px;" /></a>
</div>
</div>
</div>
<div class="section" id="verifying-the-implementation">
<h3>Verifying the implementation<a class="headerlink" href="#verifying-the-implementation" title="Permalink to this headline">¶</a></h3>
<p>It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the solution before it has
been thoroughly verified.  The most obvious idea to verify the
computations is to compare the numerical solution with the exact
solution, when that exists, but there will always be a discrepancy
between these two solutions because of the numerical
approximations. The challenging question is whether we have the
mathematically correct discrepancy or if we have another, maybe small,
discrepancy due to both an approximation error and an error in the
implementation. When looking at Figure <em class="xref std std-ref">decay:fig:v2</em>, it is
impossible to judge whether the program is correct or not.</p>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
property that there are no errors in the implementation. To avoid
mixing unavoidable approximation errors and undesired implementation
errors, we should try to make tests where we have some exact
computation of the discrete solution or at least parts of it.
Examples will show how this can be done.</p>
<div class="section" id="running-a-few-algorithmic-steps-by-hand">
<h4>Running a few algorithmic steps by hand<a class="headerlink" href="#running-a-few-algorithmic-steps-by-hand" title="Permalink to this headline">¶</a></h4>
<p>The simplest approach to produce a correct reference for the discrete
solution <span class="math">\(u\)</span> of finite difference equations is to compute a few
steps of the algorithm by hand. Then we can compare the hand
calculations with numbers produced by the program.</p>
<p>A straightforward approach is to use a calculator and
compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>. With <span class="math">\(I=0.1\)</span>, <span class="math">\(\theta=0.8\)</span>,
and <span class="math">\(\Delta t =0.8\)</span> we get</p>
<div class="math">
\[A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035\]</div>
<div class="math">
\[\begin{split}u^1 &amp;= AI=0.0298245614035,\\
u^2 &amp;= Au^1= 0.00889504462912,\\
u^3 &amp;=Au^2= 0.00265290804728\end{split}\]</div>
<p>Comparison of these manual calculations with the result of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function is carried out in the function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver_three_steps</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">,</span>
                       <span class="mf">0.0298245614035</span><span class="p">,</span>
                       <span class="mf">0.00889504462912</span><span class="p">,</span>
                       <span class="mf">0.00265290804728</span><span class="p">])</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># number of time steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_by_hand</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">assert</span> <span class="n">success</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">test_solver_three_steps</span></tt> function follows widely used conventions
for <em>unit testing</em>. By following such conventions we can at a later
stage easily execute a big test suite for our software. The
conventions are three-fold:</p>
<blockquote>
<div><ul class="simple">
<li>The test function starts with <tt class="docutils literal"><span class="pre">test_</span></tt> and takes no arguments.</li>
<li>The test ends up in a boolean expression that is <tt class="docutils literal"><span class="pre">True</span></tt> if
the test passed and <tt class="docutils literal"><span class="pre">False</span></tt> if it failed.</li>
<li>The function runs <tt class="docutils literal"><span class="pre">assert</span></tt> on the boolean expression, resulting
in program abortion (due to an <tt class="docutils literal"><span class="pre">AssertionError</span></tt> exception) if
the test failed.</li>
</ul>
</div></blockquote>
<p>The main program can routinely run the verification test prior to
solving the real problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">test_solver_three_steps</span><span class="p">()</span>
<span class="n">plot_numerical_and_exact</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(Rather than calling <tt class="docutils literal"><span class="pre">test_*()</span></tt> functions explicitly, one will
normally ask a testing framework like nose
or pytest to find and run such functions.)
The complete program including the verification above is
found in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_v3.py">decay_v3.py</a>.</p>
</div>
</div>
<div class="section" id="computing-the-numerical-error-as-a-mesh-function">
<span id="decay-computing-error"></span><h3>Computing the numerical error as a mesh function<a class="headerlink" href="#computing-the-numerical-error-as-a-mesh-function" title="Permalink to this headline">¶</a></h3>
<p>Now that we have some evidence for a correct implementation, we are in a
position to compare the computed <span class="math">\(u^n\)</span> values in the <tt class="docutils literal"><span class="pre">u</span></tt> array with
the exact <span class="math">\(u\)</span> values at the mesh points, in order to study the error
in the numerical solution.</p>
<p id="index-33">A natural way to compare the exact and discrete solutions is to
calculate their difference as a mesh function:</p>
<div class="math">
\[e^n = {u_{\small\mbox{e}}}(t_n) - u^n,\quad n=0,1,\ldots,N_t {\thinspace .}\]</div>
<p>We may view <span class="math">\({u_{\small\mbox{e}}}^n = {u_{\small\mbox{e}}}(t_n)\)</span> as the representation of <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>
as a mesh function rather than a continuous function defined for all
<span class="math">\(t\in [0,T]\)</span> (<span class="math">\({u_{\small\mbox{e}}}^n\)</span> is often called the <em>representative</em> of
<span class="math">\({u_{\small\mbox{e}}}\)</span> on the mesh). Then, <span class="math">\(e^n = {u_{\small\mbox{e}}}^n - u^n\)</span> is clearly
the difference of two mesh functions. This interpretation of <span class="math">\(e^n\)</span>
is natural when programming.</p>
<p>The error mesh function <span class="math">\(e^n\)</span> can be computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical sol.</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>      <span class="c"># Representative of exact sol.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>Note that the mesh functions <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_e</span></tt> are represented by arrays
and associated with the points in the array <tt class="docutils literal"><span class="pre">t</span></tt>.</p>
<span class="target" id="index-34"></span><div class="admonition-array-arithmetics admonition" id="index-35">
<p class="first admonition-title">Array arithmetics</p>
<p>The last statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p class="last">are primary examples of array arithmetics: <tt class="docutils literal"><span class="pre">t</span></tt> is an
array of mesh points that we pass to <tt class="docutils literal"><span class="pre">exact_solution</span></tt>. This function
evaluates <tt class="docutils literal"><span class="pre">-a*t</span></tt>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <tt class="docutils literal"><span class="pre">tmp1</span></tt>. Then
<tt class="docutils literal"><span class="pre">exp(tmp1)</span></tt> means applying the exponential function to each element in
<tt class="docutils literal"><span class="pre">tmp</span></tt>, resulting an array, say <tt class="docutils literal"><span class="pre">tmp2</span></tt>. Finally, <tt class="docutils literal"><span class="pre">I*tmp2</span></tt> is computed
(scalar times array) and <tt class="docutils literal"><span class="pre">u_e</span></tt> refers to this array returned from
<tt class="docutils literal"><span class="pre">exact_solution</span></tt>. The expression <tt class="docutils literal"><span class="pre">u_e</span> <span class="pre">-</span> <span class="pre">u</span></tt> is the difference between
two arrays, resulting in a new array referred to by <tt class="docutils literal"><span class="pre">e</span></tt>.</p>
</div>
</div>
<div class="section" id="computing-the-norm-of-the-numerical-error">
<span id="decay-computing-error-norm"></span><h3>Computing the norm of the numerical error<a class="headerlink" href="#computing-the-norm-of-the-numerical-error" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-36"></span><p id="index-37">Instead of working with the error <span class="math">\(e^n\)</span> on the entire mesh, we
often want one number expressing the size of the error.
This is obtained by taking the norm of the error function.</p>
<p>Let us first define norms of a function <span class="math">\(f(t)\)</span>
defined for all <span class="math">\(t\in [0,T]\)</span>.
Three common norms are</p>
<div class="math" id="equation-decay:norms:L2">
<span class="eqno">(30)</span>\[     ||f||_{L^2} = \left( \int_0^T f(t)^2 dt\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:L1">
<span class="eqno">(31)</span>\[     ||f||_{L^1} = \int_0^T |f(t)| dt,\]</div>
<div class="math" id="equation-decay:norms:Linf">
<span class="eqno">(32)</span>\[     ||f||_{L^\infty} = \max_{t\in [0,T]}|f(t)|{\thinspace .}\]</div>
<p>The <span class="math">\(L^2\)</span> norm <a href="#equation-decay:norms:L2">(30)</a> (&#8220;L-two norm&#8221;)
has nice mathematical properties and
is the most popular norm. It is a generalization
of the well-known Eucledian norm of vectors to functions.
The <span class="math">\(L^\infty\)</span> is also called the max norm or the supremum norm.
In fact, there is a whole family of norms,</p>
<div class="math">
\[||f||_{L^p} = \left(\int_0^T f(t)^pdt\right)^{1/p},\]</div>
<p>with <span class="math">\(p\)</span> real. In particular,
<span class="math">\(p=1\)</span> corresponds to the <span class="math">\(L^1\)</span> norm above while <span class="math">\(p=\infty\)</span> is the
<span class="math">\(L^\infty\)</span> norm.</p>
<span class="target" id="index-38"></span><span class="target" id="index-39"></span><p id="index-40">Numerical computations involving mesh functions need corresponding norms.
Given a set of function values, <span class="math">\(f^n\)</span>, and some associated mesh points, <span class="math">\(t_n\)</span>,
a numerical integration rule can be used to calculate the <span class="math">\(L^2\)</span> and
<span class="math">\(L^1\)</span> norms defined above. Imagining that the mesh function is extended
to vary linearly between the mesh points, the Trapezoidal rule is
in fact an exact integration rule. A possible modification of the <span class="math">\(L^2\)</span>
norm for a mesh function <span class="math">\(f^n\)</span> on a uniform mesh with spacing <span class="math">\(\Delta t\)</span>
is therefore the well-known Trapezoidal integration formula</p>
<div class="math">
\[||f^n|| = \left(\Delta t\left(\frac{1}{2}(f^0)^2 + \frac{1}{2}(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2}\]</div>
<p>A common approximation of this expression, motivated by the
convenience of having a simpler formula, is</p>
<div class="math">
\[||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2} {\thinspace .}\]</div>
<p>This is called the discrete <span class="math">\(L^2\)</span> norm and denoted by <span class="math">\(\ell^2\)</span>.
The error in <span class="math">\(||f||_{\ell^2}^2\)</span> compared with the Trapezoidal
integration formula
is <span class="math">\(\Delta t((f^0)^2 + (f^{N_t})^2)/2\)</span>, which means perturbed weights
at the end points of the mesh function, and the error goes to zero as
<span class="math">\(\Delta t\rightarrow 0\)</span>. As long as we are consistent and
stick to one kind of integration
rule for the norm of a mesh function, the details and accuracy of this
rule is not of concern.</p>
<p>The three discrete norms for a mesh function <span class="math">\(f^n\)</span>, corresponding to
the <span class="math">\(L^2\)</span>, <span class="math">\(L^1\)</span>, and <span class="math">\(L^\infty\)</span> norms of <span class="math">\(f(t)\)</span> defined above, are
defined by</p>
<div class="math" id="equation-decay:norms:l2">
<span class="eqno">(33)</span>\[     ||f^n||_{\ell^2}  \left( \Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:l1">
<span class="eqno">(34)</span>\[     ||f^n||_{\ell^1}  \Delta t\sum_{n=0}^{N_t} |f^n|\]</div>
<div class="math" id="equation-decay:norms:linf">
<span class="eqno">(35)</span>\[     ||f^n||_{\ell^\infty}  \max_{0\leq n\leq N_t}|f^n|{\thinspace .}\]</div>
<p>Note that the <span class="math">\(L^2\)</span>, <span class="math">\(L^1\)</span>, <span class="math">\(\ell^2\)</span>, and <span class="math">\(\ell^1\)</span> norms depend on the
length of the interval of interest (think of <span class="math">\(f=1\)</span>, then the
norms are proportional to <span class="math">\(\sqrt{T}\)</span> or <span class="math">\(T\)</span>). In some applications it
is convenient to think of a mesh function as just a vector of function
values and neglect the information of the mesh points. Then we can
replace <span class="math">\(\Delta t\)</span> by <span class="math">\(T/N_t\)</span> and drop <span class="math">\(T\)</span>. Moreover, it is convenient
to divide by the total length of the vector, <span class="math">\(N_t+1\)</span>, instead of <span class="math">\(N_t\)</span>.
This reasoning gives rise to the <em>vector norms</em> for a vector
<span class="math">\(f=(f_0,\ldots,f_{N})\)</span>:</p>
<div class="math" id="equation-decay:norms:vl2">
<span class="eqno">(36)</span>\[     ||f||_2 = \left( \frac{1}{N+1}\sum_{n=0}^{N} (f_n)^2\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:vl1">
<span class="eqno">(37)</span>\[     ||f||_1 = \frac{1}{N+1}\sum_{n=0}^{N} |f_n|\]</div>
<div class="math" id="equation-decay:norms:vlinf">
<span class="eqno">(38)</span>\[     ||f||_{\ell^\infty} = \max_{0\leq n\leq N}|f_n|{\thinspace .}\]</div>
<p>Here we have used the common vector component notation with subscripts
(<span class="math">\(f_n\)</span>) and <span class="math">\(N\)</span> as length. We will mostly work with mesh functions
and use the discrete <span class="math">\(\ell^2\)</span>
norm <a href="#equation-decay:norms:l2">(33)</a> or the max norm <span class="math">\(\ell^\infty\)</span>
<a href="#equation-decay:norms:linf">(35)</a>, but the corresponding vector norms
<a href="#equation-decay:norms:vl2">(36)</a>-<a href="#equation-decay:norms:vlinf">(38)</a> are also much used
in numerical computations, so it is important to know the different
norms and the relations between them.</p>
<p id="index-41">A single number that expresses the size of the numerical error
will be taken as <span class="math">\(||e^n||_{\ell^2}\)</span> and called <span class="math">\(E\)</span>:</p>
<div class="math" id="equation-decay:E">
<span class="eqno">(39)</span>\[     E = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}\]</div>
<p>The corresponding Python code, using array arithmetics, reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">sum</span></tt> function comes from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the sum of the elements
of an array. Also the <tt class="docutils literal"><span class="pre">sqrt</span></tt> function is from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the
square root of each element in the array argument.</p>
<div class="section" id="scalar-computing">
<span id="index-42"></span><h4>Scalar computing<a class="headerlink" href="#scalar-computing" title="Permalink to this headline">¶</a></h4>
<p>Instead of doing array computing <tt class="docutils literal"><span class="pre">sqrt(dt*sum(e**2))</span></tt> we can compute with
one element at a time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>     <span class="c"># length of u array (alt: u.size)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># summation variable</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than what we
can achieve with array computing.</p>
</div>
</div>
<div class="section" id="plotting-solutions">
<span id="decay-plotting"></span><h3>Plotting solutions<a class="headerlink" href="#plotting-solutions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-43"></span></div>
<div class="section" id="experiments-with-computing-and-plotting">
<span id="index-44"></span><h3>Experiments with computing and plotting<a class="headerlink" href="#experiments-with-computing-and-plotting" title="Permalink to this headline">¶</a></h3>
<p>Let us wrap up the computation of the error measure and all the
plotting statements for comparing the exact and numerical
solution in a new function <tt class="docutils literal"><span class="pre">explore</span></tt>. This function
can be called for various <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values
to see how the error varies with the method and the mesh resolution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the solver, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>    <span class="c"># Numerical solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>                         <span class="c"># create new plot</span>
        <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>       <span class="c"># fine mesh for u_e</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>           <span class="c"># red dashes w/circles</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>             <span class="c"># blue line for exact sol.</span>
        <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">figure()</span></tt> call is key: without it, a new <tt class="docutils literal"><span class="pre">plot</span></tt> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <tt class="docutils literal"><span class="pre">figure()</span></tt> ensures this.</p>
<p>Filenames with the method name (FE, BE, or CN) rather than the
<span class="math">\(\theta\)</span> value embedded in the name, can easily be created with
the aid of a little Python dictionary for mapping <span class="math">\(\theta\)</span> to
method acronyms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<span class="target" id="index-45"></span><span class="target" id="index-46"></span><span class="target" id="index-47"></span><p id="index-48">The <tt class="docutils literal"><span class="pre">explore</span></tt> function stores the plot in two different image file formats:
PNG and PDF. The PNG format is aimed
at being included in HTML files and the PDF format in LaTeX documents
(more precisely, in pdfLaTeX documents).
Frequently used viewers for these
image files on Unix systems are <tt class="docutils literal"><span class="pre">gv</span></tt> (comes with Ghostscript)
for the PDF format and
<tt class="docutils literal"><span class="pre">display</span></tt> (from the ImageMagick) suite for PNG files:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; gv BE_0.5.pdf
Terminal&gt; display BE_0.5.png
</pre></div>
</div>
<p>A main program may run a loop over the three methods (<span class="math">\(\theta\)</span> values)
and call <tt class="docutils literal"><span class="pre">explore</span></tt> to compute errors and make plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">,</span> <span class="n">theta_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%3.1f</span><span class="s"> </span><span class="si">%6.2f</span><span class="s">: </span><span class="si">%12.3E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code containing the functions above
resides in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a>.
Running this program results in</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python decay_plot_mpl.py
0.0   0.40:    2.105E-01
0.0   0.04:    1.449E-02
0.5   0.40:    3.362E-02
0.5   0.04:    1.887E-04
1.0   0.40:    1.030E-01
1.0   0.04:    1.382E-02
</pre></div>
</div>
<p>We observe that reducing <span class="math">\(\Delta t\)</span> by a factor of 10 increases the
accuracy for all three methods (<span class="math">\(\theta\)</span> values). We also see that
the combination of <span class="math">\(\theta=0.5\)</span> and a small time step <span class="math">\(\Delta t =0.04\)</span>
gives a much more accurate solution, and that <span class="math">\(\theta=0\)</span> and <span class="math">\(\theta=1\)</span>
with <span class="math">\(\Delta t = 0.4\)</span> result in the least accurate solutions.</p>
<p>Figure <a class="reference internal" href="#decay-fig-fe1"><em>The Forward Euler scheme for two values of the time step</em></a> demonstrates that the numerical solution for
<span class="math">\(\Delta t=0.4\)</span> clearly lies below the exact curve, but that the
accuracy improves considerably by reducing the time step by a factor
of 10.</p>
<div class="figure" id="decay-fig-fe1">
<a class="reference internal image-reference" href="_images/FE1.png"><img alt="_images/FE1.png" src="_images/FE1.png" style="width: 600px;" /></a>
<p class="caption"><em>The Forward Euler scheme for two values of the time step</em></p>
</div>
<span class="target" id="index-49"></span><div class="section" id="combining-plot-files">
<span id="index-50"></span><h4>Combining plot files<a class="headerlink" href="#combining-plot-files" title="Permalink to this headline">¶</a></h4>
<p>Mounting two PNG files, as done in the figure, is easily done by the
<a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program
from the ImageMagick suite:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; montage -background white -geometry 100% -tile 2x1 \
          FE_0.4.png FE_0.04.png FE1.png
Terminal&gt; convert -trim FE1.png FE1.png
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-geometry</span></tt> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <tt class="docutils literal"><span class="pre">-tile</span> <span class="pre">HxV</span></tt> option
specifies <tt class="docutils literal"><span class="pre">H</span></tt> images in the horizontal direction and <tt class="docutils literal"><span class="pre">V</span></tt> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <tt class="docutils literal"><span class="pre">FE1.png</span></tt> at the end.
The <tt class="docutils literal"><span class="pre">convert</span> <span class="pre">-trim</span></tt> command removes surrounding white areas in the figure
(an operation usually known as <em>cropping</em> in image manipulation programs).</p>
<span class="target" id="index-51"></span><span class="target" id="index-52"></span><p id="index-53">For LaTeX reports it is not recommended to use <tt class="docutils literal"><span class="pre">montage</span></tt> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <tt class="docutils literal"><span class="pre">pdftk</span></tt>, <tt class="docutils literal"><span class="pre">pdfnup</span></tt>, and <tt class="docutils literal"><span class="pre">pdfcrop</span></tt> tools
(on Linux/Unix):</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf
Terminal&gt; pdfnup --nup 2x1 --outfile tmp.pdf tmp.pdf
Terminal&gt; pdfcrop tmp.pdf FE1.png  # output in FE1.png
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">pdftk</span></tt> combines images into a multi-page PDF file, <tt class="docutils literal"><span class="pre">pdfnup</span></tt>
combines the images in individual pages to a table of images (pages),
and <tt class="docutils literal"><span class="pre">pdfcrop</span></tt> removes white margins in the resulting combined image file.</p>
<p>The behavior of the two other schemes is shown in Figures <a class="reference internal" href="#decay-fig-be1"><em>The Backward Euler scheme for two values of the time step</em></a>
and <a class="reference internal" href="#decay-fig-cn1"><em>The Crank-Nicolson scheme for two values of the time step</em></a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.</p>
<div class="figure" id="decay-fig-be1">
<a class="reference internal image-reference" href="_images/BE1.png"><img alt="_images/BE1.png" src="_images/BE1.png" style="width: 600px;" /></a>
<p class="caption"><em>The Backward Euler scheme for two values of the time step</em></p>
</div>
<div class="figure" id="decay-fig-cn1">
<a class="reference internal image-reference" href="_images/CN1.png"><img alt="_images/CN1.png" src="_images/CN1.png" style="width: 600px;" /></a>
<p class="caption"><em>The Crank-Nicolson scheme for two values of the time step</em></p>
</div>
</div>
<div class="section" id="plotting-with-scitools">
<h4>Plotting with SciTools<a class="headerlink" href="#plotting-with-scitools" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="http://code.google.com/p/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib, Gnuplot, Grace, MATLAB,
VTK, OpenDX, and VisIt. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool&#8217;s Easyviz interface, apart from the import
statement, which reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This statement performs a <tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> as well as an import
of the most common pieces of the Easyviz (<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>) package,
along with some additional numerical functionality.</p>
<p>With Easyviz one can
merge several plotting commands into a single one
using keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">,</span>           <span class="c"># red dashes w/circles</span>
     <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>             <span class="c"># blue line for exact sol.</span>
     <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span>
     <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
     <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
     <span class="n">title</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_st.py">decay_plot_st.py</a> file
contains such a demo.</p>
<p>By default, Easyviz employs Matplotlib for plotting, but <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> and <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace
</pre></div>
</div>
<p>The backend used for creating plots (and numerous other options)
can be permanently set in SciTool&#8217;s configuration file.</p>
<p>All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key &#8216;q&#8217; anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PDF and PostScript
files.</p>
<p>Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.</p>
<div class="admonition-test-the-understanding admonition">
<p class="first admonition-title">Test the understanding</p>
<p class="last"><a class="reference internal" href="#decay-app-exer-cooling-py"><em>Exercise 11: Implement schemes for Newton&#8217;s law of cooling</em></a> asks you to implement
a solver for a problem that is slightly different from the
one above. You may use the <tt class="docutils literal"><span class="pre">solver</span></tt> and <tt class="docutils literal"><span class="pre">explore</span></tt> functions
explained above as a starting point. Apply the new solver
to <a class="reference internal" href="#decay-app-exer-cooling-murder"><em>Exercise 12: Find time of murder from body temperature</em></a>.</p>
</div>
</div>
</div>
<div class="section" id="memory-saving-implementation">
<h3>Memory-saving implementation<a class="headerlink" href="#memory-saving-implementation" title="Permalink to this headline">¶</a></h3>
<p>The computer memory requirements of our implementations so far
consists mainly of the <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> arrays, both of length <span class="math">\(N_t+1\)</span>,
plus some other temporary arrays that Python needs for intermediate
results if we do array arithmetics in our program (e.g., <tt class="docutils literal"><span class="pre">I*exp(-a*t)</span></tt>
needs to store <tt class="docutils literal"><span class="pre">a*t</span></tt> before <tt class="docutils literal"><span class="pre">-</span></tt> can be applied to it and then <tt class="docutils literal"><span class="pre">exp</span></tt>).
Regardless of how we implement simple ODE problems, storage
requirements are very modest and put not restriction on how we choose
our data structures and algorithms.  Nevertheless, when the methods
for ODEs used here are applied to three-dimensional partial
differential equation (PDE) problems, memory storage requirements
suddenly become a challenging issue.</p>
<p>The PDE counterpart to our model problem <span class="math">\(u'=-a\)</span> is a diffusion
equation <span class="math">\(u_t = a\nabla^2 u\)</span> posed on a space-time domain. The
discrete representation of this domain may in 3D be a spatial mesh of
<span class="math">\(M^3\)</span> points and a time mesh of <span class="math">\(N_t\)</span> points. A typical desired value
for <span class="math">\(M\)</span> is 100 in many applications, or even <span class="math">\(1000\)</span>.  Storing all the
computed <span class="math">\(u\)</span> values, like we have done in the programs so far, demands
storage of some arrays of size <span class="math">\(M^3N_t\)</span>, giving a factor of <span class="math">\(M^3\)</span>
larger storage demands compared to our ODE programs. Each real number
in the array for <span class="math">\(u\)</span> requires 8 bytes (b) of storage. With <span class="math">\(M=100\)</span> and
<span class="math">\(N_t=1000\)</span>, there is a storage demand of <span class="math">\((10^3)^3\cdot 1000\cdot 8 =
8\)</span> Gb for the solution array.  Fortunately, we can usually get rid of
the <span class="math">\(N_t\)</span> factor, resulting in 8 Mb of storage.  Below we explain how
this is done, and the technique is almost always applied in
implementations of PDE problems.</p>
<p>Let us critically evaluate how much we really need to store in the
computer&#8217;s memory in our implementation of the <span class="math">\(\theta\)</span> method. To
compute a new <span class="math">\(u^{n+1}\)</span>, all we need is <span class="math">\(u^n\)</span>. This implies that the
previous <span class="math">\(u^{n-1},u^{n-2},\dots,u^0\)</span> values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <tt class="docutils literal"><span class="pre">u</span></tt> array we can work with
two variables for real numbers, <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_1</span></tt>, representing <span class="math">\(u^{n+1}\)</span>
and <span class="math">\(u^n\)</span> in the algorithm, respectively.  At each time level, we
update <tt class="docutils literal"><span class="pre">u</span></tt> from <tt class="docutils literal"><span class="pre">u_1</span></tt> and then set <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></tt> so that the computed
<span class="math">\(u^{n+1}\)</span> value becomes the &#8220;previous&#8221; value <span class="math">\(u^n\)</span> at the next time
level. The downside is that we cannot plot the solution after the
simulation is done since only the last two numbers are available.  The
remedy is to store computed values in a file and use the file for
visualizing the solution later.</p>
<p>We have implemented this memory saving idea in the file
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_memsave.py">decay_memsave.py</a>, which is a
slight modification of <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a>
program.</p>
<p>The following function demonstrates how we work with the two most
recent values of the unknown:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span class="sd">    Minimum use of memory. The solution is stored in a file</span>
<span class="sd">    (with name filename) for later plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>         <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>  <span class="c"># no of intervals</span>

    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="c"># u: time level n+1, u_1: time level n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
        <span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This code snippet serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> are done by the
function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Found more than two numbers on a line!&#39;</span><span class="p">,</span> <span class="n">words</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This type of file with numbers in rows and columns is very common, and
<tt class="docutils literal"><span class="pre">numpy</span></tt> has a function <tt class="docutils literal"><span class="pre">loadtxt</span></tt> which loads such tabular data into a
two-dimensional array, say with name <tt class="docutils literal"><span class="pre">data</span></tt>. The number in row <tt class="docutils literal"><span class="pre">i</span></tt> and
column <tt class="docutils literal"><span class="pre">j</span></tt> is then <tt class="docutils literal"><span class="pre">data[i,j]</span></tt>.  The whole column number <tt class="docutils literal"><span class="pre">j</span></tt> can be
extracted by <tt class="docutils literal"><span class="pre">data[:,j]</span></tt>.  A version of <tt class="docutils literal"><span class="pre">read_file</span></tt> using <tt class="docutils literal"><span class="pre">np.loadtxt</span></tt>
reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file_numpy</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
<p>The present counterpart to the <tt class="docutils literal"><span class="pre">explore</span></tt> function from
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a> must run
<tt class="docutils literal"><span class="pre">solver_memsave</span></tt> and then load data from file before we can compute
the error measure and make the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;u.dat&#39;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Apart from the internal implementation, where <span class="math">\(u^n\)</span> values are
stored in a file rather than in an array, <tt class="docutils literal"><span class="pre">decay_memsave.py</span></tt>
file works exactly as the <tt class="docutils literal"><span class="pre">decay_plot_mpl.py</span></tt> file.</p>
</div>
</div>
<div class="section" id="analysis-of-finite-difference-equations">
<span id="decay-analysis"></span><h2>Analysis of finite difference equations<a class="headerlink" href="#analysis-of-finite-difference-equations" title="Permalink to this headline">¶</a></h2>
<p>We address the ODE for exponential decay,</p>
<div class="math">
\[u'(t) = -au(t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(a\)</span> and <span class="math">\(I\)</span> are given constants. This problem is solved
by the <span class="math">\(\theta\)</span>-rule finite difference scheme, resulting in
the recursive equations</p>
<div class="math" id="equation-decay:analysis:scheme">
<span class="eqno">(40)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n\]</div>
<p>for the numerical solution <span class="math">\(u^{n+1}\)</span>, which approximates the exact
solution <span class="math">\({u_{\small\mbox{e}}}\)</span> at time point <span class="math">\(t_{n+1}\)</span>. For constant mesh spacing,
which we assume here, <span class="math">\(t_{n+1}=(n+1)\Delta t\)</span>.</p>
<p><strong>Discouraging numerical solutions.</strong>
Choosing <span class="math">\(I=1\)</span>, <span class="math">\(a=2\)</span>, and running experiments with <span class="math">\(\theta =1,0.5, 0\)</span>
for <span class="math">\(\Delta t=1.25, 0.75, 0.5, 0.1\)</span>, gives the results in
Figures <a class="reference internal" href="#decay-analysis-be4c"><em>Backward Euler</em></a>, <a class="reference internal" href="#decay-analysis-cn4c"><em>Crank-Nicolson</em></a>, and
<a class="reference internal" href="#decay-analysis-fe4c"><em>Forward Euler</em></a>.</p>
<div class="figure" id="decay-analysis-be4c">
<a class="reference internal image-reference" href="_images/BE4c.png"><img alt="_images/BE4c.png" src="_images/BE4c.png" style="width: 600px;" /></a>
<p class="caption"><em>Backward Euler</em></p>
</div>
<div class="figure" id="decay-analysis-cn4c">
<a class="reference internal image-reference" href="_images/CN4c.png"><img alt="_images/CN4c.png" src="_images/CN4c.png" style="width: 600px;" /></a>
<p class="caption"><em>Crank-Nicolson</em></p>
</div>
<div class="figure" id="decay-analysis-fe4c">
<a class="reference internal image-reference" href="_images/FE4c.png"><img alt="_images/FE4c.png" src="_images/FE4c.png" style="width: 600px;" /></a>
<p class="caption"><em>Forward Euler</em></p>
</div>
<p>The characteristics of the displayed curves can be summarized as follows:</p>
<blockquote>
<div><ul class="simple">
<li>The Backward Euler scheme always gives a monotone solution, lying above
the exact curve.</li>
<li>The Crank-Nicolson scheme gives the most accurate results, but for
<span class="math">\(\Delta t=1.25\)</span> the solution oscillates.</li>
<li>The Forward Euler scheme gives a growing, oscillating solution for
<span class="math">\(\Delta t=1.25\)</span>; a decaying, oscillating solution for <span class="math">\(\Delta t=0.75\)</span>;
a strange solution <span class="math">\(u^n=0\)</span> for <span class="math">\(n\geq 1\)</span> when <span class="math">\(\Delta t=0.5\)</span>; and
a solution seemingly as accurate as the one by the Backward Euler
scheme for <span class="math">\(\Delta t = 0.1\)</span>, but the curve lies below the exact
solution.</li>
</ul>
</div></blockquote>
<p>Since the exact solution of our model problem is a monotone function,
<span class="math">\(u(t)=Ie^{-at}\)</span>, some of these qualitatively wrong results are indeed alarming!</p>
<div class="admonition-goal admonition">
<p class="first admonition-title">Goal</p>
<p>We ask the question</p>
<blockquote>
<div><ul class="simple">
<li>Under what circumstances, i.e., values of
the input data <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(\Delta t\)</span> will the Forward Euler and
Crank-Nicolson schemes result in undesired oscillatory solutions?</li>
</ul>
</div></blockquote>
<p>The question will be investigated both by numerical experiments and
by precise mathematical theory. The latter will help establish
general criteria on <span class="math">\(\Delta t\)</span> for avoiding non-physical oscillatory
or growing solutions.</p>
<p>Another question to be raised is</p>
<blockquote>
<div><ul class="simple">
<li>How does <span class="math">\(\Delta t\)</span> impact the error in the numerical solution?</li>
</ul>
</div></blockquote>
<p class="last">For our simple model problem we can answer this question very precisely, but
we will also look at simplified formulas for small <span class="math">\(\Delta t\)</span>
and touch upon important concepts such as <em>convergence rate</em> and
<em>the order of a scheme</em>. Other fundamental concepts mentioned are
stability, consistency, and convergence.</p>
</div>
<div class="section" id="experimental-investigation-of-oscillatory-solutions">
<h3>Experimental investigation of oscillatory solutions<a class="headerlink" href="#experimental-investigation-of-oscillatory-solutions" title="Permalink to this headline">¶</a></h3>
<p>To address the first question above,
we may set up an experiment where we loop over values of <span class="math">\(I\)</span>, <span class="math">\(a\)</span>,
and <span class="math">\(\Delta t\)</span>. For each experiment, we flag the solution as
oscillatory if</p>
<div class="math">
\[\begin{split}u^{n} &gt; u^{n-1},\end{split}\]</div>
<p>for some value of <span class="math">\(n\)</span>,
since we expect <span class="math">\(u^n\)</span> to decay with <span class="math">\(n\)</span>, but oscillations make
<span class="math">\(u\)</span> increase over a time step. We will quickly see that
oscillations are independent of <span class="math">\(I\)</span>, but do depend on <span class="math">\(a\)</span> and
<span class="math">\(\Delta t\)</span>. Therefore, we introduce a two-dimensional
function <span class="math">\(B(a,\Delta t)\)</span> which is 1 if oscillations occur
and 0 otherwise. We can visualize <span class="math">\(B\)</span> as a contour plot
(lines for which <span class="math">\(B=\hbox{const}\)</span>). The contour <span class="math">\(B=0.5\)</span>
corresponds to the borderline between oscillatory regions with <span class="math">\(B=1\)</span>
and monotone regions with <span class="math">\(B=0\)</span> in the <span class="math">\(a,\Delta t\)</span> plane.</p>
<p>The <span class="math">\(B\)</span> function is defined at discrete <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> values.
Say we have given <span class="math">\(P\)</span> $a$ values, <span class="math">\(a_0,\ldots,a_{P-1}\)</span>, and
<span class="math">\(Q\)</span> $Delta t$ values, <span class="math">\(\Delta t_0,\ldots,\Delta t_{Q-1}\)</span>.
These <span class="math">\(a_i\)</span> and <span class="math">\(\Delta t_j\)</span> values, <span class="math">\(i=0,\ldots,P-1\)</span>,
<span class="math">\(j=0,\ldots,Q-1\)</span>, form a rectangular mesh of <span class="math">\(P\times Q\)</span> points
in the plane. At each point <span class="math">\((a_i, \Delta t_j)\)</span>, we associate
the corresponding value of <span class="math">\(B(a_i,\Delta t_j)\)</span>, denoted <span class="math">\(B_{ij}\)</span>.
The <span class="math">\(B_{ij}\)</span> values are naturally stored in a two-dimensional
array. We can thereafter create a plot of the
contour line <span class="math">\(B_{ij}=0.5\)</span> dividing the oscillatory and monotone
regions. The file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_osc_regions.py">decay_osc_regions.py</a>  <tt class="docutils literal"><span class="pre">osc_regions</span></tt> stands for &#8220;oscillatory regions&#8221;) contains all nuts and
bolts to produce the <span class="math">\(B=0.5\)</span> line in Figures <a class="reference internal" href="#decay-analysis-b-fe"><em>Forward Euler scheme: oscillatory solutions occur for points above the curve</em></a>
and <a class="reference internal" href="#decay-analysis-b-cn"><em>Crank-Nicolson scheme: oscillatory solutions occur for points above the curve</em></a>. The oscillatory region is above this line.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay_mod</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>

<span class="k">def</span> <span class="nf">non_physical_behavior</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given lists/arrays a and dt, and numbers I, dt, and theta,</span>
<span class="sd">    make a two-dimensional contour line B=0.5, where B=1&gt;0.5</span>
<span class="sd">    means oscillatory (unstable) solution, and B=0&lt;0.5 means</span>
<span class="sd">    monotone solution of u&#39;=-au.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># must be arrays</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>         <span class="c"># results</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>
            <span class="c"># Does u have the right monotone decay properties?</span>
            <span class="n">correct_qualitative_behavior</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c"># Not decaying?</span>
                    <span class="n">correct_qualitative_behavior</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>  <span class="c"># Jump out of loop</span>
            <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">correct_qualitative_behavior</span><span class="p">)</span>
    <span class="n">a_</span><span class="p">,</span> <span class="n">dt_</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">ndgrid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c"># make mesh of a and dt values</span>
    <span class="n">st</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">a_</span><span class="p">,</span> <span class="n">dt_</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">);</span> <span class="n">st</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;dt&#39;</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;osc_region_theta_</span><span class="si">%s</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;osc_region_theta_</span><span class="si">%s</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>

<span class="n">non_physical_behavior</span><span class="p">(</span>
    <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
    <span class="n">dt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
    <span class="n">T</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="decay-analysis-b-fe">
<a class="reference internal image-reference" href="_images/osc_region_FE.png"><img alt="_images/osc_region_FE.png" src="_images/osc_region_FE.png" style="width: 500px;" /></a>
<p class="caption"><em>Forward Euler scheme: oscillatory solutions occur for points above the curve</em></p>
</div>
<div class="figure" id="decay-analysis-b-cn">
<a class="reference internal image-reference" href="_images/osc_region_CN.png"><img alt="_images/osc_region_CN.png" src="_images/osc_region_CN.png" style="width: 500px;" /></a>
<p class="caption"><em>Crank-Nicolson scheme: oscillatory solutions occur for points above the curve</em></p>
</div>
<p>By looking at the curves in the figures one may guess that <span class="math">\(a\Delta t\)</span>
must be less than a critical limit to avoid the undesired
oscillations.  This limit seems to be about 2 for Crank-Nicolson and 1
for Forward Euler.  We shall now establish a precise mathematical
analysis of the discrete model that can explain the observations in
our numerical experiments.</p>
</div>
<div class="section" id="exact-numerical-solution">
<h3>Exact numerical solution<a class="headerlink" href="#exact-numerical-solution" title="Permalink to this headline">¶</a></h3>
<p>Starting with <span class="math">\(u^0=I\)</span>, the simple recursion <a href="#equation-decay:analysis:scheme">(40)</a>
can be applied repeatedly <span class="math">\(n\)</span> times, with the result that</p>
<div class="math" id="equation-decay:analysis:unex">
<span class="eqno">(41)</span>\[     u^{n} = IA^n,\quad A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}{\thinspace .}\]</div>
<div class="admonition-solving-difference-equations admonition">
<p class="first admonition-title">Solving difference equations</p>
<p>Difference equations where all terms are linear in
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and maybe <span class="math">\(u^{n-1}\)</span>, <span class="math">\(u^{n-2}\)</span>, etc., are
called <em>homogeneous, linear</em> difference equations, and their solutions
are generally of the form <span class="math">\(u^n=A^n\)</span>. Inserting this expression
and dividing by <span class="math">\(A^{n+1}\)</span> gives
a polynomial equation in <span class="math">\(A\)</span>. In the present case we get</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}{\thinspace .}\]</div>
<p class="last">This is a solution technique of wider applicability than repeated use of
the recursion <a href="#equation-decay:analysis:scheme">(40)</a>.</p>
</div>
<p>Regardless of the solution approach, we have obtained a formula for
<span class="math">\(u^n\)</span>.  This formula can explain everything what we see in the figures
above, but it also gives us a more general insight into accuracy and
stability properties of the three schemes.</p>
</div>
<div class="section" id="stability">
<h3>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h3>
<p id="index-54">Since <span class="math">\(u^n\)</span> is a factor <span class="math">\(A\)</span>
raised to an integer power <span class="math">\(n\)</span>, we realize that <span class="math">\(A&lt;0\)</span>
will for odd powers imply <span class="math">\(u^n&lt;0\)</span> and for even power result in <span class="math">\(u^n&gt;0\)</span>.
That is, the solution oscillates between the mesh points.
We have oscillations due to <span class="math">\(A&lt;0\)</span> when</p>
<div class="math" id="equation-decay:th:stability">
<span class="eqno">(42)</span>\[\begin{split}     (1-\theta)a\Delta t &gt; 1 {\thinspace .}\end{split}\]</div>
<p>Since <span class="math">\(A&gt;0\)</span> is a requirement for having a numerical solution with the
same basic property (monotonicity) as the exact solution, we may say
that <span class="math">\(A&gt;0\)</span> is a <em>stability criterion</em>. Expressed in terms of <span class="math">\(\Delta t\)</span>
the stability criterion reads</p>
<div class="math">
\[\begin{split}\Delta t &lt; \frac{1}{(1-\theta)a}{\thinspace .}\end{split}\]</div>
<p>The Backward
Euler scheme is always stable since <span class="math">\(A&lt;0\)</span> is impossible for <span class="math">\(\theta=1\)</span>, while
non-oscillating solutions for Forward Euler and Crank-Nicolson
demand <span class="math">\(\Delta t\leq 1/a\)</span> and <span class="math">\(\Delta t\leq 2/a\)</span>, respectively.
The relation between <span class="math">\(\Delta t\)</span> and <span class="math">\(a\)</span> look reasonable: a larger
<span class="math">\(a\)</span> means faster decay and hence a need for smaller time steps.</p>
<p>Looking at Figure <a class="reference internal" href="#decay-analysis-fe4c"><em>Forward Euler</em></a>, we see that with <span class="math">\(a\Delta
t= 2\cdot 1.25=2.5\)</span>, <span class="math">\(A=-1.5\)</span>, and the solution <span class="math">\(u^n=(-1.5)^n\)</span>
oscillates <em>and</em> grows. With <span class="math">\(a\Delta t = 2\cdot 0.75=1.5\)</span>, <span class="math">\(A=-0.5\)</span>,
<span class="math">\(u^n=(-0.5)^n\)</span> decays but oscillates. The peculiar case <span class="math">\(\Delta t =
0.5\)</span>, where the Forward Euler scheme produces a solution that is stuck
on the <span class="math">\(t\)</span> axis, corresponds to <span class="math">\(A=0\)</span> and therefore <span class="math">\(u^0=I=1\)</span> and
<span class="math">\(u^n=0\)</span> for <span class="math">\(n\geq 1\)</span>.  The decaying oscillations in the Crank-Nicolson scheme
for <span class="math">\(\Delta t=1.25\)</span> are easily explained by the fact that <span class="math">\(A\approx -0.11&lt;0\)</span>.</p>
<p id="index-55">The factor <span class="math">\(A\)</span> is called the <em>amplification factor</em> since the solution
at a new time level is <span class="math">\(A\)</span> times the solution at the previous time
level. For a decay process, we must obviously have <span class="math">\(|A|\leq 1\)</span>, which
is fulfilled for all <span class="math">\(\Delta t\)</span> if <span class="math">\(\theta \geq 1/2\)</span>. Arbitrarily
large values of <span class="math">\(u\)</span> can be generated when <span class="math">\(|A|&gt;1\)</span> and <span class="math">\(n\)</span> is large
enough. The numerical solution is in such cases totally irrelevant to
an ODE modeling decay processes! To avoid this situation, we must
for <span class="math">\(\theta &lt; 1/2\)</span> have</p>
<div class="math">
\[\Delta t \leq \frac{2}{(1-2\theta)a},\]</div>
<p>which means <span class="math">\(\Delta t &lt; 2/a\)</span> for the Forward Euler scheme.</p>
<span class="target" id="index-56"></span><div class="admonition-stability-properties admonition" id="index-57">
<p class="first admonition-title">Stability properties</p>
<p>We may summarize the stability investigations as follows:</p>
<ol class="arabic simple">
<li>The Forward Euler method is a <em>conditionally stable</em> scheme because
it requires <span class="math">\(\Delta t &lt; 2/a\)</span> for avoiding growing solutions
and <span class="math">\(\Delta t &lt; 1/a\)</span> for avoiding oscillatory solutions.</li>
<li>The Crank-Nicolson is <em>unconditionally stable</em> with respect to
growing solutions, while it is conditionally stable with
the criterion <span class="math">\(\Delta t &lt; 2/a\)</span> for avoiding oscillatory solutions.</li>
<li>The Backward Euler method is unconditionally stable with respect
to growing and oscillatory solutions - any <span class="math">\(\Delta t\)</span> will work.</li>
</ol>
<p class="last">Much literature on ODEs speaks about L-stable and A-stable methods.
In our case A-stable methods ensures non-growing solutions, while
L-stable methods also avoids oscillatory solutions.</p>
</div>
</div>
<div class="section" id="comparing-amplification-factors">
<h3>Comparing amplification factors<a class="headerlink" href="#comparing-amplification-factors" title="Permalink to this headline">¶</a></h3>
<p>After establishing how <span class="math">\(A\)</span> impacts the qualitative features of the
solution, we shall now look more into how well the numerical amplification
factor approximates the exact one. The exact solution reads
<span class="math">\(u(t)=Ie^{-at}\)</span>, which can be rewritten as</p>
<div class="math">
\[{{u_{\small\mbox{e}}}}(t_n) = Ie^{-a n\Delta t} = I(e^{-a\Delta t})^n {\thinspace .}\]</div>
<p>From this formula we see that the exact amplification factor is</p>
<div class="math">
\[{A_{\small\mbox{e}}} = e^{-a\Delta t} {\thinspace .}\]</div>
<p>We realize that the exact and numerical amplification factors depend
on <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> through the product <span class="math">\(a\Delta t\)</span>. Therefore, it
is convenient to introduce a symbol for this product, <span class="math">\(p=a\Delta t\)</span>,
and view <span class="math">\(A\)</span> and <span class="math">\({A_{\small\mbox{e}}}\)</span> as functions of <span class="math">\(p\)</span>. Figure
<a class="reference internal" href="#decay-analysis-fig-a"><em>Comparison of amplification factors</em></a> shows these functions. Crank-Nicolson is
clearly closest to the exact amplification factor, but that method has
the unfortunate oscillatory behavior when <span class="math">\(p&gt;2\)</span>.</p>
<div class="figure" id="decay-analysis-fig-a">
<a class="reference internal image-reference" href="_images/A_factors.png"><img alt="_images/A_factors.png" src="_images/A_factors.png" style="width: 500px;" /></a>
<p class="caption"><em>Comparison of amplification factors</em></p>
</div>
</div>
<div class="section" id="series-expansion-of-amplification-factors">
<h3>Series expansion of amplification factors<a class="headerlink" href="#series-expansion-of-amplification-factors" title="Permalink to this headline">¶</a></h3>
<p>As an alternative to the visual understanding inherent in Figure
<a class="reference internal" href="#decay-analysis-fig-a"><em>Comparison of amplification factors</em></a>, there is a strong tradition in numerical
analysis to establish formulas for the approximation errors when the
discretization parameter, here <span class="math">\(\Delta t\)</span>, becomes small. In the
present case we let <span class="math">\(p\)</span> be our small discretization parameter, and it
makes sense to simplify the expressions for <span class="math">\(A\)</span> and <span class="math">\({A_{\small\mbox{e}}}\)</span> by using
Taylor polynomials around <span class="math">\(p=0\)</span>.  The Taylor polynomials are accurate
for small <span class="math">\(p\)</span> and greatly simplifies the comparison of the analytical
expressions since we then can compare polynomials, term by term.</p>
<p>Calculating the Taylor series for <span class="math">\({A_{\small\mbox{e}}}\)</span> is easily done by hand, but
the three versions of <span class="math">\(A\)</span> for <span class="math">\(\theta=0,1,{\frac{1}{2}}\)</span> lead to more
cumbersome calculations.
Nowadays, analytical computations can benefit greatly by
symbolic computer algebra software. The Python package <tt class="docutils literal"><span class="pre">sympy</span></tt>
represents a powerful computer algebra system, not yet as sophisticated as
the famous Maple and Mathematica systems, but free and
very easy to integrate with our numerical computations in Python.</p>
<p>When using <tt class="docutils literal"><span class="pre">sympy</span></tt>, it is convenient to enter the interactive Python
mode where we can write expressions and statements and immediately see
the results.  Here is a simple example. We strongly recommend to use
<tt class="docutils literal"><span class="pre">isympy</span></tt> (or <tt class="docutils literal"><span class="pre">ipython</span></tt>) for such interactive sessions.</p>
<p>Let us illustrate <tt class="docutils literal"><span class="pre">sympy</span></tt> with a standard Python shell syntax
(<tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> prompt) to compute a Taylor polynomial approximation to <span class="math">\(e^{-p}\)</span>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># Create p as a mathematical symbol with name &#39;p&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># Create a mathematical expression with p</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A_e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># Find the first 6 terms of the Taylor series of A_e</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">120</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">24</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>Lines with <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> represent input lines and lines without
this prompt represents the result of computations (note that
<tt class="docutils literal"><span class="pre">isympy</span></tt> and <tt class="docutils literal"><span class="pre">ipython</span></tt> apply other prompts, but in this text
we always apply <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> for interactive Python computing).
Apart from the order of the powers, the computed formula is easily
recognized as the beginning of the Taylor series for <span class="math">\(e^{-p}\)</span>.</p>
<p>Let us define the numerical amplification factor where <span class="math">\(p\)</span> and <span class="math">\(\theta\)</span>
enter the formula as symbols:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>To work with the factor for the Backward Euler scheme we
can substitute the value 1 for <tt class="docutils literal"><span class="pre">theta</span></tt>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we can replace <tt class="docutils literal"><span class="pre">theta</span></tt> by 1/2 for Crank-Nicolson,
preferably using an exact rational representation of 1/2 in <tt class="docutils literal"><span class="pre">sympy</span></tt>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">half</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
<span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The Taylor series of the amplification factor for the Crank-Nicolson
scheme can be computed as</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>We are now in a position to compare Taylor series:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span>
<span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>From these expressions we see that the error <span class="math">\(A-{A_{\small\mbox{e}}}\sim {\mathcal{O}(p^2)}\)</span>
for the Forward and Backward Euler schemes, while
<span class="math">\(A-{A_{\small\mbox{e}}}\sim {\mathcal{O}(p^3)}\)</span> for the Crank-Nicolson scheme.
It is the <em>leading order term</em>,
i.e., the term of the lowest order (polynomial degree),
that is of interest, because as <span class="math">\(p\rightarrow 0\)</span>, this term is
(much) bigger than the higher-order terms (think of <span class="math">\(p=0.01\)</span>:
<span class="math">\(p\)</span> is a hundred times larger than <span class="math">\(p^2\)</span>).</p>
<p>Now, <span class="math">\(a\)</span> is a given parameter in the problem, while <span class="math">\(\Delta t\)</span> is
what we can vary. One therefore usually writes the error expressions in
terms <span class="math">\(\Delta t\)</span>. When then have</p>
<div class="math">
\[\begin{split}A-{A_{\small\mbox{e}}} = \left\lbrace\begin{array}{ll}
{\mathcal{O}(\Delta t^2)}, &amp; \hbox{Forward and Backward Euler},\\
{\mathcal{O}(\Delta t^3)}, &amp; \hbox{Crank-Nicolson}
\end{array}\right.\end{split}\]</div>
<p>We say that the Crank-Nicolson scheme has an error in the amplification
factor of order <span class="math">\(\Delta t^3\)</span>, while the two other schemes are
of order <span class="math">\(\Delta t^2\)</span> in the same quantity.
What is the significance of the order expression? If we halve <span class="math">\(\Delta t\)</span>,
the error in amplification factor at a time level will be reduced
by a factor of 4 in the Forward and Backward Euler schemes, and by
a factor of 8 in the Crank-Nicolson scheme. That is, as we
reduce <span class="math">\(\Delta t\)</span> to obtain more accurate results, the Crank-Nicolson
scheme reduces the error more efficiently than the other schemes.</p>
</div>
<div class="section" id="the-fraction-of-numerical-and-exact-amplification-factors">
<h3>The fraction of numerical and exact amplification factors<a class="headerlink" href="#the-fraction-of-numerical-and-exact-amplification-factors" title="Permalink to this headline">¶</a></h3>
<p id="index-58">An alternative comparison of the schemes is to look at the
ratio <span class="math">\(A/{A_{\small\mbox{e}}}\)</span>, or the error <span class="math">\(1-A/{A_{\small\mbox{e}}}\)</span> in this ratio:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span>
<span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The leading-order terms have the same powers as
in the analysis of <span class="math">\(A-{A_{\small\mbox{e}}}\)</span>.</p>
</div>
<div class="section" id="the-global-error-at-a-point">
<span id="decay-analysis-gobal-error"></span><h3>The global error at a point<a class="headerlink" href="#the-global-error-at-a-point" title="Permalink to this headline">¶</a></h3>
<p id="index-59">The error in the amplification factor reflects the error when
progressing from time level <span class="math">\(t_n\)</span> to <span class="math">\(t_{n-1}\)</span>.
To investigate the real error at a point, known as the <em>global error</em>,
we look at <span class="math">\(e^n = u^n-{u_{\small\mbox{e}}}(t_n)\)</span> for some <span class="math">\(n\)</span> and Taylor expand the
mathematical expressions as functions of <span class="math">\(p=a\Delta t\)</span>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u_e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u_n</span> <span class="o">=</span> <span class="n">A</span><span class="o">**</span><span class="n">n</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">FE</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BE</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">CN</span>
<span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>For a fixed time <span class="math">\(t\)</span>, the parameter <span class="math">\(n\)</span> in these expressions increases
as <span class="math">\(p\rightarrow 0\)</span> since <span class="math">\(t=n\Delta t =\mbox{const}\)</span> and hence
<span class="math">\(n\)</span> must increase like <span class="math">\(\Delta t^{-1}\)</span>. With <span class="math">\(n\)</span> substituted by
<span class="math">\(t/\Delta t\)</span> in
the leading-order error terms, these become <span class="math">\(\frac{1}{2} na^2\Delta
t^2 = {\frac{1}{2}}ta^2\Delta t\)</span> for the Forward and Backward Euler
scheme, and <span class="math">\(\frac{1}{12}na^3\Delta t^3 = \frac{1}{12}ta^3\Delta t^2\)</span>
for the Crank-Nicolson scheme.  The global error is therefore of
second order (in <span class="math">\(\Delta t\)</span>) for the latter scheme and of first order for
the former schemes.</p>
<p>When the global error <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>,
we say that the scheme is <em>convergent</em>. It means that the numerical
solution approaches the exact solution as the mesh is refined, and
this is a much desired property of a numerical method.</p>
</div>
<div class="section" id="integrated-errors">
<h3>Integrated errors<a class="headerlink" href="#integrated-errors" title="Permalink to this headline">¶</a></h3>
<p>It is common to study the norm of the numerical error, as
explained in detail in the section <a class="reference internal" href="#decay-computing-error-norm"><em>Computing the norm of the numerical error</em></a>.
The <span class="math">\(L^2\)</span> norm can be computed by treating <span class="math">\(e^n\)</span> as a function
of <span class="math">\(t\)</span> in <tt class="docutils literal"><span class="pre">sympy</span></tt> and performing symbolic integration. For
the Forward Euler scheme we have</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;p n a dt t T &#39;</span><span class="n">theta</span><span class="s">&#39;)</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="n">u_n</span> <span class="o">=</span> <span class="n">A</span><span class="o">**</span><span class="n">n</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c"># Introduce t and dt instead of n and p</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="s">&#39;t/dt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&#39;a*dt&#39;</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="c"># study only the first term</span>
<span class="k">print</span> <span class="n">error</span>
<span class="n">error_L2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">error</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">)))</span>
<span class="k">print</span> <span class="n">error_L2</span>
</pre></div>
</div>
<p>The output reads</p>
<div class="highlight-text"><div class="highlight"><pre>sqrt(30)*sqrt(T**3*a**4*dt**2*(6*T**2*a**2 - 15*T*a + 10))/60
</pre></div>
</div>
<p>which means that the <span class="math">\(L^2\)</span> error behaves like <span class="math">\(a^2\Delta t\)</span>.</p>
<p>Strictly speaking, the numerical error is only defined at the
mesh points so it makes most sense to compute the
<span class="math">\(\ell^2\)</span> error</p>
<div class="math">
\[||e^n||_{\ell^2} = \sqrt{\Delta t\sum_{n=0}^{N_t} ({{u_{\small\mbox{e}}}}(t_n) - u^n)^2}
{\thinspace .}\]</div>
<p>We have obtained an exact analytical expressions for the error at <span class="math">\(t=t_n\)</span>,
but here we use the leading-order error term only since we are mostly
interested in how the error behaves as a polynomial in <span class="math">\(\Delta t\)</span>, and then
the leading order term will dominate.
For the Forward Euler scheme,
<span class="math">\({u_{\small\mbox{e}}}(t_n) - u^n \approx {\frac{1}{2}}np^2\)</span>, and we have</p>
<div class="math">
\[||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{4}n^2p^4
=\Delta t\frac{1}{4}p^4 \sum_{n=0}^{N_t} n^2{\thinspace .}\]</div>
<p>Now, <span class="math">\(\sum_{n=0}^{N_t} n^2\approx \frac{1}{3}N_t^3\)</span>. Using this approximation,
setting <span class="math">\(N_t =T/\Delta t\)</span>, and taking the square root gives the expression</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{2}\sqrt{\frac{T^3}{3}} a^2\Delta t{\thinspace .}\]</div>
<p>Calculations for the Backward Euler scheme are very similar and provide
the same result, while the Crank-Nicolson scheme leads to</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{12}\sqrt{\frac{T^3}{3}}a^3\Delta t^2{\thinspace .}\]</div>
<div class="admonition-summary-of-errors admonition">
<p class="first admonition-title">Summary of errors</p>
<p class="last">Both the point-wise and the time-integrated true errors are of
second order in <span class="math">\(\Delta t\)</span> for the Crank-Nicolson scheme and of
first order in <span class="math">\(\Delta t\)</span> for the Forward Euler and Backward Euler schemes.</p>
</div>
</div>
<div class="section" id="truncation-error">
<h3>Truncation error<a class="headerlink" href="#truncation-error" title="Permalink to this headline">¶</a></h3>
<p>The truncation error is a very frequently used error measure for
finite difference methods. It is defined as <em>the error
in the difference equation that arises when inserting the exact
solution</em>. Contrary to many other error measures, e.g., the
true error <span class="math">\(e^n={u_{\small\mbox{e}}}(t_n)-u^n\)</span>, the truncation error is a quantity that
is easily computable.</p>
<p>Let us illustrate the calculation of the truncation error
for the Forward Euler scheme.
We start with the difference equation on operator form,</p>
<div class="math">
\[\lbrack D_t u = -au\rbrack^n,\]</div>
<p>i.e.,</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} = -au^n{\thinspace .}\]</div>
<p>The idea is to see how well the exact solution <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> fulfills
this equation. Since <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> in general will not obey the
discrete equation, error in the discrete equation, called
a <em>residual</em>, denoted here by <span class="math">\(R^n\)</span>:</p>
<div class="math" id="equation-decay:analysis:trunc:Req">
<span class="eqno">(43)</span>\[     R^n = \frac{{u_{\small\mbox{e}}}(t_{n+1})-{u_{\small\mbox{e}}}(t_n)}{\Delta t} + a{u_{\small\mbox{e}}}(t_n)
     {\thinspace .}\]</div>
<p>The residual is defined at each mesh point and is therefore a mesh
function with a superscript <span class="math">\(n\)</span>.</p>
<p>The interesting feature of <span class="math">\(R^n\)</span> is to see how it
depends on the discretization parameter <span class="math">\(\Delta t\)</span>.
The tool for reaching
this goal is to Taylor expand <span class="math">\({u_{\small\mbox{e}}}\)</span> around the point where the
difference equation is supposed to hold, here <span class="math">\(t=t_n\)</span>.
We have that</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t_{n+1}) = {u_{\small\mbox{e}}}(t_n) + {u_{\small\mbox{e}}}'(t_n)\Delta t + \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)
\Delta t^2 + \cdots\]</div>
<p>Inserting this Taylor series in <a href="#equation-decay:analysis:trunc:Req">(43)</a> gives</p>
<div class="math">
\[R^n = {u_{\small\mbox{e}}}'(t_n) + \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + \ldots + a{u_{\small\mbox{e}}}(t_n){\thinspace .}\]</div>
<p>Now, <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the ODE <span class="math">\({u_{\small\mbox{e}}}'=-a{u_{\small\mbox{e}}}\)</span> such that the first and last
term cancels and we have</p>
<div class="math">
\[R^n \approx \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t {\thinspace .}\]</div>
<p>This <span class="math">\(R^n\)</span> is the <em>truncation error</em>, which for the Forward Euler is seen
to be of first order in <span class="math">\(\Delta t\)</span>.</p>
<p>The above procedure can be repeated for the Backward Euler and the
Crank-Nicolson schemes. We start with the scheme in operator notation,
write it out in detail, Taylor expand <span class="math">\({u_{\small\mbox{e}}}\)</span> around the point <span class="math">\(\tilde t\)</span>
at which the difference equation is defined, collect terms that
correspond to the ODE (here <span class="math">\({u_{\small\mbox{e}}}' + a{u_{\small\mbox{e}}}\)</span>), and identify the remaining
terms as the residual <span class="math">\(R\)</span>, which is the truncation error.
The Backward Euler scheme leads to</p>
<div class="math">
\[R^n \approx -\frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t,\]</div>
<p>while the Crank-Nicolson scheme gives</p>
<div class="math">
\[R^{n+\frac{1}{2}} \approx \frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})\Delta t^2{\thinspace .}\]</div>
<p>The <em>order</em> <span class="math">\(r\)</span> of a finite difference scheme is often defined through
the leading term <span class="math">\(\Delta t^r\)</span> in the truncation error. The above
expressions point out that the Forward and Backward Euler schemes are
of first order, while Crank-Nicolson is of second order.  We have
looked at other error measures in other sections, like the error in
amplification factor and the error <span class="math">\(e^n={u_{\small\mbox{e}}}(t_n)-u^n\)</span>, and expressed
these error measures in terms of <span class="math">\(\Delta t\)</span> to see the order of the
method. Normally, calculating the truncation error is more
straightforward than deriving the expressions for other error measures
and therefore the easiest way to establish the order of a scheme.</p>
</div>
<div class="section" id="consistency-stability-and-convergence">
<h3>Consistency, stability, and convergence<a class="headerlink" href="#consistency-stability-and-convergence" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-60"></span><span class="target" id="index-61"></span><p id="index-62">Three fundamental concepts when solving differential equations by
numerical methods are consistency, stability, and convergence.  We
shall briefly touch these concepts below in the context of the present
model problem.</p>
<p>Consistency means that the error in the difference equation, measured
through the truncation error, goes to zero as <span class="math">\(\Delta t\rightarrow
0\)</span>. Since the truncation error tells how well the exact solution
fulfills the difference equation, and the exact solution fulfills the
differential equation, consistency ensures that the difference
equation approaches the differential equation in the limit. The
expressions for the truncation errors in the previous section are all
proportional to <span class="math">\(\Delta t\)</span> or <span class="math">\(\Delta t^2\)</span>, hence they vanish as
<span class="math">\(\Delta t\rightarrow 0\)</span>, and all the schemes are consistent.  Lack of
consistency implies that we actually solve a different differential
equation in the limit <span class="math">\(\Delta t\rightarrow 0\)</span> than we aim at.</p>
<p>Stability means that the numerical solution exhibits the same
qualitative properties as the exact solution. This is obviously a
feature we want the numerical solution to have. In the present
exponential decay model, the exact solution is monotone and
decaying. An increasing numerical solution is not in accordance with
the decaying nature of the exact solution and hence unstable. We can
also say that an oscillating numerical solution lacks the property of
monotonicity of the exact solution and is also unstable. We have seen
that the Backward Euler scheme always leads to monotone and decaying
solutions, regardless of <span class="math">\(\Delta t\)</span>, and is hence stable. The Forward
Euler scheme can lead to increasing solutions and oscillating
solutions if <span class="math">\(\Delta t\)</span> is too large and is therefore unstable unless
<span class="math">\(\Delta t\)</span> is sufficiently small.  The Crank-Nicolson can never lead
to increasing solutions and has no problem to fulfill that stability
property, but it can produce oscillating solutions and is unstable in
that sense, unless <span class="math">\(\Delta t\)</span> is sufficiently small.</p>
<p>Convergence implies that the global (true) error mesh function <span class="math">\(e^n =
{u_{\small\mbox{e}}}(t_n)-u^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>. This is really
what we want: the numerical solution gets as close to the exact
solution as we request by having a sufficiently fine mesh.</p>
<p>Convergence is hard to establish theoretically, except in quite simple
problems like the present one. Stability and consistency are much
easier to calculate. A major breakthrough in the understanding of
numerical methods for differential equations came in 1956 when Lax and
Richtmeyer established equivalence between convergence on one hand and
consistency and stability on the other (the <a class="reference external" href="http://en.wikipedia.org/wiki/Lax_equivalence_theorem">Lax equivalence theorem</a>).  In practice
it meant that one can first establish that a method is stable and
consistent, and then it is automatically convergent (which is much
harder to establish).  The result holds for linear problems only, and
in the world of nonlinear differential equations the relations between
consistency, stability, and convergence are much more complicated.</p>
<p>We have seen in the previous analysis that the Forward Euler,
Backward Euler, and Crank-Nicolson schemes are convergent (<span class="math">\(e^n\rightarrow 0\)</span>),
that they are consistent (<span class="math">\(R^n\rightarrow 0\)</span>, and that they are
stable under certain conditions on the size of <span class="math">\(\Delta t\)</span>.
We have also derived explicit mathematical expressions for <span class="math">\(e^n\)</span>,
the truncation error, and the stability criteria.</p>
</div>
</div>
<div class="section" id="exercises-1">
<h2>Exercises  (1)<a class="headerlink" href="#exercises-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-1-visualize-the-accuracy-of-finite-differences">
<span id="decay-analysis-exer-fd-exp-plot"></span><h3>Exercise 1: Visualize the accuracy of finite differences<a class="headerlink" href="#exercise-1-visualize-the-accuracy-of-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to visualize the accuracy of finite difference
approximations of the derivative of a given function.
For any finite difference approximation, take the Forward Euler difference
as an example, and any specific function, take  <span class="math">\(u=e^{-at}\)</span>,
we may introduce an error fraction</p>
<div class="math">
\[E = \frac{[D_t^+ u]^n}{u'(t_n)} = \frac{\exp{(-a(t_n+\Delta t))} - \exp{(-at_n)}}{-a\exp{(-at_n)\Delta t}} = \frac{1}{a\Delta t}\left(1 -\exp{(-a\Delta t)}\right),\]</div>
<p>and view <span class="math">\(E\)</span> as a function of <span class="math">\(\Delta t\)</span>. We expect that
<span class="math">\(\lim_{\Delta t\rightarrow 0}E=1\)</span>, while <span class="math">\(E\)</span> may deviate significantly from
unity for large <span class="math">\(\Delta t\)</span>. How the error depends on <span class="math">\(\Delta t\)</span> is best
visualized in a graph where we use a logarithmic scale for <span class="math">\(\Delta t\)</span>,
so we can cover many orders of magnitude of that quantity. Here is
a code segment creating an array of 100 intervals, on the logarithmic
scale, ranging from <span class="math">\(10^{-6}\)</span> to <span class="math">\(10^{-0.5}\)</span> and then plotting <span class="math">\(E\)</span> versus
<span class="math">\(p=a\Delta t\)</span> with logarithmic scale on the <span class="math">\(p\)</span> axis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">logspace</span><span class="p">,</span> <span class="n">exp</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">semilogx</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span><span class="o">/</span><span class="n">p</span>
<span class="n">semilogx</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Illustrate such errors for the finite difference operators <span class="math">\([D_t^+u]^n\)</span>
(forward), <span class="math">\([D_t^-u]^n\)</span> (backward), and <span class="math">\([D_t u]^n\)</span> (centered) in
the same plot.</p>
<p>Perform a Taylor series expansions of the error fractions and find
the leading order <span class="math">\(r\)</span> in the expressions of type
<span class="math">\(1 + Cp^r + {\mathcal{O}(p^{r+1)}}\)</span>, where <span class="math">\(C\)</span> is some constant.</p>
<p><strong>Hint.</strong>
To save manual calculations and learn more about symbolic computing,
make functions for the three difference operators and use <tt class="docutils literal"><span class="pre">sympy</span></tt>
to perform the symbolic differences, differentiation, and Taylor series
expansion. To plot a symbolic expression <tt class="docutils literal"><span class="pre">E</span></tt> against <tt class="docutils literal"><span class="pre">p</span></tt>, convert the
expression to a Python function first: <tt class="docutils literal"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">sympy.lamdify([p],</span> <span class="pre">E)</span></tt>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">decay_plot_fd_error.py</span></tt>.</p>
</div>
<div class="section" id="exercise-2-explore-the-rule-for-exponential-growth">
<span id="decay-analysis-exer-growth"></span><h3>Exercise 2: Explore the <span class="math">\(\theta\)</span>-rule for exponential growth<a class="headerlink" href="#exercise-2-explore-the-rule-for-exponential-growth" title="Permalink to this headline">¶</a></h3>
<p>This exercise asks you to solve the ODE <span class="math">\(u'=-au\)</span> with <span class="math">\(a&lt;0\)</span> such that
the ODE models exponential growth instead of exponential decay.  A
central theme is to investigate numerical artifacts and non-physical
solution behavior.</p>
<p><strong>a)</strong>
Set <span class="math">\(a=-1\)</span> and run experiments with <span class="math">\(\theta=0, 0.5, 1\)</span> for
various values of <span class="math">\(\Delta t\)</span> to uncover numerical artifacts.
Recall that the exact solution is a
monotone, growing function when <span class="math">\(a&lt;0\)</span>. Oscillations or significantly
wrong growth are signs of wrong qualitative behavior.</p>
<p>From the experiments, select four values of <span class="math">\(\Delta t\)</span> that
demonstrate the kind of numerical solutions that are characteristic
for this model.
Filename: <tt class="docutils literal"><span class="pre">growth_demo.py</span></tt>.</p>
<p><strong>b)</strong>
Write up the amplification factor and plot it for <span class="math">\(\theta=0,0.5,1\)</span>
together with the exact one for <span class="math">\(a\Delta t &lt;0\)</span>. Use the plot to
explain the observations made in the experiments.</p>
<p><strong>Hint.</strong>
Modify the <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_ampf_plot.py">decay_ampf_plot.py</a> code.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">growth_ampf_plot.py</span></tt>.</p>
</div>
</div>
<div class="section" id="model-extensions">
<h2>Model extensions<a class="headerlink" href="#model-extensions" title="Permalink to this headline">¶</a></h2>
<p>It is time to consider generalizations of the simple decay model
<span class="math">\(u=-au\)</span> and also to look at additional numerical solution methods.</p>
<div class="section" id="generalization-including-a-variable-coefficient">
<h3>Generalization: including a variable coefficient<a class="headerlink" href="#generalization-including-a-variable-coefficient" title="Permalink to this headline">¶</a></h3>
<p>In the ODE for decay, <span class="math">\(u'=-au\)</span>, we now consider the case where <span class="math">\(a\)</span>
depends on time:</p>
<div class="math" id="equation-decay:problem:a">
<span class="eqno">(44)</span>\[     u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I {\thinspace .}\]</div>
<p>A Forward Euler scheme consist of evaluating <a href="#equation-decay:problem:a">(44)</a>
at <span class="math">\(t=t_n\)</span> and approximating the derivative with a forward
difference <span class="math">\([D^+_t u]^n\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
{\thinspace .}\]</div>
<p>The Backward Euler scheme becomes</p>
<div class="math">
\[\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
{\thinspace .}\]</div>
<p>The Crank-Nicolson method builds on sampling the ODE at
<span class="math">\(t_{n+\frac{1}{2}}\)</span>. We can evaluate <span class="math">\(a\)</span> at <span class="math">\(t_{n+\frac{1}{2}}\)</span>
and use an average for <span class="math">\(u\)</span> at
times <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\frac{1}{2}})\frac{1}{2}(u^n + u^{n+1})
{\thinspace .}\]</div>
<p>Alternatively, we can use an average for the product <span class="math">\(au\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -\frac{1}{2}(a(t_n)u^n + a(t_{n+1})u^{n+1})
{\thinspace .}\]</div>
<p>The <span class="math">\(\theta\)</span>-rule unifies the three mentioned schemes. One version is to
have <span class="math">\(a\)</span> evaluated at <span class="math">\(t_{n+\theta}\)</span>,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
{\thinspace .}\]</div>
<p>Another possibility is to apply a weighted average for the product <span class="math">\(au\)</span>,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
{\thinspace .}\]</div>
<p>With the finite difference operator notation the Forward Euler and Backward
Euler schemes can be summarized as</p>
<div class="math">
\[\lbrack D^+_t u = -au\rbrack^n,\]</div>
<div class="math">
\[\lbrack D^-_t u = -au\rbrack^n
{\thinspace .}\]</div>
<p>The Crank-Nicolson and <span class="math">\(\theta\)</span> schemes depend on whether we evaluate
<span class="math">\(a\)</span> at the sample point for the ODE or if we use an average. The
various versions are written as</p>
<div class="math">
\[\lbrack D_t u = -a\overline{u}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u = -\overline{au}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u = -a\overline{u}^{t,\theta}\rbrack^{n+\theta},\]</div>
<div class="math">
\[\lbrack D_t u = -\overline{au}^{t,\theta}\rbrack^{n+\theta}
{\thinspace .}\]</div>
</div>
<div class="section" id="generalization-including-a-source-term">
<span id="decay-source"></span><h3>Generalization: including a source term<a class="headerlink" href="#generalization-including-a-source-term" title="Permalink to this headline">¶</a></h3>
<p>A further extension of the model ODE is to include a source term <span class="math">\(b(t)\)</span>:</p>
<div class="math" id="equation-decay:problem:ab">
<span class="eqno">(45)</span>\[     u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
     {\thinspace .}\]</div>
<div class="section" id="schemes">
<h4>Schemes<a class="headerlink" href="#schemes" title="Permalink to this headline">¶</a></h4>
<p>The time point where we sample the ODE determines where <span class="math">\(b(t)\)</span> is
evaluated. For the Crank-Nicolson scheme and the <span class="math">\(\theta\)</span>-rule we
have a choice of whether to evaluate <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> at the
correct point or use an average. The chosen strategy becomes
particularly clear if we write up the schemes in the operator notation:</p>
<div class="math">
\[\lbrack D^+_t u = -au + b\rbrack^n,\]</div>
<div class="math">
\[\lbrack D^-_t u = -au + b\rbrack^n,\]</div>
<div class="math">
\[\lbrack D_t u   = -a\overline{u}^t + b\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u   = \overline{-au+b}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u   = -a\overline{u}^{t,\theta} + b\rbrack^{n+\theta},\]</div>
<div class="math" id="equation-decay:problem:ab:theta:avg:all:op">
<span class="eqno">(46)</span>\[     \lbrack D_t u   = \overline{-au+b}^{t,\theta}\rbrack^{n+\theta}\]\[     {\thinspace .}\]</div>
</div>
</div>
<div class="section" id="implementation-of-the-generalized-model-problem">
<span id="decay-general"></span><h3>Implementation of the generalized model problem<a class="headerlink" href="#implementation-of-the-generalized-model-problem" title="Permalink to this headline">¶</a></h3>
<div class="section" id="deriving-the-rule-formula">
<h4>Deriving the <span class="math">\(\theta\)</span>-rule formula<a class="headerlink" href="#deriving-the-rule-formula" title="Permalink to this headline">¶</a></h4>
<p>Writing out the <span class="math">\(\theta\)</span>-rule in <a href="#equation-decay:problem:ab:theta:avg:all:op">(46)</a>,
using <a href="#equation-decay:fd1:Du:theta">(28)</a>
and <a href="#equation-decay:fd1:wmean:a">(29)</a>, we get</p>
<div class="math" id="equation-decay:problem:ab:theta:avg:all">
<span class="eqno">(47)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = \theta(-a^{n+1}u^{n+1} + b^{n+1}))
     + (1-\theta)(-a^nu^{n} + b^n)),\]</div>
<p>where <span class="math">\(a^n\)</span> means evaluating <span class="math">\(a\)</span> at <span class="math">\(t=t_n\)</span> and similar for
<span class="math">\(a^{n+1}\)</span>, <span class="math">\(b^n\)</span>, and <span class="math">\(b^{n+1}\)</span>.
We solve for <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
{\thinspace .}\]</div>
</div>
<div class="section" id="the-python-code">
<h4>The Python code<a class="headerlink" href="#the-python-code" title="Permalink to this headline">¶</a></h4>
<p>Here is a suitable implementation of <a href="#equation-decay:problem:ab:theta:avg:all">(47)</a>
where <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> are given as
Python functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span class="sd">    for t in (0,T] with steps of dt.</span>
<span class="sd">    a and b are Python functions of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
                  <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                  <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This function is found in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_vc.py">decay_vc.py</a> (<tt class="docutils literal"><span class="pre">vc</span></tt> stands for &#8220;variable coefficients&#8221;).</p>
</div>
<div class="section" id="coding-of-variable-coefficients">
<h4>Coding of variable coefficients<a class="headerlink" href="#coding-of-variable-coefficients" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function shown above demands the arguments <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> to
be Python functions of time <tt class="docutils literal"><span class="pre">t</span></tt>, say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">a(t)</span></tt> has three parameters <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">tp</span></tt>, and <tt class="docutils literal"><span class="pre">k</span></tt>,
which must be global variables.
A better implementation is to represent <tt class="docutils literal"><span class="pre">a</span></tt> by a class where the
parameters are attributes and a <em>special method</em> <tt class="docutils literal"><span class="pre">__call__</span></tt> evaluates <span class="math">\(a(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">a0</span><span class="p">,</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a0</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">a0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># a behaves as a function a(t)</span>
</pre></div>
</div>
<p id="index-63">For quick tests it is cumbersome to write a complete function or a class.
The <em>lambda function</em> construction in Python is then convenient. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>
</pre></div>
</div>
<p>is equivalent to the <tt class="docutils literal"><span class="pre">def</span> <span class="pre">a(t):</span></tt> definition above. In general,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">:</span> <span class="n">expressin</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</pre></div>
</div>
<p>One can use lambda functions directly in calls. Say we want to
solve <span class="math">\(u'=-u+1\)</span>, <span class="math">\(u(0)=2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>A lambda function can appear anywhere where a variable can appear.</p>
</div>
</div>
<div class="section" id="verifying-a-constant-solution">
<span id="decay-verify-trivial"></span><h3>Verifying a constant solution<a class="headerlink" href="#verifying-a-constant-solution" title="Permalink to this headline">¶</a></h3>
<p>A very useful partial verification method is to construct a test
problem with a very simple solution, usually <span class="math">\(u=\hbox{const}\)</span>.
Especially the initial debugging of a program code can benefit greatly
from such tests, because 1) all relevant numerical methods will
exactly reproduce a constant solution, 2) many of the intermediate
calculations are easy to control for a constant <span class="math">\(u\)</span>, and 3) even a
constant <span class="math">\(u\)</span> can uncover many bugs in an implementation.</p>
<p>The only constant solution for the problem <span class="math">\(u'=-au\)</span> is <span class="math">\(u=0\)</span>, but too
many bugs can escape from that trivial solution.  It is much better to
search for a problem where <span class="math">\(u=C=\hbox{const}\neq 0\)</span>.  Then <span class="math">\(u'=-a(t)u
+ b(t)\)</span> is more appropriate: with <span class="math">\(u=C\)</span> we can choose any <span class="math">\(a(t)\)</span> and
set <span class="math">\(b=a(t)C\)</span> and <span class="math">\(I=C\)</span>. An appropriate test function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_constant_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=u_const is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u_const</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u_const</span>

    <span class="n">u_const</span> <span class="o">=</span> <span class="mf">2.15</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="n">u_const</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># enough with a few steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">u</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>An interesting question is what type of bugs that will make the
computed <span class="math">\(u^n\)</span> deviate from the exact solution <span class="math">\(C\)</span>.
Fortunately, the updating formula and the initial condition must
be absolutely correct for the test to pass! Any attempt to make
a wrong indexing in terms like <tt class="docutils literal"><span class="pre">a(t[n])</span></tt> or any attempt to
introduce an erroneous factor in the formula creates a solution
that is different from <span class="math">\(C\)</span>.</p>
</div>
<div class="section" id="verification-via-manufactured-solutions">
<span id="decay-mms"></span><h3>Verification via manufactured solutions<a class="headerlink" href="#verification-via-manufactured-solutions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-64"></span><p id="index-65">Following the idea of the previous section, we can choose any formula
as the exact solution, insert the formula in the ODE problem and fit
the data <span class="math">\(a(t)\)</span>, <span class="math">\(b(t)\)</span>, and <span class="math">\(I\)</span> to make the chosen
formula fulfill the equation. This
powerful technique for generating exact solutions is very useful for
verification purposes and known as the <em>method of manufactured
solutions</em>, often abbreviated MMS.</p>
<p>One common choice of solution is a linear function in the independent
variable(s). The rationale behind such a simple variation is that
almost any relevant numerical solution method for differential
equation problems is able to reproduce the linear function exactly to
machine precision (if <span class="math">\(u\)</span> is about unity in size; precision is lost if
<span class="math">\(u\)</span> take on large values, see <a class="reference internal" href="#decay-fd2-exer-precision"><em>Exercise 3: Experiment with precision in tests and the size of </em></a>).
The linear solution also makes some stronger demands to the
numerical method and the implementation than the constant solution
used in the section <a class="reference internal" href="#decay-verify-trivial"><em>Verifying a constant solution</em></a>, at least in more
complicated applications. However, the constant solution is often
ideal for initial debugging before proceeding with a linear solution.</p>
<p>We choose a linear solution <span class="math">\(u(t) = ct + d\)</span>. From the initial condition it
follows that <span class="math">\(d=I\)</span>.
Inserting this <span class="math">\(u\)</span> in the ODE results in</p>
<div class="math">
\[c = -a(t)u + b(t) {\thinspace .}\]</div>
<p>Any function <span class="math">\(u=ct+I\)</span> is then a correct solution if we choose</p>
<div class="math">
\[b(t) = c + a(t)(ct + I) {\thinspace .}\]</div>
<p>With this <span class="math">\(b(t)\)</span> there are no restrictions on <span class="math">\(a(t)\)</span> and <span class="math">\(c\)</span>.</p>
<p>Let prove that such a linear solution obeys the numerical
schemes. To this end, we must check that <span class="math">\(u^n = ca(t_n)(ct_n+I)\)</span>
fulfills the discrete equations. For these calculations, and
later calculations involving linear solutions inserted in
finite difference schemes, it is convenient to
compute the action of a difference operator on a linear function <span class="math">\(t\)</span>:</p>
<div class="math" id="equation-decay:fd2:Dop:tn:fw">
<span class="eqno">(48)</span>\[     \lbrack D_t^+ t\rbrack^n = \frac{t_{n+1}-t_n}{\Delta t}=1,\]</div>
<div class="math" id="equation-decay:fd2:Dop:tn:bw">
<span class="eqno">(49)</span>\[     \lbrack D_t^- t\rbrack^n = \frac{t_{n}-t_{n-1}}{\Delta t}=1,\]</div>
<div class="math" id="equation-decay:fd2:Dop:tn:cn">
<span class="eqno">(50)</span>\[     \lbrack D_t t\rbrack^n = \frac{t_{n+\frac{1}{2}}-t_{n-\frac{1}{2}}}{\Delta t}=\frac{(n+\frac{1}{2})\Delta t - (n-\frac{1}{2})\Delta t}{\Delta t}=1\]\[     {\thinspace .}\]</div>
<p>Clearly, all three finite difference approximations to the derivative are
exact for <span class="math">\(u(t)=t\)</span> or its mesh function counterpart <span class="math">\(u^n = t_n\)</span>.</p>
<p>The difference equation for the Forward Euler scheme</p>
<div class="math">
\[[D^+_t u = -au + b]^n,\]</div>
<p>with <span class="math">\(a^n=a(t_n)\)</span>, <span class="math">\(b^n=c + a(t_n)(ct_n + I)\)</span>, and <span class="math">\(u^n=ct_n + I\)</span>
then results in</p>
<div class="math">
\[c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c\]</div>
<p>which is always fulfilled. Similar calculations can be done for the
Backward Euler and Crank-Nicolson schemes, or the <span class="math">\(\theta\)</span>-rule for
that matter. In all cases, <span class="math">\(u^n=ct_n +I\)</span> is an exact solution of
the discrete equations. That is why we should expect that
<span class="math">\(u^n - {u_{\small\mbox{e}}}(t_n) =0\)</span> mathematically and <span class="math">\(|u^n - {u_{\small\mbox{e}}}(t_n)|\)</span> less
than a small number about the machine precision for <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<p>The following function offers an implementation of this verification
test based on a linear exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_linear_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=c*t+I is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">**</span><span class="mf">0.5</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="k">print</span> <span class="n">difference</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>  <span class="c"># depends on c!</span>
    <span class="k">assert</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Any error in the updating formula makes this test fail!</p>
<p>Choosing more complicated formulas as the exact solution, say
<span class="math">\(\cos(t)\)</span>, will not make the numerical and exact solution
coincide to machine precision, because finite differencing of
<span class="math">\(\cos(t)\)</span> does not exactly yield the exact derivative <span class="math">\(-\sin(t)\)</span>.
In such cases, the verification procedure
must be based on measuring the convergence rates as exemplified in
the section <em class="xref std std-ref">decay:convergence:rate</em>. Convergence rates can be
computed as long as one has
an exact solution of a problem that the solver can be tested on, but
this can always be obtained by the method of manufactured solutions.</p>
</div>
<div class="section" id="extension-to-systems-of-odes">
<h3>Extension to systems of ODEs<a class="headerlink" href="#extension-to-systems-of-odes" title="Permalink to this headline">¶</a></h3>
<p>Many ODE models involves more than one unknown function and more
than one equation. Here is an example of two unknown functions <span class="math">\(u(t)\)</span>
and <span class="math">\(v(t)\)</span>:</p>
<div class="math">
\[u' = a u + bv,\]</div>
<div class="math">
\[v' = cu +  dv,\]</div>
<p>for constants <span class="math">\(a,b,c,d\)</span>.
Applying the Forward Euler method to each equation results in simple
updating formula</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t (a u^n + b v^n),\]</div>
<div class="math">
\[v^{n+1} = u^n + \Delta t (cu^n + dv^n)
{\thinspace .}\]</div>
<p>On the other hand, the Crank-Nicolson or Backward Euler schemes result in a
<span class="math">\(2\times 2\)</span> linear system for the new unknowns. The latter schemes gives</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t (a u^{n+1} + b v^{n+1}),\]</div>
<div class="math">
\[v^{n+1} = v^n + \Delta t (c u^{n+1} + d v^{n+1}){\thinspace .}\]</div>
<p>Collecting <span class="math">\(u^{n+1}\)</span> as well as <span class="math">\(v^{n+1}\)</span> on the left-hand side results
in</p>
<div class="math">
\[(1 - \Delta t a)u^{n+1} + bv^{n+1} = u^n ,\]</div>
<div class="math">
\[c u^{n+1} + (1 - \Delta t d) v^{n+1} = v^n ,\]</div>
<p>which is a system of two coupled, linear, algebraic equations in two
unknowns.</p>
</div>
</div>
<div class="section" id="general-first-order-odes">
<h2>General first-order ODEs<a class="headerlink" href="#general-first-order-odes" title="Permalink to this headline">¶</a></h2>
<p>We now turn the attention to general, nonlinear ODEs and systems of
such ODEs.  Our focus is on numerical methods that can be readily
reused for time-discretization PDEs, and diffusion PDEs in particular.
The methods are just briefly listed, and we refer to the rich literature
for more detailed descriptions and analysis - the books
<a class="reference internal" href="#ref2" id="id2">[Ref2]</a> <a class="reference internal" href="#ref3" id="id3">[Ref3]</a> <a class="reference internal" href="#ref4" id="id4">[Ref4]</a> <a class="reference internal" href="#ref5" id="id5">[Ref5]</a> are all excellent resources on numerical methods for ODEs.
We also demonstrate the Odespy Python interface to a range
of different software for general first-order ODE systems.</p>
<div class="section" id="generic-form-of-first-order-odes">
<h3>Generic form of first-order ODEs<a class="headerlink" href="#generic-form-of-first-order-odes" title="Permalink to this headline">¶</a></h3>
<p>ODEs are commonly written in the generic form</p>
<div class="math" id="equation-decay:ode:general">
<span class="eqno">(51)</span>\[     u' = f(u,t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(f(u,t)\)</span>  is some prescribed function.
As an example, our most
general exponential decay model <a href="#equation-decay:problem:ab">(45)</a> has
<span class="math">\(f(u,t)=-a(t)u(t) + b(t)\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> in <a href="#equation-decay:ode:general">(51)</a> may either be
a scalar function of time <span class="math">\(t\)</span>, or a vector valued function of <span class="math">\(t\)</span> in
case of a <em>system of ODEs</em> with <span class="math">\(m\)</span> unknown components:</p>
<div class="math">
\[u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t)) {\thinspace .}\]</div>
<p>In that case, the right-hand side is vector-valued function with <span class="math">\(m\)</span>
components,</p>
<div class="math">
\[\begin{split}f(u, t) = ( &amp; f^{(0)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; f^{(1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; \vdots,\\
            &amp; f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
{\thinspace .}\end{split}\]</div>
<p>Actually, any system of ODEs can
be written in the form <a href="#equation-decay:ode:general">(51)</a>, but higher-order
ODEs then need auxiliary unknown functions to enable conversion to
a first-order system.</p>
<p>Next we list some well-known methods for <span class="math">\(u'=f(u,t)\)</span>, valid both for
a single ODE (scalar <span class="math">\(u\)</span>) and systems of ODEs (vector <span class="math">\(u\)</span>).
The choice of methods is inspired by the kind of schemes that are
popular also for time discretization of partial differential equations.</p>
</div>
<div class="section" id="the-rule">
<h3>The <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-rule" title="Permalink to this headline">¶</a></h3>
<p>The <span class="math">\(\theta\)</span>-rule scheme applied to <span class="math">\(u'=f(u,t)\)</span> becomes</p>
<div class="math" id="equation-decay:fd2:theta">
<span class="eqno">(52)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
     (1-\theta)f(u^n, t_n){\thinspace .}\]</div>
<p>Bringing the unknown <span class="math">\(u^{n+1}\)</span> to the left-hand side and the known terms
on the right-hand side gives</p>
<span class="target" id="index-66"></span><span class="target" id="index-67"></span><span class="target" id="index-68"></span><div class="math" id="index-69">
\[u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n){\thinspace .}\]</div>
<p>For a general <span class="math">\(f\)</span> (not linear in <span class="math">\(u\)</span>), this equation is <em>nonlinear</em> in
the unknown <span class="math">\(u^{n+1}\)</span> unless <span class="math">\(\theta = 0\)</span>. For a scalar ODE (<span class="math">\(m=1\)</span>),
we have to solve a single nonlinear algebraic equation for <span class="math">\(u^{n+1}\)</span>,
while for a system of ODEs, we get a system of coupled, nonlinear
algebraic equations. Newton&#8217;s method is a popular solution approach
in both cases. Note that with the Forward Euler scheme (<span class="math">\(\theta =0\)</span>)
we do not have to deal with nonlinear equations, because in that
case we have an explicit updating formula for <span class="math">\(u^{n+1}\)</span>. This is known
as an <em>explicit</em> scheme. With <span class="math">\(\theta\neq 1\)</span> we have to solve
(systems of) algebraic equations, and the scheme is said to be <em>implicit</em>.</p>
</div>
<div class="section" id="an-implicit-2-step-backward-scheme">
<h3>An implicit 2-step backward scheme<a class="headerlink" href="#an-implicit-2-step-backward-scheme" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-70"></span><p id="index-71">The implicit backward method with 2 steps applies a
three-level backward difference as approximation to <span class="math">\(u'(t)\)</span>,</p>
<div class="math">
\[u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t},\]</div>
<p>which is an approximation of order <span class="math">\(\Delta t^2\)</span> to the first derivative.
The resulting scheme for <span class="math">\(u'=f(u,t)\)</span> reads</p>
<div class="math" id="equation-decay:fd2:bw:2step">
<span class="eqno">(53)</span>\[     u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
     \frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
     {\thinspace .}\]</div>
<p>Higher-order versions of the scheme <a href="#equation-decay:fd2:bw:2step">(53)</a> can
be constructed by including more time levels. These schemes are known
as the Backward Differentiation Formulas (BDF), and the particular
version <a href="#equation-decay:fd2:bw:2step">(53)</a> is often referred to as BDF2.</p>
<p>Note that the scheme <a href="#equation-decay:fd2:bw:2step">(53)</a> is implicit and requires
solution of nonlinear equations when <span class="math">\(f\)</span> is nonlinear in <span class="math">\(u\)</span>.  The
standard 1st-order Backward Euler method or the Crank-Nicolson scheme
can be used for the first step.</p>
</div>
<div class="section" id="leapfrog-schemes">
<h3>Leapfrog schemes<a class="headerlink" href="#leapfrog-schemes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-ordinary-leapfrog-scheme">
<span id="index-72"></span><h4>The ordinary Leapfrog scheme<a class="headerlink" href="#the-ordinary-leapfrog-scheme" title="Permalink to this headline">¶</a></h4>
<p>The derivative of <span class="math">\(u\)</span> at some point <span class="math">\(t_n\)</span> can be approximated by
a central difference over two time steps,</p>
<div class="math">
\[u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n\]</div>
<p>which is an approximation of second order in <span class="math">\(\Delta t\)</span>. The scheme
can then be written as</p>
<div class="math">
\[[D_{2t}u=f(u,t)]^n,\]</div>
<p>in operator notation. Solving for <span class="math">\(u^{n+1}\)</span> gives</p>
<div class="math" id="equation-decay:fd2:leapfrog">
<span class="eqno">(54)</span>\[     u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
     {\thinspace .}\]</div>
<p>Observe that <a href="#equation-decay:fd2:leapfrog">(54)</a> is an explicit scheme, and that
a nonlinear <span class="math">\(f\)</span> (in <span class="math">\(u\)</span>) is trivial to handle since it only involves
the known <span class="math">\(u^n\)</span> value.
Some other scheme must be used as starter to compute <span class="math">\(u^1\)</span>, preferably
the Forward Euler scheme since it is also explicit.</p>
</div>
<div class="section" id="the-filtered-leapfrog-scheme">
<span id="index-73"></span><h4>The filtered Leapfrog scheme<a class="headerlink" href="#the-filtered-leapfrog-scheme" title="Permalink to this headline">¶</a></h4>
<p>Unfortunately, the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(54)</a>
will develop growing oscillations with time (see <a class="reference internal" href="#decay-fd2-exer-leapfrog1"><em>Problem 8: Implement and investigate the Leapfrog scheme</em></a>)[[[. A remedy for such undesired oscillations
is to introduce a <em>filtering technique</em>. First, a standard Leapfrog
step is taken, according to <a href="#equation-decay:fd2:leapfrog">(54)</a>, and then
the previous <span class="math">\(u^n\)</span> value is adjusted according to</p>
<div class="math" id="equation-decay:fd2:leapfrog:filtered">
<span class="eqno">(55)</span>\[     u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})\]\[     {\thinspace .}\]</div>
<p>The <span class="math">\(\gamma\)</span>-terms will effectively damp oscillations in the solution,
especially those with short wavelength (like point-to-point oscillations).
A common choice of <span class="math">\(\gamma\)</span> is 0.6 (a value used in the
famous NCAR Climate Model).</p>
</div>
</div>
<div class="section" id="the-2nd-order-runge-kutta-method">
<h3>The 2nd-order Runge-Kutta method<a class="headerlink" href="#the-2nd-order-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-74"></span><p id="index-75">The two-step scheme</p>
<div class="math" id="equation-decay:fd2:RK2:s1">
<span class="eqno">(56)</span>\[     u^* = u^n + \Delta t f(u^n, t_n),\]</div>
<div class="math" id="equation-decay:fd2:RK2:s2">
<span class="eqno">(57)</span>\[     u^{n+1} = u^n + \Delta t \frac{1}{2} \left( f(u^n, t_n) + f(u^*, t_{n+1})
     \right),\]</div>
<p>essentially applies a Crank-Nicolson method <a href="#equation-decay:fd2:RK2:s2">(57)</a>
to the ODE, but replaces
the term <span class="math">\(f(u^{n+1}, t_{n+1})\)</span> by a prediction
<span class="math">\(f(u^{*}, t_{n+1})\)</span> based on a Forward Euler step <a href="#equation-decay:fd2:RK2:s1">(56)</a>.
The scheme <a href="#equation-decay:fd2:RK2:s1">(56)</a>-<a href="#equation-decay:fd2:RK2:s2">(57)</a> is
known as Huen&#8217;s method, but is also a 2nd-order Runge-Kutta method.
The scheme is explicit, and the error is expected to behave as <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="a-2nd-order-taylor-series-method">
<h3>A 2nd-order Taylor-series method<a class="headerlink" href="#a-2nd-order-taylor-series-method" title="Permalink to this headline">¶</a></h3>
<p id="index-76">One way to compute <span class="math">\(u^{n+1}\)</span> given <span class="math">\(u^n\)</span> is to use a Taylor polynomial.
We may write up a polynomial of 2nd degree:</p>
<div class="math">
\[u^{n+1} = u^n + u'(t_n)\Delta t + {\frac{1}{2}}u''(t_n)\Delta t^2
{\thinspace .}\]</div>
<p>From the equation <span class="math">\(u'=f(u,t)\)</span> it follows that the derivatives of <span class="math">\(u\)</span>
can be expressed in terms of <span class="math">\(f\)</span> and its derivatives:</p>
<div class="math">
\[\begin{split}u'(t_n) &amp;=f(u^n,t_n),\\
u''(t_n) &amp;=
\frac{\partial f}{\partial u}(u^n,t_n) u'(t_n) + \frac{\partial f}{\partial t}\\
&amp;=  f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
\frac{\partial f}{\partial t},\end{split}\]</div>
<p>resulting in the scheme</p>
<div class="math" id="equation-decay:fd2:Taylor2">
<span class="eqno">(58)</span>\[     u^{n+1} = u^n + f(u^n,t_n)\Delta t + \frac{1}{2}\left(
     f(u^n,t_n)\frac{\partial f}{\partial u}(u^n,t_n)  +
     \frac{\partial f}{\partial t}\right)\Delta t^2
     {\thinspace .}\]</div>
<p>More terms in the series could be included in the Taylor polynomial to
obtain methods of higher order than 2.</p>
</div>
<div class="section" id="the-2nd-and-3rd-order-adams-bashforth-schemes">
<h3>The 2nd- and 3rd-order Adams-Bashforth schemes<a class="headerlink" href="#the-2nd-and-3rd-order-adams-bashforth-schemes" title="Permalink to this headline">¶</a></h3>
<p id="index-77">The following method is known as the 2nd-order Adams-Bashforth scheme:</p>
<div class="math" id="equation-decay:fd2:AB2">
<span class="eqno">(59)</span>\[     u^{n+1} = u^n + \frac{1}{2}\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
     \right)
     {\thinspace .}\]</div>
<p>The scheme is explicit and requires another one-step scheme to compute
<span class="math">\(u^1\)</span> (the Forward Euler scheme or Heun&#8217;s method, for instance).
As the name implies, the scheme is of order <span class="math">\(\Delta t^2\)</span>.</p>
<p id="index-78">Another explicit scheme, involving four time levels, is the
3rd-order Adams-Bashforth scheme</p>
<div class="math" id="equation-decay:fd2:AB3">
<span class="eqno">(60)</span>\[     u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
     + 5f(u^{n-2}, t_{n-2})\right)
     {\thinspace .}\]</div>
<p>The numerical error is of order <span class="math">\(\Delta t^3\)</span>, and the scheme needs
some method for computing <span class="math">\(u^1\)</span> and <span class="math">\(u^2\)</span>.</p>
<p>More general, higher-order Adams-Bashforth schemes (also called
<em>explicit Adams methods</em>) compute <span class="math">\(u^{n+1}\)</span> as a linear combination
of <span class="math">\(f\)</span> at <span class="math">\(k\)</span> previous time steps:</p>
<div class="math">
\[u^{n+1} = u^n + \sum_{j=0}^k \beta_jf(u^{n-j},t_{n-j}),\]</div>
<p>where <span class="math">\(\beta_j\)</span> are known coefficients.</p>
</div>
<div class="section" id="the-4th-order-runge-kutta-method">
<span id="decay-fd2-rk4"></span><h3>The 4th-order Runge-Kutta method<a class="headerlink" href="#the-4th-order-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-79"></span><p id="index-80">The perhaps most widely used method to solve ODEs is the 4th-order
Runge-Kutta method, often called RK4.
Its derivation is a nice illustration of common
numerical approximation strategies, so let us go through the
steps in detail.</p>
<p>The starting point is to integrate the ODE
<span class="math">\(u'=f(u,t)\)</span> from <span class="math">\(t_n\)</span> to <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[u(t_{n+1}) - u(t_n) = \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt{\thinspace .}\]</div>
<p>We want to compute <span class="math">\(u(t_{n+1})\)</span> and regard <span class="math">\(u(t_n)\)</span> as known.
The task is to find good approximations for the integral, since the
integrand involves the unknown <span class="math">\(u\)</span> between <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>.</p>
<p>The integral can be approximated by the famous
<a class="reference external" href="http://en.wikipedia.org/wiki/Simpson's_rule">Simpson&#8217;s rule</a>:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 4f^{n+\frac{1}{2}} + f^{n+1}\right){\thinspace .}\]</div>
<p>The problem now is that we do not know <span class="math">\(f^{n+\frac{1}{2}}=f(u^{n+\frac{1}{2}},t_{n+1/2})\)</span>
and <span class="math">\(f^{n+1}=(u^{n+1},t_{n+1})\)</span> as we know only <span class="math">\(u^n\)</span> and hence <span class="math">\(f^n\)</span>.
The idea is to use various approximations for <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span> based on using well-known schemes for the ODE in the
intervals <span class="math">\([t_n,t_{n+1/2}]\)</span> and <span class="math">\([t_n, t_{n+1}]\)</span>.
We split the integral approximation into four terms:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span>, <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span>, and <span class="math">\(\bar{f}^{n+1}\)</span>
are approximations to <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span> that can be based on already computed quantities.
For <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span> we can apply
an approximation to <span class="math">\(u^{n+\frac{1}{2}}\)</span> using the Forward Euler
method with step <span class="math">\(\frac{1}{2}\Delta t\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:hatf">
<span class="eqno">(61)</span>\[     \hat{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+1/2})\]</div>
<p>Since this gives us a prediction of <span class="math">\(f^{n+\frac{1}{2}}\)</span>, we can for
<span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> try a Backward Euler method to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:tildef">
<span class="eqno">(62)</span>\[     \tilde{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+1/2}){\thinspace .}\]</div>
<p>With <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> as a hopefully good approximation to
<span class="math">\(f^{n+\frac{1}{2}}\)</span>, we can for the final term <span class="math">\(\bar{f}^{n+1}\)</span> use
a Crank-Nicolson method to approximate <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:fd2:RK4:barf">
<span class="eqno">(63)</span>\[     \bar{f}^{n+1} = f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1}){\thinspace .}\]</div>
<p>We have now used the Forward and Backward Euler methods as well as the
Crank-Nicolson method in the context of Simpson&#8217;s rule. The hope is
that the combination of these methods yields an overall time-stepping
scheme from <span class="math">\(t_n\)</span> to <span class="math">\(t_n{+1}\)</span> that is much more accurate than the
<span class="math">\({\mathcal{O}(\Delta t)}\)</span> and <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> of the individual steps.
This is indeed true: the overall accuracy is <span class="math">\({\mathcal{O}(\Delta t^4)}\)</span>!</p>
<p>To summarize, the 4th-order Runge-Kutta method becomes</p>
<div class="math">
\[u^{n+1} = u^n +
\frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where the quantities on the right-hand side are computed from
<a href="#equation-decay:fd2:RK4:hatf">(61)</a>-<a href="#equation-decay:fd2:RK4:barf">(63)</a>. Note that
the scheme is fully explicit so there is never any need to solve linear or
nonlinear algebraic
equations. However, the stability is conditional and depends on <span class="math">\(f\)</span>.
There is a whole range of <em>implicit</em> Runge-Kutta methods that
are unconditionally stable, but require solution of algebraic
equations involving <span class="math">\(f\)</span> at each time step.</p>
<p>The simplest way to explore more sophisticated methods for ODEs is to
apply one of the many high-quality software packages that exist, as the
next section explains.</p>
</div>
<div class="section" id="the-odespy-software">
<h3>The Odespy software<a class="headerlink" href="#the-odespy-software" title="Permalink to this headline">¶</a></h3>
<p>A wide range of the methods and software exist for solving <a href="#equation-decay:ode:general">(51)</a>.
Many of methods are accessible through a unified Python interface offered
by the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package.
Odespy features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">ODEPACK</a>, <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">Vode</a>,
<a class="reference external" href="http://www.netlib.org/ode/rkc.f">rkc.f</a>, <a class="reference external" href="http://www.netlib.org/ode/rkf45.f">rkf45.f</a>, <a class="reference external" href="http://www.unige.ch/~hairer/software.html">Radau5</a>, as well
as the ODE solvers in <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html">SciPy</a>, <a class="reference external" href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html">SymPy</a>, and <a class="reference external" href="http://olivierverdier.github.com/odelab/">odelab</a>.</p>
<p>The usage of Odespy follows this setup for the ODE <span class="math">\(u'=-au\)</span>,
<span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0,T]\)</span>, here solved
by the famous 4th-order Runge-Kutta method, using <span class="math">\(\Delta t=1\)</span>
and <span class="math">\(N_t=6\)</span> steps:</p>
<div class="highlight-text"><div class="highlight"><pre>def f(u, t):
    return -a*u

import odespy
import numpy as np

I = 1; a = 0.5; Nt = 6; dt = 1
solver = odespy.RK4(f)
solver.set_initial_condition(I)
t_mesh = np.linspace(0, Nt*dt, Nt+1)
u, t = solver.solve(t_mesh)
</pre></div>
</div>
<p>The previously listed methods for ODEs are all accessible in
Odespy:</p>
<blockquote>
<div><ul class="simple">
<li>the <span class="math">\(\theta\)</span>-rule: <tt class="docutils literal"><span class="pre">ThetaRule</span></tt></li>
<li>special cases of the <span class="math">\(\theta\)</span>-rule: <tt class="docutils literal"><span class="pre">ForwardEuler</span></tt>, <tt class="docutils literal"><span class="pre">BackwardEuler</span></tt>,
<tt class="docutils literal"><span class="pre">CrankNicolson</span></tt></li>
<li>the 2nd- and 4th-order Runge-Kutta methods: <tt class="docutils literal"><span class="pre">RK2</span></tt> and <tt class="docutils literal"><span class="pre">RK4</span></tt></li>
<li>The BDF methods and the Adam-Bashforth methods:
<tt class="docutils literal"><span class="pre">Vode</span></tt>, <tt class="docutils literal"><span class="pre">Lsode</span></tt>, <tt class="docutils literal"><span class="pre">Lsoda</span></tt>, <tt class="docutils literal"><span class="pre">lsoda_scipy</span></tt></li>
<li>The Leapfrog scheme: <tt class="docutils literal"><span class="pre">Leapfrog</span></tt> and <tt class="docutils literal"><span class="pre">LeapfrogFiltered</span></tt></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="example-runge-kutta-methods">
<h3>Example: Runge-Kutta methods<a class="headerlink" href="#example-runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p>Since all solvers have the same interface in Odespy, modulo different set of
parameters to the solvers&#8217; constructors, one can easily make a list of
solver objects and run a loop for comparing (a lot of) solvers. The
code below, found in complete form in <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_odespy.py">decay_odespy.py</a>,
compares the famous Runge-Kutta methods of orders 2, 3, and 4
with the exact solution of the decay equation
<span class="math">\(u'=-au\)</span>.
Since we have quite long time steps, we have included the only
relevant <span class="math">\(\theta\)</span>-rule for large time steps, the Backward Euler scheme
(<span class="math">\(\theta=1\)</span>), as well.
Figure <a class="reference internal" href="#decay-odespy-fig1"><em>Behavior of different schemes for the decay equation</em></a> shows the results.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="mf">0.75</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK3</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">)]</span>

<span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c"># Compare with exact solution plotted on a very fine mesh</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t_fine</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">)</span> <span class="c"># avoid markers by specifying line type</span>
<span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;exact&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Time step: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-visualization-tip admonition">
<p class="first admonition-title">Visualization tip</p>
<p>We use SciTools for
plotting here, but importing <tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt> as <tt class="docutils literal"><span class="pre">plt</span></tt> instead
also works. However, plain use of Matplotlib as done here results in
curves with different colors, which may be hard to distinguish on
black-and-white paper. Using SciTools, curves are
automatically given colors <em>and</em> markers, thus making curves easy
to distinguish on screen with colors and on black-and-white paper.
The automatic adding of markers is normally a bad idea for a
very fine mesh since all the markers get cluttered, but SciTools limits
the number of markers in such cases.
For the exact solution we use a very fine mesh, but in the code
above we specify the line type as a solid line (<tt class="docutils literal"><span class="pre">-</span></tt>), which means
no markers and just a color to be automatically determined by
the backend used for plotting (Matplotlib by default, but
SciTools gives the opportunity to use other backends
to produce the plot, e.g., Gnuplot or Grace).</p>
<p class="last">Also note the that the legends
are based on the class names of the solvers, and in Python the name of
a the class type (as a string) of an object <tt class="docutils literal"><span class="pre">obj</span></tt> is obtained by
<tt class="docutils literal"><span class="pre">obj.__class__.__name__</span></tt>.</p>
</div>
<div class="figure" id="decay-odespy-fig1">
<a class="reference internal image-reference" href="_images/decay_odespy1_png.png"><img alt="_images/decay_odespy1_png.png" src="_images/decay_odespy1_png.png" style="width: 600px;" /></a>
<p class="caption"><em>Behavior of different schemes for the decay equation</em></p>
</div>
<p>The runs in Figure <a class="reference internal" href="#decay-odespy-fig1"><em>Behavior of different schemes for the decay equation</em></a>
and other experiments reveal that the 2nd-order Runge-Kutta
method (<tt class="docutils literal"><span class="pre">RK2</span></tt>) is unstable for <span class="math">\(\Delta t&gt;1\)</span> and decays slower than the
Backward Euler scheme for large and moderate <span class="math">\(\Delta t\)</span> (see <a class="reference internal" href="#decay-exer-rk2-taylor-analysis"><em>Exercise 7: Analyze explicit 2nd-order methods</em></a> for an analysis).  However, for
fine <span class="math">\(\Delta t = 0.25\)</span> the 2nd-order Runge-Kutta method approaches
the exact solution faster than the Backward Euler scheme.  That is,
the latter scheme does a better job for larger <span class="math">\(\Delta t\)</span>, while the
higher order scheme is superior for smaller <span class="math">\(\Delta t\)</span>. This is a
typical trend also for most schemes for ordinary and partial
differential equations.</p>
<p>The 3rd-order Runge-Kutta method (<tt class="docutils literal"><span class="pre">RK3</span></tt>) has also artifacts in form
of oscillatory behavior for the larger <span class="math">\(\Delta t\)</span> values, much
like that of the Crank-Nicolson scheme. For finer <span class="math">\(\Delta t\)</span>,
the 3rd-order Runge-Kutta method converges quickly to the exact
solution.</p>
<p>The 4th-order Runge-Kutta method (<tt class="docutils literal"><span class="pre">RK4</span></tt>) is slightly inferior
to the Backward Euler scheme on the coarsest mesh, but is then
clearly superior to all the other schemes. It is definitely the
method of choice for all the tested schemes.</p>
<div class="section" id="remark-about-using-the-rule-in-odespy">
<h4>Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy<a class="headerlink" href="#remark-about-using-the-rule-in-odespy" title="Permalink to this headline">¶</a></h4>
<p>The Odespy package assumes that the ODE is written as <span class="math">\(u'=f(u,t)\)</span> with
an <span class="math">\(f\)</span> that is possibly nonlinear in <span class="math">\(u\)</span>. The <span class="math">\(\theta\)</span>-rule for
<span class="math">\(u'=f(u,t)\)</span> leads to</p>
<div class="math">
\[u^{n+1} = u^{n} + \Delta t\left(\theta f(u^{n+1}, t_{n+1})
+ (1-\theta) f(u^{n}, t_{n})\right),\]</div>
<p>which is a <em>nonlinear equation</em> in <span class="math">\(u^{n+1}\)</span>. Odespy&#8217;s implementation
of the <span class="math">\(\theta\)</span>-rule (<tt class="docutils literal"><span class="pre">ThetaRule</span></tt>) and the specialized Backward Euler
(<tt class="docutils literal"><span class="pre">BackwardEuler</span></tt>) and Crank-Nicolson (<tt class="docutils literal"><span class="pre">CrankNicolson</span></tt>) schemes
must invoke iterative methods for
solving the nonlinear equation in <span class="math">\(u^{n+1}\)</span>. This is done even when
<span class="math">\(f\)</span> is linear in <span class="math">\(u\)</span>, as in the model problem <span class="math">\(u'=-au\)</span>, where we can
easily solve for <span class="math">\(u^{n+1}\)</span> by hand.  Therefore, we need to specify
use of Newton&#8217;s method to the equations.
(Odespy allows other methods than Newton&#8217;s to be used, for instance
Picard iteration, but that method is not suitable. The reason is that it
applies the Forward Euler scheme to generate a start value for
the iterations. Forward Euler may give very wrong solutions
for large <span class="math">\(\Delta t\)</span> values. Newton&#8217;s method, on the other hand,
is insensitive to the start value in <em>linear problems</em>.)</p>
</div>
</div>
<div class="section" id="example-adaptive-runge-kutta-methods">
<span id="decay-fd2-adaptiverk"></span><h3>Example: Adaptive Runge-Kutta methods<a class="headerlink" href="#example-adaptive-runge-kutta-methods" title="Permalink to this headline">¶</a></h3>
<p id="index-81">Odespy offers solution methods that can adapt the size of <span class="math">\(\Delta t\)</span>
with time to match a desired accuracy in the solution. Intuitively,
small time steps will be chosen in areas where the solution is changing
rapidly, while larger time steps can be used where the solution
is slowly varying. Some kind of <em>error estimator</em> is used to
adjust the next time step at each time level.</p>
<span class="target" id="index-82"></span><p id="index-83">A very popular adaptive method for solving ODEs is the Dormand-Prince
Runge-Kutta method of order 4 and 5. The 5th-order method is used as a
reference solution and the difference between the 4th- and 5th-order
methods is used as an indicator of the error in the numerical
solution.  The Dormand-Prince method is the default choice in MATLAB&#8217;s
widely used <tt class="docutils literal"><span class="pre">ode45</span></tt> routine.</p>
<p>We can easily set up Odespy to use the Dormand-Prince method and
see how it selects the optimal time steps. To this end, we request
only one time step from <span class="math">\(t=0\)</span> to <span class="math">\(t=T\)</span> and ask the method to
compute the necessary non-uniform time mesh to meet a certain
error tolerance. The code goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">decay_mod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c">#import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">DormandPrince</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>

<span class="n">Nt</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># just one step - let the scheme find its intermediate points</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>

<span class="c"># u and t will only consist of [I, u^Nt] and [0,T]</span>
<span class="c"># solver.u_all and solver.t_all contains all computed points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">u_all</span><span class="p">,</span> <span class="s">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_fine</span><span class="p">),</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;tol=</span><span class="si">%.0E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_odespy_adaptive.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Running four cases with tolerances <span class="math">\(10^{-1}\)</span>, <span class="math">\(10^{-3}\)</span>, <span class="math">\(10^{-5}\)</span>,
and <span class="math">\(10^{-7}\)</span>, gives the results in Figure <a class="reference internal" href="#decay-odespy-fig2"><em>Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</em></a>.
Intuitively, one would expect denser points in the beginning of
the decay and larger time steps when the solution flattens out.</p>
<div class="figure" id="decay-odespy-fig2">
<a class="reference internal image-reference" href="_images/decay_DormandPrince_adaptivity.png"><img alt="_images/decay_DormandPrince_adaptivity.png" src="_images/decay_DormandPrince_adaptivity.png" style="width: 800px;" /></a>
<p class="caption"><em>Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</em></p>
</div>
</div>
</div>
<div class="section" id="exercises-2">
<h2>Exercises  (2)<a class="headerlink" href="#exercises-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-3-experiment-with-precision-in-tests-and-the-size-of">
<span id="decay-fd2-exer-precision"></span><h3>Exercise 3: Experiment with precision in tests and the size of <span class="math">\(u\)</span><a class="headerlink" href="#exercise-3-experiment-with-precision-in-tests-and-the-size-of" title="Permalink to this headline">¶</a></h3>
<p>It is claimed in the section <a class="reference internal" href="#decay-mms"><em>Verification via manufactured solutions</em></a> that most numerical methods will
reproduce a linear exact solution to machine precision. Test this
assertion using the test function <tt class="docutils literal"><span class="pre">test_linear_solution</span></tt> in the
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_vc.py">decay_vc.py</a> program.
Vary the parameter <tt class="docutils literal"><span class="pre">c</span></tt> from very small, via <tt class="docutils literal"><span class="pre">c=1</span></tt> to many larger values,
and print out the maximum difference between the numerical solution
and the exact solution. What is the relevant value of the tolerance
in the float comparison in each case?
Filename: <tt class="docutils literal"><span class="pre">test_precision.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-implement-the-2-step-backward-scheme">
<span id="decay-fd2-exer-bw2"></span><h3>Exercise 4: Implement the 2-step backward scheme<a class="headerlink" href="#exercise-4-implement-the-2-step-backward-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 2-step backward method <a href="#equation-decay:fd2:bw:2step">(53)</a> for the
model <span class="math">\(u'(t) = -a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.  Allow the first step to
be computed by either the Backward Euler scheme or the Crank-Nicolson
scheme. Verify the implementation by choosing <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> such
that the exact solution is linear in <span class="math">\(t\)</span> (see the section <a class="reference internal" href="#decay-mms"><em>Verification via manufactured solutions</em></a>). Show mathematically that a linear solution is indeed a
solution of the discrete equations.</p>
<p>Compute convergence rates (see the section <em class="xref std std-ref">decay:convergence:rate</em>) in
a test case <span class="math">\(a=\hbox{const}\)</span> and <span class="math">\(b=0\)</span>, where we easily have an exact
solution, and determine if the choice of a first-order scheme
(Backward Euler) for the first step has any impact on the overall
accuracy of this scheme. The expected error goes like <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.
Filename: <tt class="docutils literal"><span class="pre">decay_backward2step.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-implement-the-2nd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab2"></span><h3>Exercise 5: Implement the 2nd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-5-implement-the-2nd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 2nd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB2">(59)</a>
for the decay problem <span class="math">\(u'=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Use the Forward Euler method for the first step such that the overall
scheme is explicit. Verify the implementation using an exact
solution that is linear in time.
Analyze the scheme by searching for solutions <span class="math">\(u^n=A^n\)</span> when <span class="math">\(a=\hbox{const}\)</span>
and <span class="math">\(b=0\)</span>. Compare this second-order secheme to the Crank-Nicolson scheme.
Filename: <tt class="docutils literal"><span class="pre">decay_AdamsBashforth2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-implement-the-3rd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab3"></span><h3>Exercise 6: Implement the 3rd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-6-implement-the-3rd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>Implement the 3rd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB3">(60)</a>
for the decay problem <span class="math">\(u'=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Since the scheme is explicit, allow it to be started by two steps with
the Forward Euler method.  Investigate experimentally the case where
<span class="math">\(b=0\)</span> and <span class="math">\(a\)</span> is a constant: Can we have oscillatory solutions for
large <span class="math">\(\Delta t\)</span>?
Filename: <tt class="docutils literal"><span class="pre">decay_AdamsBashforth3.py</span></tt>.</p>
</div>
<div class="section" id="exercise-7-analyze-explicit-2nd-order-methods">
<span id="decay-exer-rk2-taylor-analysis"></span><h3>Exercise 7: Analyze explicit 2nd-order methods<a class="headerlink" href="#exercise-7-analyze-explicit-2nd-order-methods" title="Permalink to this headline">¶</a></h3>
<p>Show that the schemes <a href="#equation-decay:fd2:RK2:s2">(57)</a> and
<a href="#equation-decay:fd2:Taylor2">(58)</a> are identical in the case <span class="math">\(f(u,t)=-a\)</span>, where
<span class="math">\(a&gt;0\)</span> is a constant. Assume that the numerical solution reads
<span class="math">\(u^n=A^n\)</span> for some unknown amplification factor <span class="math">\(A\)</span> to be determined.
Find <span class="math">\(A\)</span> and derive stability criteria. Can the scheme produce
oscillatory solutions of <span class="math">\(u'=-au\)</span>? Plot the numerical and exact
amplification factor.
Filename: <tt class="docutils literal"><span class="pre">decay_RK2_Taylor2.py</span></tt>.</p>
</div>
<div class="section" id="problem-8-implement-and-investigate-the-leapfrog-scheme">
<span id="decay-fd2-exer-leapfrog1"></span><h3>Problem 8: Implement and investigate the Leapfrog scheme<a class="headerlink" href="#problem-8-implement-and-investigate-the-leapfrog-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Leapfrog scheme
for the ODE <span class="math">\(u'(t) = -a(t)u(t) + b(t)\)</span> is defined by</p>
<div class="math">
\[\lbrack D_{2t}u = -au+b\rbrack^n{\thinspace .}\]</div>
<p>A separate method is needed to compute <span class="math">\(u^1\)</span>. The Forward Euler
scheme is a possible candidate.</p>
<p><strong>a)</strong>
Implement the Leapfrog scheme for the model equation.
Plot the solution in the case <span class="math">\(a=1\)</span>, <span class="math">\(b=0\)</span>, <span class="math">\(I=1\)</span>,
<span class="math">\(\Delta t = 0.01\)</span>, <span class="math">\(t\in [0,4]\)</span>. Compare with the exact
solution <span class="math">\({u_{\small\mbox{e}}}(t)=e^{-t}\)</span>.</p>
<p><strong>b)</strong>
Show mathematically that a linear solution in <span class="math">\(t\)</span> fulfills the
Forward Euler scheme for the first step and the Leapfrog scheme
for the subsequent steps. Use this linear solution to verify
the implementation, and automate the verification through a test
function.</p>
<p><strong>Hint.</strong>
It can be wise to automate the calculations such that it is easy to
redo the calculations for other types of solutions. Here is
a possible <tt class="docutils literal"><span class="pre">sympy</span></tt> function that takes a symbolic expression <tt class="docutils literal"><span class="pre">u</span></tt>
(implemented as a Python function of <tt class="docutils literal"><span class="pre">t</span></tt>), fits the <tt class="docutils literal"><span class="pre">b</span></tt> term, and
checks if <tt class="docutils literal"><span class="pre">u</span></tt> fulfills the discrete equations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>

<span class="k">def</span> <span class="nf">analyze</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t dt a&#39;</span><span class="p">)</span>

    <span class="k">print</span> <span class="s">&#39;Analyzing u_e(t)=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;u(0)=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Fit source term to the given u(t)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Source term b:&#39;</span><span class="p">,</span> <span class="n">b</span>

    <span class="c"># Residual in discrete equations; Forward Euler step</span>
    <span class="n">R_step1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">R_step1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R_step1</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Residual Forward Euler step:&#39;</span><span class="p">,</span> <span class="n">R_step1</span>

    <span class="c"># Residual in discrete equations; Leapfrog steps</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Residual Leapfrog steps:&#39;</span><span class="p">,</span> <span class="n">R</span>

<span class="k">def</span> <span class="nf">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

<span class="n">analyze</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>
<span class="c"># or short form: analyze(lambda t: c*t + I)</span>
</pre></div>
</div>
<p><strong>c)</strong>
Show that a second-order polynomial in <span class="math">\(t\)</span> cannot be a solution of the discrete
equations. However, if a Crank-Nicolson scheme is used for the first
step, a second-order polynomial solves the equations exactly.</p>
<p><strong>d)</strong>
Create a manufactured solution <span class="math">\(u(t)=\sin(t)\)</span> for the ODE
<span class="math">\(u'=-au+b\)</span>.
Compute the convergence rate of the Leapfrog scheme using this
manufactured solution. The expected convergence rate of the
Leapfrog scheme is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. Does the use of a
1st-order method for the first step impact the convergence rate?</p>
<p><strong>e)</strong>
Set up a set of experiments to demonstrate that the Leapfrog scheme
<a href="#equation-decay:fd2:leapfrog">(54)</a> is associated with numerical artifacts
(instabilities). Document the main results from this investigation.</p>
<p><strong>f)</strong>
Analyze and explain the
instabilities of the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(54)</a>:</p>
<ol class="arabic simple">
<li>Choose <span class="math">\(a=\mbox{const}\)</span> and <span class="math">\(b=0\)</span>. Assume that an exact solution
of the discrete equations has
the form <span class="math">\(u^n=A^n\)</span>, where <span class="math">\(A\)</span> is an amplification factor to
be determined. Derive an equation for <span class="math">\(A\)</span> by inserting <span class="math">\(u^n=A^n\)</span>
in the Leapfrog scheme.</li>
<li>Compute <span class="math">\(A\)</span> either by hand and/or with the aid of <tt class="docutils literal"><span class="pre">sympy</span></tt>.
The polynomial for <span class="math">\(A\)</span> has two roots, <span class="math">\(A_1\)</span> and <span class="math">\(A_2\)</span>. Let
<span class="math">\(u^n\)</span> be a linear combination <span class="math">\(u^n=C_1A_1^n + C_2A_2^n\)</span>.</li>
<li>Show that one of the roots is the explanation of the instability.</li>
<li>Compare <span class="math">\(A\)</span> with the exact expression, using a Taylor series approximation.</li>
<li>How can <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> be determined?</li>
</ol>
<p><strong>g)</strong>
Since the original Leapfrog scheme is unconditionally unstable as time
grows, it demands some stabilization.  This can be done by filtering,
where we first find <span class="math">\(u^{n+1}\)</span> from the original Leapfrog scheme and
then replace <span class="math">\(u^{n}\)</span> by <span class="math">\(u^n + \gamma (u^{n-1} - 2u^n +
u^{n+1})\)</span>, where <span class="math">\(\gamma\)</span> can be taken as 0.6.  Implement the filtered
Leapfrog scheme and check that it can handle tests where the original
Leapfrog scheme is unstable.</p>
<p>Filenames: <tt class="docutils literal"><span class="pre">decay_leapfrog.py</span></tt>, <tt class="docutils literal"><span class="pre">decay_leapfrog.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-9-make-a-unified-implementation-of-many-schemes">
<span id="decay-fd2-exer-uni"></span><h3>Problem 9: Make a unified implementation of many schemes<a class="headerlink" href="#problem-9-make-a-unified-implementation-of-many-schemes" title="Permalink to this headline">¶</a></h3>
<p>Consider the linear ODE problem <span class="math">\(u'(t)=-a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.
Explicit schemes for this problem can be written in the general form</p>
<div class="math" id="equation-decay:analysis:exer:sumcj">
<span class="eqno">(64)</span>\[     u^{n+1} = \sum_{j=0}^m c_ju^{n-j},\]</div>
<p>for some choice of <span class="math">\(c_0,\ldots,c_m\)</span>.
Find expressions for the <span class="math">\(c_j\)</span> coefficients in case of the
<span class="math">\(\theta\)</span>-rule, the three-level backward scheme,
the Leapfrog scheme, the 2nd-order Runge-Kutta method,
and the 3rd-order Adams-Bashforth scheme.</p>
<p>Make a class <tt class="docutils literal"><span class="pre">ExpDecay</span></tt> that implements the
general updating formula <a href="#equation-decay:analysis:exer:sumcj">(64)</a>.
The formula cannot be applied for <span class="math">\(n&lt;m\)</span>, and for those <span class="math">\(n\)</span> values, other
schemes must be used. Assume for simplicity that we just
repeat Crank-Nicolson steps until <a href="#equation-decay:analysis:exer:sumcj">(64)</a> can be used.
Use a subclass
to specify the list <span class="math">\(c_0,\ldots,c_m\)</span> for a particular method, and
implement subclasses for all the mentioned schemes.
Verify the implementation by testing with a linear solution, which should
be exactly reproduced by all methods.
Filename: <tt class="docutils literal"><span class="pre">decay_schemes_oo.py</span></tt>.</p>
</div>
</div>
<div class="section" id="applications-of-exponential-decay-models">
<span id="decay-app"></span><h2>Applications of exponential decay models<a class="headerlink" href="#applications-of-exponential-decay-models" title="Permalink to this headline">¶</a></h2>
<p>This section presents many mathematical models that all
end up with ODEs of the type <span class="math">\(u'=-au+b\)</span>.
The applications are taken from biology,
finance, and physics, and cover population growth or decay, compound
interest and inflation, radioactive decay, cooling of objects,
compaction of geological media, pressure
variations in the atmosphere, and air resistance on falling or rising
bodies.</p>
<div class="section" id="scaling-1">
<span id="decay-app-scaling"></span><h3>Scaling  (1)<a class="headerlink" href="#scaling-1" title="Permalink to this headline">¶</a></h3>
<p>Real applications of a model <span class="math">\(u'=-au+b\)</span> will often involve a lot
of parameters in the expressions for <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. It can be quite
a challenge to find relevant values of all parameters. In simple
problems, however, it turns out that it is not always necessary
to estimate all parameters because we can lump them into one or
a few <em>dimensionless</em> numbers by using a very attractive technique
called scaling. It simply means to stretch the <span class="math">\(u\)</span> and <span class="math">\(t\)</span> axis
is the present problem - and suddenly all parameters in the problem
are lumped one parameter if <span class="math">\(b\neq 0\)</span> and no parameter when <span class="math">\(b=0\)</span>!</p>
<p>Scaling means that we introduce a new function <span class="math">\(\bar u(\bar t)\)</span>,
with</p>
<div class="math">
\[\bar u = \frac{u - u_m}{u_c},\quad \bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(u_m\)</span> is a characteristic value of <span class="math">\(u\)</span>, <span class="math">\(u_c\)</span> is a characteristic
size of the range of <span class="math">\(u\)</span> values, and <span class="math">\(t_c\)</span> is a characteristic
size of the range of <span class="math">\(t_c\)</span> where <span class="math">\(u\)</span> varies significantly.
Choosing <span class="math">\(u_m\)</span>, <span class="math">\(u_c\)</span>, and <span class="math">\(t_c\)</span> is not always easy and often an art
in complicated problems. We just state one choice first:</p>
<div class="math">
\[u_c = I,\quad u_m = b/a,\quad t_c = 1/a{\thinspace .}\]</div>
<p>Inserting <span class="math">\(u=u_m + u_c\bar u\)</span> and <span class="math">\(t=t_c\bar t\)</span> in the problem
<span class="math">\(u'=-au + b\)</span>, assuming <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are constants, results after some
algebra in the <em>scaled problem</em></p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1 - \beta,\]</div>
<p>where <span class="math">\(\beta\)</span> is a dimensionless number</p>
<div class="math">
\[\beta = \frac{b}{Ia}{\thinspace .}\]</div>
<p>That is, only the special combination of <span class="math">\(b/(Ia)\)</span> matters, not what
the individual values of <span class="math">\(b\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(I\)</span> are. Moreover, if <span class="math">\(b=0\)</span>,
the scaled problem is independent of <span class="math">\(a\)</span> and <span class="math">\(I\)</span>! In practice this means
that we can perform one numerical simulation of the scaled problem and
recover the solution of any problem for a given <span class="math">\(a\)</span> and <span class="math">\(I\)</span> by
stretching the axis in the plot: <span class="math">\(u=I\bar u\)</span> and <span class="math">\(t =\bar t/a\)</span>.
For <span class="math">\(b\neq 0\)</span>, we simulate the scaled problem for a few <span class="math">\(\beta\)</span> values
and recover the physical solution <span class="math">\(u\)</span> by translating and stretching the <span class="math">\(u\)</span>
axis and stretching the <span class="math">\(t\)</span> axis.</p>
<p>The scaling breaks down if <span class="math">\(I=0\)</span>. In that case we may choose <span class="math">\(u_m=0\)</span>,
<span class="math">\(u_c=b/a\)</span>, and <span class="math">\(t_c=1/b\)</span>, resulting in a slightly different scaled problem:</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = 1 -\bar u,\quad \bar u(0)=0{\thinspace .}\]</div>
<p>As with <span class="math">\(b=0\)</span>, the case <span class="math">\(I=0\)</span> has a scaled problem with no physical
parameters!</p>
<p>It is common to drop the bars after scaling and write the scaled
problem as <span class="math">\(u'=-u\)</span>, <span class="math">\(u(0)=1-\beta\)</span>, or <span class="math">\(u'=1-u\)</span>, <span class="math">\(u(0)=0\)</span>.
Any implementation of the problem <span class="math">\(u'=-au+b\)</span>, <span class="math">\(u(0)=I\)</span>, can be
reused for the scaled problem by setting <span class="math">\(a=1\)</span>, <span class="math">\(b=0\)</span>, and <span class="math">\(I=1-\beta\)</span>
in the code, if <span class="math">\(I\neq 0\)</span>, or one sets
<span class="math">\(a=1\)</span>, <span class="math">\(b=1\)</span>, and <span class="math">\(I=0\)</span> when the physical <span class="math">\(I\)</span> is zero.
Falling bodies in fluids, as described in the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>,
involves <span class="math">\(u'=-au+b\)</span> with seven physical parameters. All these vanish
in the scaled version of the problem if we start the motion from rest!</p>
</div>
<div class="section" id="evolution-of-a-population">
<span id="decay-app-pop"></span><h3>Evolution of a population<a class="headerlink" href="#evolution-of-a-population" title="Permalink to this headline">¶</a></h3>
<p id="index-84">Let <span class="math">\(N\)</span> be the number of individuals in a population occupying some
spatial domain.
Despite <span class="math">\(N\)</span> being an integer in this problem,
we shall compute with <span class="math">\(N\)</span> as a real number
and view <span class="math">\(N(t)\)</span> as a continuous function of time.
The basic model assumption is that in a time interval <span class="math">\(\Delta t\)</span> the number of
newcomers to the populations (newborns) is proportional to
<span class="math">\(N\)</span>, with proportionality constant <span class="math">\(\bar b\)</span>. The amount of
newcomers will increase the population and result in
to</p>
<div class="math">
\[N(t+\Delta t) = N(t) + \bar bN(t){\thinspace .}\]</div>
<p>It is obvious that a long time interval <span class="math">\(\Delta t\)</span> will result in
more newcomers and hence a larger <span class="math">\(\bar b\)</span>. Therefore, we introduce
<span class="math">\(b=\bar b/\Delta t\)</span>: the number of newcomers per unit time and per
individual. We must then multiply <span class="math">\(b\)</span> by the length of the time
interval considered and by the population size to get the
total number of new individuals, <span class="math">\(b\Delta t N\)</span>.</p>
<p>If the number of removals from the population (deaths) is also
proportional to <span class="math">\(N\)</span>, with proportionality constant <span class="math">\(d\Delta t\)</span>,
the population evolves according to</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t){\thinspace .}\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t \rightarrow 0\)</span>,
we get the ODE</p>
<div class="math">
\[N' = (b-d)N,\quad N(0)=N_0{\thinspace .}\]</div>
<p>In a population where the death rate (<span class="math">\(d\)</span>) is larger than
then newborn rate (<span class="math">\(b\)</span>), <span class="math">\(a&gt;0\)</span>, and the population experiences
exponential decay rather than exponential growth.</p>
<p>In some populations there is an immigration of individuals into the
spatial domain. With <span class="math">\(I\)</span> individuals coming in per time unit,
the equation for the population change becomes</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t) + \Delta t I{\thinspace .}\]</div>
<p>The corresponding ODE reads</p>
<div class="math">
\[N' = (b-d)N + I,\quad N(0)=N_0
{\thinspace .}\]</div>
<p>Some simplification arises if we introduce a fractional measure
of the population: <span class="math">\(u=N/N_0\)</span> and set <span class="math">\(r=b-d\)</span>. The ODE problem
now becomes</p>
<div class="math" id="equation-decay:app:pop:ueq">
<span class="eqno">(65)</span>\[     u' = ru + f,\quad u(0)=1,\]</div>
<p>where <span class="math">\(f=I/N_0\)</span> measures the net immigration per time unit as
the fraction of the initial population. Very often, <span class="math">\(r\)</span> is approximately
constant, but <span class="math">\(f\)</span> is usually a function of time.</p>
<p id="index-85">The growth rate <span class="math">\(r\)</span> of a population decreases if the environment
has limited resources. Suppose the environment can sustain at
most <span class="math">\(N_{\max}\)</span> individuals. We may then assume that the growth rate
approaches zero as <span class="math">\(N\)</span> approaches <span class="math">\(N_{\max}\)</span>, i.e., as <span class="math">\(u\)</span> approaches
<span class="math">\(M=N_{\max}/N_0\)</span>. The simplest possible evolution of <span class="math">\(r\)</span> is then a
linear function: <span class="math">\(r(t)=r_0(1-u(t)/M)\)</span>, where <span class="math">\(r_0\)</span>
is the initial growth rate when the population is small relative to the
maximum size and there is enough resources. Using this <span class="math">\(r(t)\)</span> in
<a href="#equation-decay:app:pop:ueq">(65)</a> results in the <em>logistic model</em> for the
evolution of a population (assuming for the moment that <span class="math">\(f=0\)</span>):</p>
<div class="math" id="equation-decay:app:pop:logistic">
<span class="eqno">(66)</span>\[     u' = r_0(1-u/M)u,\quad u(0)=1
     {\thinspace .}\]</div>
<p>Initially, <span class="math">\(u\)</span> will grow at rate <span class="math">\(r_0\)</span>, but the growth will decay
as <span class="math">\(u\)</span> approaches <span class="math">\(M\)</span>, and then there is no more change in <span class="math">\(u\)</span>, causing
<span class="math">\(u\rightarrow M\)</span> as <span class="math">\(t\rightarrow\infty\)</span>.
Note that the logistic equation <span class="math">\(u'=r_0(1-u/M)u\)</span> is <em>nonlinear</em> because
of the quadratic term <span class="math">\(-u^2r_0/M\)</span>.</p>
</div>
<div class="section" id="compound-interest-and-inflation">
<span id="decay-app-interest"></span><h3>Compound interest and inflation<a class="headerlink" href="#compound-interest-and-inflation" title="Permalink to this headline">¶</a></h3>
<p>Say the annual interest rate is <span class="math">\(r\)</span> percent and that the bank
adds the interest once a year to your investment.
If <span class="math">\(u^n\)</span> is the investment in year <span class="math">\(n\)</span>, the investment in year <span class="math">\(u^{n+1}\)</span>
grows to</p>
<div class="math">
\[u^{n+1} = u^n + \frac{r}{100}u^n
{\thinspace .}\]</div>
<p>In reality, the interest rate is added every day. We therefore introduce
a parameter <span class="math">\(m\)</span> for the number of periods per year when the interest
is added. If <span class="math">\(n\)</span> counts the periods, we have the fundamental model
for compound interest:</p>
<div class="math" id="equation-decay:app:interest:eq1">
<span class="eqno">(67)</span>\[     u^{n+1} = u^n + \frac{r}{100 m}u^n
     {\thinspace .}\]</div>
<p>This model is a <em>difference equation</em>, but it can be transformed to a
continuous differential equation through a limit process.
The first step is to derive a formula for the growth of the investment
over a time <span class="math">\(t\)</span>.
Starting with an investment <span class="math">\(u^0\)</span>, and assuming that <span class="math">\(r\)</span> is constant in time,
we get</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= \left(1 + \frac{r}{100 m}\right)u^{n}\\
&amp;= \left(1 + \frac{r}{100 m}\right)^2u^{n-1}\\
&amp;\ \ \vdots\\
&amp;= \left(1 +\frac{r}{100 m}\right)^{n+1}u^{0}\end{split}\]</div>
<p>Introducing time <span class="math">\(t\)</span>, which here is a real-numbered counter for years,
we have that <span class="math">\(n=mt\)</span>, so we can write</p>
<div class="math">
\[u^{mt} = \left(1 + \frac{r}{100 m}\right)^{mt} u^0{\thinspace .}\]</div>
<p>The second step is to assume <em>continuous compounding</em>, meaning that the
interest is added continuously. This implies <span class="math">\(m\rightarrow\infty\)</span>, and
in the limit one gets the formula</p>
<div class="math">
\[u(t) = u_0e^{rt/100},\]</div>
<p>which is nothing but the solution of the ODE problem</p>
<div class="math" id="equation-decay:app:interest:eq2">
<span class="eqno">(68)</span>\[     u' = \frac{r}{100}u,\quad u(0)=u_0
     {\thinspace .}\]</div>
<p>This is then taken as the ODE model for compound interest if <span class="math">\(r&gt;0\)</span>.
However, the reasoning applies equally well to inflation, which is
just the case <span class="math">\(r&lt;0\)</span>. One may also take the <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(68)</a>
as the net growth of an investemt, where <span class="math">\(r\)</span> takes both compound interest
and inflation into account. Note that for real applications we must
use a time-dependent <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(68)</a>.</p>
<p>Introducing <span class="math">\(a=\frac{r}{100}\)</span>, continuous inflation of an initial
fortune <span class="math">\(I\)</span> is then
a process exhibiting exponential decay according to</p>
<div class="math">
\[u' = -au,\quad u(0)=I{\thinspace .}\]</div>
</div>
<div class="section" id="radioactive-decay">
<span id="decay-app-nuclear"></span><h3>Radioactive Decay<a class="headerlink" href="#radioactive-decay" title="Permalink to this headline">¶</a></h3>
<p id="index-86">An atomic nucleus of an unstable atom may lose energy by emitting
ionizing particles and thereby be transformed to a nucleus with a
different number of protons and neutrons.  This process is known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Radioactive_decay">radioactive decay</a>.
Actually, the process is stochastic when viewed for a single atom,
because it is impossible to predict exactly when a particular atom
emits a particle. Nevertheless, with a large number of atoms, <span class="math">\(N\)</span>, one
may view the process as deterministic and compute the mean behavior of
the decay. Below we reason intuitively about an ODE for the mean
behavior. Thereafter, we show mathematically that a detailed stochastic model
for single atoms leads the same mean behavior.</p>
<div class="section" id="deterministic-model">
<h4>Deterministic model<a class="headerlink" href="#deterministic-model" title="Permalink to this headline">¶</a></h4>
<p>Suppose at time <span class="math">\(t\)</span>, the number of the original atom type is <span class="math">\(N(t)\)</span>.
A basic model assumption is that the transformation of the atoms of the original
type in a small time interval <span class="math">\(\Delta t\)</span> is proportional to
<span class="math">\(N\)</span>, so that</p>
<div class="math">
\[N(t+\Delta t) = N(t) - a\Delta t N(t),\]</div>
<p>where <span class="math">\(a&gt;0\)</span> is a constant. Introducing <span class="math">\(u=N(t)/N(0)\)</span>, dividing by
<span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t\rightarrow 0\)</span> gives the
following ODE:</p>
<div class="math">
\[u' = -au,\quad u(0)=1
{\thinspace .}\]</div>
<p>The parameter <span class="math">\(a\)</span> can for a given nucleus be expressed through the
<em>half-life</em> <span class="math">\(t_{1/2}\)</span>, which is the time taken for the decay to reduce the
initial amount by one half, i.e., <span class="math">\(u(t_{1/2}) = 0.5\)</span>.
With <span class="math">\(u(t)=e^{-at}\)</span>, we get <span class="math">\(t_{1/2}=a^{-1}\ln 2\)</span> or <span class="math">\(a=\ln 2/t_{1/2}\)</span>.</p>
</div>
<div class="section" id="stochastic-model">
<h4>Stochastic model<a class="headerlink" href="#stochastic-model" title="Permalink to this headline">¶</a></h4>
<p>We have originally <span class="math">\(N_0\)</span> atoms. Each atom may have decayed or
survived at a particular time <span class="math">\(t\)</span>. We want to count how many original
atoms that are left, i.e., how many atoms that have survived.
The survival of a single atom at time <span class="math">\(t\)</span> is a random event. Since there
are only two outcomes, survival or decay, we have a
<a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli trial</a>.
Let <span class="math">\(p\)</span> be the
probability of survival (implying that the probability of decay
is <span class="math">\(1-p\)</span>). If each atom survives independently of
the others, and the probability of survival is the same for every
atom, we have <span class="math">\(N_0\)</span> statistically Bernoulli trials, known as
a <em>binomial experiment</em> from probability theory.
The probability <span class="math">\(P(N)\)</span> that <span class="math">\(N\)</span> out
of the <span class="math">\(N_0\)</span> atoms have survived at time <span class="math">\(t\)</span> is then given by the
famous <em>binomial distribution</em></p>
<div class="math">
\[P(N) = \frac{N_0!}{N! (N_0-N)!}p^N (1-p)^{N_0-N}{\thinspace .}\]</div>
<p>The mean (or expected) value <span class="math">\({\hbox{E}\lbrack P \rbrack}\)</span> of <span class="math">\(P(N)\)</span> is known to be <span class="math">\(N_0p\)</span>.</p>
<p>It remains to estimate <span class="math">\(p\)</span>. Let the interval <span class="math">\([0,t]\)</span> be divided into <span class="math">\(m\)</span>
small subintervals of length <span class="math">\(\Delta t\)</span>. We make the assumption that
the probability of decay of a single atom in an interval of length <span class="math">\(\Delta t\)</span>
is <span class="math">\(\tilde p\)</span>, and that this probability is proportional to <span class="math">\(\Delta t\)</span>:
<span class="math">\(\tilde p = \lambda\Delta t\)</span> (it sounds natural that the probability
of decay increases with <span class="math">\(\Delta t\)</span>). The corresponding probability of survival
is <span class="math">\(1-\lambda\Delta t\)</span>. Believing that <span class="math">\(\lambda\)</span> is independent
of time, we have, for each interval of length <span class="math">\(\Delta t\)</span>,
a Bernoulli trial: the atom either survives or
decays in that interval. Now, <span class="math">\(p\)</span> should be the probability that the atom
survives in all the intervals, i.e., that we have <span class="math">\(m\)</span> successful
Bernoulli trials in a row and therefore</p>
<div class="math">
\[p = (1-\lambda\Delta t)^m{\thinspace .}\]</div>
<p>The expected number of atoms of the original type at time <span class="math">\(t\)</span> is</p>
<div class="math">
\[{\hbox{E}\lbrack P \rbrack} = N_0p = N_0(1-\lambda\Delta t)^m,\quad m=t/\Delta t{\thinspace .}\]</div>
<p>To see the relation between the two types of Bernoulli trials and the
ODE above, we go to the limit <span class="math">\(\Delta t\rightarrow t\)</span>, <span class="math">\(m\rightarrow\infty\)</span>.
One can show that</p>
<div class="math">
\[p = \lim_{m\rightarrow\infty} (1-\lambda\Delta t)^m
= \lim_{m\rightarrow\infty} \left(1-\lambda\frac{t}{m}\right)^m = e^{-\lambda t}\]</div>
<p>This is the famous exponential waiting time (or arrival time) distribution for a
Poisson process in probability theory (obtained here, as often done, as
the limit of a binomial experiment). The probability of decay,
<span class="math">\(1-e^{-\lambda t}\)</span>, follows an <a class="reference external" href="http://en.wikipedia.org/wiki/Exponential_distribution">exponential distribution</a>.
The limit means that <span class="math">\(m\)</span> is very
large, hence <span class="math">\(\Delta t\)</span> is very small, and <span class="math">\(\tilde p=\lambda\Delta t\)</span>
is very small since the intensity of the events, <span class="math">\(\lambda\)</span>, is assumed
finite. This situation corresponds to a very small probability
that an atom will decay in a very short time interval, which is a
reasonable model.
The same model occurs in lots of different applications, e.g.,
when waiting for a taxi, or when finding defects along a rope.</p>
</div>
<div class="section" id="relation-between-stochastic-and-deterministic-models">
<h4>Relation between stochastic and deterministic models<a class="headerlink" href="#relation-between-stochastic-and-deterministic-models" title="Permalink to this headline">¶</a></h4>
<p>With <span class="math">\(p=e^{-\lambda t}\)</span> we get the expected number of original atoms
at <span class="math">\(t\)</span> as <span class="math">\(N_0p=N_0e^{-\lambda t}\)</span>, which is exactly the solution of
the ODE model <span class="math">\(N'=-\lambda N\)</span>. This gives also an interpretation
of <span class="math">\(a\)</span> via <span class="math">\(\lambda\)</span> or vice versa. Our important finding here
is that the ODE model
captures the mean behavior of the underlying stochastic model. This
is, however, not always the common relation between microscopic stochastic
models and macroscopic &#8220;averaged&#8221; models.</p>
<p>Also of interest is to see that a Forward Euler discretization of
<span class="math">\(N'=-\lambda N\)</span>, <span class="math">\(N(0)=N_0\)</span>, gives <span class="math">\(N^m = N_0(1-\lambda\Delta t)^m\)</span>
at time <span class="math">\(t_m=m\Delta t\)</span>, which is exactly the
expected value of the stochastic experiment with <span class="math">\(N_0\)</span> atoms
and <span class="math">\(m\)</span> small intervals of length <span class="math">\(\Delta t\)</span>, where each atom can
decay with probability <span class="math">\(\lambda\Delta t\)</span> in an interval.</p>
<p>A fundamental question is how accurate the ODE model is. The underlying
stochastic model fluctuates around its expected value. A measure
of the fluctuations is the standard deviation of the binomial experiment with
<span class="math">\(N_0\)</span> atoms, which can be shown to be <span class="math">\({\hbox{Std}\lbrack P \rbrack}=\sqrt{N_0p(1-p)}\)</span>. Compared
to the size of the expectation, we get
the normalized standard deviation</p>
<div class="math">
\[\frac{\sqrt{{\hbox{Var}\lbrack P \rbrack}}}{{\hbox{E}\lbrack P \rbrack}} = N_0^{-1/2}\sqrt{p^{-1}-1}
= N_0^{-1/2}\sqrt{(1-e^{-\lambda t})^{-1}-1}\approx
(N_0\lambda t)^{-1/2},\]</div>
<p>showing that the normalized fluctuations are very small if <span class="math">\(N_0\)</span> is
very large, which is usually the case.</p>
</div>
</div>
<div class="section" id="newton-s-law-of-cooling">
<span id="decay-app-newton-cooling"></span><h3>Newton&#8217;s law of cooling<a class="headerlink" href="#newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h3>
<p>When a body at some temperature is placed in a cooling environment,
experience shows that the temperature falls rapidly in the beginning,
and then the changes in temperature levels off until the body&#8217;s
temperature equals that of the surroundings. Newton carried out some
experiments on cooling hot iron and found that the temperature
evolved as a &#8220;geometric progression at times in arithmetic progression&#8221;,
meaning that the temperature decayed exponentially.
Later, this result was formulated as a differential equation:
the rate of change of the temperature in a body is proportional to
the temperature difference between the body and its surroundings.
This statement is known as <em>Newton&#8217;s law of cooling</em>, which
can be mathematically expressed as</p>
<div class="math" id="equation-decay:Newton:cooling">
<span class="eqno">(69)</span>\[     {dT\over dt} = -k(T-T_s),\]</div>
<p>where <span class="math">\(T\)</span> is the temperature of the body, <span class="math">\(T_s\)</span> is the temperature
of the surroundings, <span class="math">\(t\)</span> is time, and <span class="math">\(k\)</span> is a positive constant.
Equation <a href="#equation-decay:Newton:cooling">(80)</a> is primarily viewed as an
empirical law, valid when heat is efficiently convected away
from the surface of the body by a flowing fluid such as air
at constant temperature <span class="math">\(T_s\)</span>.
The <em>heat transfer coefficient</em> <span class="math">\(k\)</span> reflects the transfer of
heat from the body to
the surroundings and must be determined from physical experiments.</p>
<p>We must obviously have an initial condition <span class="math">\(T(0)=T_0\)</span> in addition
to the cooling law <a href="#equation-decay:Newton:cooling">(80)</a>.</p>
</div>
<div class="section" id="decay-of-atmospheric-pressure-with-altitude">
<span id="decay-app-atm"></span><h3>Decay of atmospheric pressure with altitude<a class="headerlink" href="#decay-of-atmospheric-pressure-with-altitude" title="Permalink to this headline">¶</a></h3>
<p>Vertical equilibrium of air in the atmosphere is governed by
the equation</p>
<div class="math" id="equation-decay:app:atm:dpdz">
<span class="eqno">(70)</span>\[     \frac{dp}{dz} = -\varrho g
     {\thinspace .}\]</div>
<p>Here, <span class="math">\(p(z)\)</span> is the air pressure, <span class="math">\(\varrho\)</span> is the density of
air, and <span class="math">\(g=9.807\hbox{ m/s}^2\)</span> is a standard value of
the acceleration of gravity.
(Equation <a href="#equation-decay:app:atm:dpdz">(70)</a> follows directly from the general
Navier-Stokes equations for fluid motion, with
the assumption that the air does not move.)</p>
<p>The pressure is related to density and temperature through the ideal gas law</p>
<div class="math" id="equation-decay:app:atm:rho">
<span class="eqno">(71)</span>\[     \varrho = \frac{Mp}{R^*T},\]</div>
<p>where <span class="math">\(M\)</span> is the molar mass of the Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\)</span> Nm/(mol K)), and <span class="math">\(T\)</span> is the temperature.
All variables <span class="math">\(p\)</span>, <span class="math">\(\varrho\)</span>, and <span class="math">\(T\)</span> vary with the height <span class="math">\(z\)</span>.
Inserting <a href="#equation-decay:app:atm:rho">(71)</a> in <a href="#equation-decay:app:atm:dpdz">(70)</a> results
in an ODE with a variable coefficient:</p>
<div class="math" id="equation-decay:app:atm:ode">
<span class="eqno">(72)</span>\[     \frac{dp}{dz} = -\frac{Mg}{R^*T(z)} p\]\[     \thinspace  .\]</div>
<div class="section" id="multiple-atmospheric-layers">
<h4>Multiple atmospheric layers<a class="headerlink" href="#multiple-atmospheric-layers" title="Permalink to this headline">¶</a></h4>
<p>The atmosphere can be approximately modeled by seven layers.
In each layer, <a href="#equation-decay:app:atm:ode">(72)</a> is applied with
a linear temperature of the form</p>
<div class="math">
\[T(z) = \bar T_i + L_i(z-h_i),\]</div>
<p>where <span class="math">\(z=h_i\)</span> denotes the bottom of layer number <span class="math">\(i\)</span>,
having temperature <span class="math">\(\bar T_i\)</span>,
and <span class="math">\(L_i\)</span> is a constant in layer number <span class="math">\(i\)</span>. The table below
lists <span class="math">\(h_i\)</span> (m), <span class="math">\(\bar T_i\)</span> (K), and <span class="math">\(L_i\)</span> (K/m) for the layers
<span class="math">\(i=0,\ldots,6\)</span>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(i\)</span></th>
<th class="head"><span class="math">\(h_i\)</span></th>
<th class="head"><span class="math">\(\bar T_i\)</span></th>
<th class="head"><span class="math">\(L_i\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>288</td>
<td>-0.0065</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>11,000</td>
<td>216</td>
<td>0.0</td>
</tr>
<tr class="row-even"><td>2</td>
<td>20,000</td>
<td>216</td>
<td>0.001</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>32,000</td>
<td>228</td>
<td>0.0028</td>
</tr>
<tr class="row-even"><td>4</td>
<td>47,000</td>
<td>270</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>51,000</td>
<td>270</td>
<td>-0.0028</td>
</tr>
<tr class="row-even"><td>6</td>
<td>71,000</td>
<td>214</td>
<td>-0.002</td>
</tr>
</tbody>
</table>
<p>For implementation it might be convenient to write <a href="#equation-decay:app:atm:ode">(72)</a>
on the form</p>
<div class="math">
\[\frac{dp}{dz} = -\frac{Mg}{R^*(\bar T(z) + L(z)(z-h(z)))} p,\]</div>
<p>where <span class="math">\(\bar T(z)\)</span>, <span class="math">\(L(z)\)</span>, and <span class="math">\(h(z)\)</span> are piecewise constant
functions with values given in the table.
The value of the pressure at the sea level <span class="math">\(z=0\)</span>, <span class="math">\(p_0=p(0)\)</span>, is <span class="math">\(101325\)</span> Pa.</p>
</div>
<div class="section" id="simplification">
<h4>Simplification: <span class="math">\(L=0\)</span><a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h4>
<p>One commonly used simplification is to assume that the temperature is
constant within each layer. This means that <span class="math">\(L=0\)</span>.</p>
</div>
<div class="section" id="simplification-one-layer-model">
<h4>Simplification: one-layer model<a class="headerlink" href="#simplification-one-layer-model" title="Permalink to this headline">¶</a></h4>
<p>Another commonly used approximation is to work with one layer instead of
seven. This <a class="reference external" href="http://en.wikipedia.org/wiki/Density_of_air">one-layer model</a>
is based on <span class="math">\(T(z)=T_0 - Lz\)</span>, with
sea level standard temperature <span class="math">\(T_0=288\)</span> K and
temperature lapse rate <span class="math">\(L=0.0065\)</span> K/m.</p>
</div>
</div>
<div class="section" id="compaction-of-sediments">
<span id="decay-app-sediment"></span><h3>Compaction of sediments<a class="headerlink" href="#compaction-of-sediments" title="Permalink to this headline">¶</a></h3>
<p>Sediments, originally made from materials like sand and mud, get
compacted through geological time by the weight of new material that
is deposited on the sea bottom. The porosity <span class="math">\(\phi\)</span> of the sediments
tells how much void (fluid) space there is between the sand and
mud grains. The porosity reduces with depth because the weight of
the sediments above and causes the void space to shrink and thereby
increase the compaction.</p>
<p>A typical assumption is that the change in <span class="math">\(\phi\)</span> at some depth <span class="math">\(z\)</span>
is negatively proportional to <span class="math">\(\phi\)</span>. This assumption leads to
the differential equation problem</p>
<div class="math" id="equation-decay:app:sediment:phi:eq">
<span class="eqno">(73)</span>\[     \frac{d\phi}{dz} = -c\phi,\quad \phi(0)=\phi_0,\]</div>
<p>where the <span class="math">\(z\)</span> axis points downwards, <span class="math">\(z=0\)</span> is the surface with known
porosity, and <span class="math">\(c&gt;0\)</span> is a constant.</p>
<p>The upper part of the Earth&#8217;s crust consists of many geological layers
stacked on top of each other, as indicated in Figure
<a class="reference internal" href="#decay-app-sediment-fig-layers"><em>Illustration of the compaction of geological layers (with different colors) through time</em></a>.  The model
<a href="#equation-decay:app:sediment:phi:eq">(73)</a> can be applied for each layer. In
layer number <span class="math">\(i\)</span>, we have the unknown porosity function <span class="math">\(\phi_i(z)\)</span>
fulfilling <span class="math">\(\phi_i'(z)=-c_iz\)</span>, since the constant <span class="math">\(c\)</span> in the model
<a href="#equation-decay:app:sediment:phi:eq">(73)</a> depends on the type of sediment in
the layer. From the figure we see that new layers of sediments are
deposited on top of older ones as time progresses. The compaction,
as measured by <span class="math">\(\phi\)</span>, is
rapid in the beginning and then decreases (exponentially) with depth
in each layer.</p>
<div class="figure" id="decay-app-sediment-fig-layers">
<a class="reference internal image-reference" href="_images/Compaction_of_Sediment.png"><img alt="_images/Compaction_of_Sediment.png" src="_images/Compaction_of_Sediment.png" style="width: 600px;" /></a>
<p class="caption"><em>Illustration of the compaction of geological layers (with different colors) through time</em></p>
</div>
<p>When we drill a well at present time through the right-most column of
sediments in Figure <a class="reference internal" href="#decay-app-sediment-fig-layers"><em>Illustration of the compaction of geological layers (with different colors) through time</em></a>, we can measure
the thickness of the sediment in (say) the bottom layer. Let <span class="math">\(L_1\)</span> be
this thickness.  Assuming that the volume of sediment remains constant
through time, we have that the initial volume, <span class="math">\(\int_0^{L_{1,0}}
\phi_1 dz\)</span>, must equal the volume seen today,
<span class="math">\(\int_{\ell-L_1}^{\ell}\phi_1 dz\)</span>, where <span class="math">\(\ell\)</span> is the depth of the
bottom of the sediment in the present day configuration.  After having
solved for <span class="math">\(\phi_1\)</span> as a function of <span class="math">\(z\)</span>, we can then find the
original thickness <span class="math">\(L_{1,0}\)</span> of the sediment from the equation</p>
<div class="math">
\[\int_0^{L_{1,0}} \phi_1 dz = \int_{\ell-L_1}^{\ell}\phi_1 dz {\thinspace .}\]</div>
<p>In hydrocarbon exploration it is important to know <span class="math">\(L_{1,0}\)</span> and the
compaction history of the various layers of sediments.</p>
</div>
<div class="section" id="vertical-motion-of-a-body-in-a-viscous-fluid">
<span id="decay-app-drag"></span><h3>Vertical motion of a body in a viscous fluid<a class="headerlink" href="#vertical-motion-of-a-body-in-a-viscous-fluid" title="Permalink to this headline">¶</a></h3>
<p>A body moving vertically through a fluid (liquid or gas) is subject to
three different types of forces: the gravity force, <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_(physics)">the drag force</a>,
and the buoyancy force.</p>
<div class="section" id="overview-of-forces">
<h4>Overview of forces<a class="headerlink" href="#overview-of-forces" title="Permalink to this headline">¶</a></h4>
<p>The gravity force is <span class="math">\(F_g= -mg\)</span>, where <span class="math">\(m\)</span> is the mass of the body and
<span class="math">\(g\)</span> is the acceleration of gravity.
The uplift or buoyancy force (&#8220;Archimedes force&#8221;) is <span class="math">\(F_b = \varrho gV\)</span>,
where <span class="math">\(\varrho\)</span> is the density of the fluid and
<span class="math">\(V\)</span> is the volume of the body.
Forces and other quantities are taken as positive in the upward
direction.</p>
<p>The drag force is of two types, depending on the Reynolds number</p>
<div class="math">
\[\hbox{Re} = \frac{\varrho d|v|}{\mu},\]</div>
<p>where <span class="math">\(d\)</span> is the diameter of the body in
the direction perpendicular to the flow, <span class="math">\(v\)</span> is the velocity of the
body, and <span class="math">\(\mu\)</span> is the dynamic viscosity of the fluid.
When <span class="math">\(\hbox{Re} &lt; 1\)</span>, the drag force is fairly well modeled by
the so-called Stokes&#8217; drag,
which for a spherical body of diameter <span class="math">\(d\)</span> reads</p>
<div class="math">
\[F_d^{(S)} = - 3\pi d\mu v
{\thinspace .}\]</div>
<p>For large Re, typically <span class="math">\(\hbox{Re} &gt; 10^3\)</span>, the drag force is quadratic
in the velocity:</p>
<div class="math">
\[F_d^{(q)} = -{1\over2}C_D\varrho A|v|v,\]</div>
<p>where <span class="math">\(C_D\)</span> is a dimensionless drag coefficient depending on the body&#8217;s shape,
and <span class="math">\(A\)</span> is the cross-sectional area as
produced by a cut plane, perpendicular to the motion, through the thickest
part of the body. The superscripts <span class="math">\(\,{}^q\)</span> and <span class="math">\(\,{}^S\)</span> in
<span class="math">\(F_d^{(S)}\)</span> and <span class="math">\(F_d^{(q)}\)</span> indicate Stokes drag and quadratic drag,
respectively.</p>
</div>
<div class="section" id="equation-of-motion">
<h4>Equation of motion<a class="headerlink" href="#equation-of-motion" title="Permalink to this headline">¶</a></h4>
<p>All the mentioned forces act in the vertical direction.
Newton&#8217;s second law of motion applied to the body says that the sum of
these forces must equal the mass of the body times its acceleration
<span class="math">\(a\)</span> in the vertical direction.</p>
<div class="math">
\[ma = F_g + F_d^{(S)} + F_b {\thinspace .}\]</div>
<p>Here we have chosen to model the fluid resistance by the Stokes drag.
Inserting the expressions for the forces yields</p>
<div class="math">
\[ma = -mg - 3\pi d\mu v + \varrho gV
{\thinspace .}\]</div>
<p>The unknowns here are <span class="math">\(v\)</span> and <span class="math">\(a\)</span>, i.e., we have two unknowns but only
one equation. From kinematics in physics we know that
the acceleration is the time derivative of the velocity: <span class="math">\(a = dv/dt\)</span>.
This is our second equation.
We can easily eliminate <span class="math">\(a\)</span> and get a single differential equation for <span class="math">\(v\)</span>:</p>
<div class="math">
\[m{dv\over dt} = -mg - 3\pi d\mu v + \varrho gV
{\thinspace .}\]</div>
<p>A small rewrite of this equation is handy: We express <span class="math">\(m\)</span> as <span class="math">\(\varrho_bV\)</span>,
where <span class="math">\(\varrho_b\)</span> is the density of the body, and we divide by
the mass to get</p>
<div class="math" id="equation-decay:app:fallingbody:model:S">
<span class="eqno">(74)</span>\[     v'(t) = - \frac{3\pi d\mu}{\varrho_b V} v + g\left(\frac{\varrho}{\varrho_b} -1\right)\]\[     {\thinspace .}\]</div>
<p>We may introduce the constants</p>
<div class="math">
\[a = \frac{3\pi d\mu}{\varrho_b V},\quad
b = g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>so that the structure of the differential equation becomes obvious:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:S">
<span class="eqno">(75)</span>\[     v'(t) = -av(t) + b\]\[     {\thinspace .}\]</div>
<p>The corresponding initial condition is <span class="math">\(v(0)=v_0\)</span> for some prescribed
starting velocity <span class="math">\(v_0\)</span>.</p>
<p>This derivation can be repeated with the quadratic drag force
<span class="math">\(F_d^{(q)}\)</span>, leading to the result</p>
<div class="math" id="equation-decay:app:fallingbody:model:q">
<span class="eqno">(76)</span>\[     v'(t) =
     -{1\over2}C_D{\varrho A\over\varrho_b V}|v|v +
     g\left({\varrho\over\varrho_b} - 1\right)
     {\thinspace .}\]</div>
<p>Defining</p>
<div class="math">
\[a = {1\over2}C_D{\varrho A\over\varrho_b V},\]</div>
<p>and <span class="math">\(b\)</span> as above, we can write <a href="#equation-decay:app:fallingbody:model:q">(76)</a> as</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q">
<span class="eqno">(77)</span>\[     v'(t) = -a|v|v + b
     {\thinspace .}\]</div>
</div>
<div class="section" id="terminal-velocity">
<span id="index-87"></span><h4>Terminal velocity<a class="headerlink" href="#terminal-velocity" title="Permalink to this headline">¶</a></h4>
<p>An interesting aspect of <a href="#equation-decay:app:fallingbody:gmodel:S">(75)</a> and
<a href="#equation-decay:app:fallingbody:gmodel:q">(77)</a> is whether <span class="math">\(v\)</span> will approach
a final constant value,
the so-called <em>terminal velocity</em> <span class="math">\(v_T\)</span>, as <span class="math">\(t\rightarrow\infty\)</span>.
A constant <span class="math">\(v\)</span> means that
<span class="math">\(v'(t)\rightarrow 0\)</span> as <span class="math">\(t\rightarrow\infty\)</span> and therefore
the terminal velocity <span class="math">\(v_T\)</span> solves</p>
<div class="math">
\[0 = -av_T + b\]</div>
<p>and</p>
<div class="math">
\[0 = -a|v_T|v_T + b
{\thinspace .}\]</div>
<p>The former equation implies <span class="math">\(v_T = b/a\)</span>, while the latter has solutions
<span class="math">\(v_T =-\sqrt{|b|/a}\)</span> for a falling body (<span class="math">\(v_T&lt;0\)</span>) and
<span class="math">\(v_T = \sqrt{b/a}\)</span> for a rising body (<span class="math">\(v_T&gt;0\)</span>).</p>
</div>
<div class="section" id="a-crank-nicolson-scheme">
<h4>A Crank-Nicolson scheme<a class="headerlink" href="#a-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h4>
<p>Both governing equations, the Stokes&#8217; drag model
<a href="#equation-decay:app:fallingbody:gmodel:S">(75)</a> and the quadratic drag model
<a href="#equation-decay:app:fallingbody:gmodel:q">(77)</a>, can be readily solved
by the Forward Euler scheme. For higher accuracy one can use
the Crank-Nicolson method, but a straightforward application
this method results
a nonlinear equation in the new unknown value <span class="math">\(v^{n+1}\)</span> when applied to
<a href="#equation-decay:app:fallingbody:gmodel:q">(77)</a>:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:CN">
<span class="eqno">(78)</span>\[     \frac{v^{n+1}-v^n}{\Delta t}
     = -a\frac{1}{2}(|v^{n+1}|v^{n+1} + |v^n|v^n) + b\]\[     {\thinspace .}\]</div>
<p>However, instead of approximating the term <span class="math">\(-|v|v\)</span> by an arithmetic
average, we can use a <em>geometric mean</em>:</p>
<span class="target" id="index-88"></span><div class="math" id="index-89">
\[(|v|v)^{n+\frac{1}{2}} \approx |v^n|v^{n+1}
{\thinspace .}\]</div>
<p>The error is of second order in <span class="math">\(\Delta t\)</span>, just as for the arithmetic
average and the centered finite difference approximation in
<a href="#equation-decay:app:fallingbody:gmodel:CN">(78)</a>. With this approximation trick,
the discrete equation</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = - a|v^{n}|v^{n+1} + b\]</div>
<p>becomes a <em>linear</em> equation in <span class="math">\(v^{n+1}\)</span>, and we can
therefore easily solve for <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q:CN">
<span class="eqno">(79)</span>\[     v^{n+1} = \frac{v_n + \Delta t b^{n+\frac{1}{2}}}{1 + \Delta t a^{n+\frac{1}{2}}|v^{n}|}{\thinspace .}\]</div>
</div>
<div class="section" id="physical-data">
<h4>Physical data<a class="headerlink" href="#physical-data" title="Permalink to this headline">¶</a></h4>
<p>Suitable values of <span class="math">\(\mu\)</span> are <span class="math">\(1.8\cdot 10^{-5}\hbox{ Pa}\, \hbox{s}\)</span> for air
and <span class="math">\(8.9\cdot 10^{-4}\hbox{ Pa}\, \hbox{s}\)</span> for water.
Densities can be taken as <span class="math">\(1.2\hbox{ kg/m}^3\)</span> for air and as
<span class="math">\(1.0\cdot 10^3\hbox{ kg/m}^3\)</span> for water. For considerable vertical
displacement in the atmosphere one should take into account that
the density of air varies with the altitude, see the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>.
One possible density variation arises from the one-layer model
in the mentioned section.</p>
<p>Any density variation makes <span class="math">\(b\)</span> time dependent and we need
<span class="math">\(b^{n+\frac{1}{2}}\)</span> in <a href="#equation-decay:app:fallingbody:gmodel:q:CN">(79)</a>.
To compute the density that enters
<span class="math">\(b^{n+\frac{1}{2}}\)</span> we must also compute the vertical
position <span class="math">\(z(t)\)</span> of the body. Since <span class="math">\(v=dz/dt\)</span>, we can use a centered
difference approximation:</p>
<div class="math">
\[\frac{z^{n+\frac{1}{2}} - z^{n-\frac{1}{2}}}{\Delta t} = v^n
\quad\Rightarrow\quad z^{n+\frac{1}{2}} = z^{n-\frac{1}{2}}+\Delta t\, v^n{\thinspace .}\]</div>
<p>This <span class="math">\(z^{n+\frac{1}{2}}\)</span> is used in the expression for <span class="math">\(b\)</span>
to compute <span class="math">\(\varrho(z^{n+\frac{1}{2}})\)</span> and then <span class="math">\(b^{n+\frac{1}{2}}\)</span>.</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_coefficient">drag coefficient</a> <span class="math">\(C_D\)</span> depends heavily
on the shape of the body.  Some values are: 0.45 for a sphere, 0.42
for a semi-sphere, 1.05 for a cube, 0.82 for a long cylinder (when the
center axis is in the vertical direction), 0.75 for a rocket,
1.0-1.3 for a man in upright position, 1.3 for a flat plate perpendicular
to the flow, and
0.04 for a streamlined, droplet-like body.</p>
</div>
<div class="section" id="verification">
<h4>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h4>
<p>To verify the program, one may assume a heavy body in air such that the <span class="math">\(F_b\)</span>
force can be neglected, and further assume a small velocity such that the
air resistance <span class="math">\(F_d\)</span> can also be neglected. This can be obtained by
setting <span class="math">\(\mu\)</span> and <span class="math">\(\varrho\)</span> to zero. The motion then leads to
the velocity
<span class="math">\(v(t)=v_0 - gt\)</span>, which is linear in <span class="math">\(t\)</span> and therefore should be
reproduced to machine precision (say tolerance <span class="math">\(10^{-15}\)</span>) by any
implementation based on the Crank-Nicolson or Forward Euler schemes.</p>
<p>Another verification, but not as powerful as the one above,
can be based on computing the terminal velocity and comparing with
the exact expressions.
The advantage of this verification is that we can also
the test situation <span class="math">\(\varrho\neq 0\)</span>.</p>
<p>As always, the method of manufactured solutions can be applied to
test the implementation of all terms in the governing equation, but
the solution then has no physical relevance in general.</p>
</div>
<div class="section" id="scaling-2">
<span id="index-90"></span><h4>Scaling  (2)<a class="headerlink" href="#scaling-2" title="Permalink to this headline">¶</a></h4>
<p>Applying scaling, as described in the section <a class="reference internal" href="#decay-app-scaling"><em>Scaling  (1)</em></a>,
will for the linear case reduce the need to estimate values for
seven parameters down to choosing one value of a single dimensionless parameter</p>
<div class="math">
\[\beta = \frac{\varrho_b gV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu I},\]</div>
<p>provided <span class="math">\(I\neq 0\)</span>. If the motion starts from rest, <span class="math">\(I=0\)</span>, the scaled
problem <span class="math">\(\bar u'=1-\bar u\)</span>, <span class="math">\(\bar u(0)=0\)</span>, has no need for
estimating physical parameters.
This means that there is a single universal solution to the problem
of a falling body starting from rest:
<span class="math">\(\bar u(t) = 1 - e^{-\bar t}\)</span>. All real
physical cases correspond to stretching the <span class="math">\(\bar t\)</span> axis and the <span class="math">\(\bar u\)</span>
axis in this dimensionless solution. More precisely, the physical velocity
<span class="math">\(u(t)\)</span> is related to the dimensionless velocity <span class="math">\(\bar u(\bar t)\)</span> through</p>
<div class="math">
\[u = \frac{\varrho_bgV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu}\bar u(t/(g(\varrho/\varrho_b -1))){\thinspace .}\]</div>
</div>
</div>
<div class="section" id="decay-odes-from-solving-a-pde-by-fourier-expansions">
<span id="decay-app-diffusion-fourier"></span><h3>Decay ODEs from solving a PDE by Fourier expansions<a class="headerlink" href="#decay-odes-from-solving-a-pde-by-fourier-expansions" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a partial differential equation</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \alpha\frac{\partial^2u}{\partial x^2}
+ f(x,t),\]</div>
<p>with boundary conditions <span class="math">\(u(0,t)=u(L,t)=0\)</span> and initial condition
<span class="math">\(u(x,0)=I(x)\)</span>. One may express the solution as</p>
<div class="math">
\[u(x,t) = \sum_{k=1}^m A_k(t)e^{ikx\pi/L},\]</div>
<p>for appropriate unknown functions <span class="math">\(A_k\)</span>, <span class="math">\(k=1,\ldots,m\)</span>.
We use the complex exponential <span class="math">\(e^{ikx\pi/L}\)</span> for easy algebra, but
the physical <span class="math">\(u\)</span> is taken as the real part of any complex expression.
Note that the expansion in terms of <span class="math">\(e^{ikx\pi/L}\)</span> is compatible with
the boundary conditions: all functions <span class="math">\(e^{ikx\pi/L}\)</span> vanish for
<span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>. Suppose we can express <span class="math">\(I(x)\)</span> as</p>
<div class="math">
\[I(x) = \sum_{k=1}^m I_ke^{ikx\pi/L}
{\thinspace .}\]</div>
<p>Such an expansion can be computed by well-known Fourier expansion techniques,
but the details are not important here.
Also, suppose we can express the given <span class="math">\(f(x,t)\)</span> as</p>
<div class="math">
\[f(x,t) = \sum_{k=1}^m b_k(t)e^{ikx\pi/L}
{\thinspace .}\]</div>
<p>Inserting the expansions for <span class="math">\(u\)</span>
and <span class="math">\(f\)</span> in the differential equations demands that all terms corresponding
to a given <span class="math">\(k\)</span> must be equal. The calculations results in the follow
system of ODEs:</p>
<div class="math">
\[A_k'(t) = -\alpha\frac{k^2\pi^2}{L^2} + b_k(t),\quad k=1,\ldots,m
{\thinspace .}\]</div>
<p>From the initial condition</p>
<div class="math">
\[u(x,0)=\sum_k A_k(0)e^{ikx\pi/L}=I(x)=\sum_k I_k e^{(ikx\pi/L)},\]</div>
<p>it follows that <span class="math">\(A_k(0)=I_k\)</span>, <span class="math">\(k=1,\ldots,m\)</span>. We then have <span class="math">\(m\)</span>
equations of the form <span class="math">\(A_k'=-a A_k +b\)</span>, <span class="math">\(A_k(0)=I_k\)</span>, for
appropriate definitions of <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. These ODE problems
independent each other such that we can solve one problem
at a time. The outline technique is a quite common approach for solving
partial differential equations.</p>
<p><strong>Remark.</strong>
Since <span class="math">\(a_k\)</span> depends on <span class="math">\(k\)</span> and the stability of
the Forward Euler scheme demands <span class="math">\(a_k\Delta t \leq 1\)</span>, we get that
<span class="math">\(\Delta t \leq \alpha^{-1}L^2\pi^{-2} k^{-2}\)</span>. Usually, quite large
<span class="math">\(k\)</span> values are needed to accurately represent the given functions
<span class="math">\(I\)</span> and <span class="math">\(f\)</span> and then <span class="math">\(\Delta t\)</span> needs to be very small for these large
values of <span class="math">\(k\)</span>.
Therefore, the Crank-Nicolson and Backward Euler schemes, which
allow larger <span class="math">\(\Delta t\)</span> without any growth in the solutions, are
more popular choices when creating time-stepping algorithms for
partial differential equations of the type considered in this
example.</p>
</div>
</div>
<div class="section" id="exercises-3">
<h2>Exercises  (3)<a class="headerlink" href="#exercises-3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-10-derive-schemes-for-newton-s-law-of-cooling">
<span id="decay-app-exer-cooling-schemes"></span><h3>Exercise 10: Derive schemes for Newton&#8217;s law of cooling<a class="headerlink" href="#exercise-10-derive-schemes-for-newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h3>
<p>Show in detail how we can apply the ideas of the Forward Euler,
Backward Euler, Crank-Nicolson, and <span class="math">\(\theta\)</span>-rule
discretizations to derive explicit
computational formulas for new temperature values in Newton&#8217;s law of
cooling (see the section <a class="reference internal" href="#decay-app-newton-cooling"><em>Newton&#8217;s law of cooling</em></a>):</p>
<div class="math" id="equation-decay:Newton:cooling">
<span class="eqno">(80)</span>\[     {dT\over dt} = -k(T-T_s),\quad T(0)=T_0{\thinspace .}\]</div>
<p>Here, <span class="math">\(T\)</span> is the temperature of the body, <span class="math">\(T_s\)</span> is the temperature
of the surroundings, <span class="math">\(t\)</span> is time, <span class="math">\(k\)</span> is the heat transfer
coefficient, and <span class="math">\(T_0\)</span> is the initial temperature of the body.
Filename: <tt class="docutils literal"><span class="pre">schemes_cooling.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-11-implement-schemes-for-newton-s-law-of-cooling">
<span id="decay-app-exer-cooling-py"></span><h3>Exercise 11: Implement schemes for Newton&#8217;s law of cooling<a class="headerlink" href="#exercise-11-implement-schemes-for-newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h3>
<p>Formulate a <span class="math">\(\theta\)</span>-rule for the three schemes in <a class="reference internal" href="#decay-app-exer-cooling-schemes"><em>Exercise 10: Derive schemes for Newton&#8217;s law of cooling</em></a> such that you can get the three
schemes from a single formula by varying the <span class="math">\(\theta\)</span> parameter.
Implement the method in a function <tt class="docutils literal"><span class="pre">cooling(T0,</span> <span class="pre">k,</span> <span class="pre">T_s,</span>
<span class="pre">t_end,</span> <span class="pre">dt,</span> <span class="pre">theta=0.5)</span></tt>, where <tt class="docutils literal"><span class="pre">T0</span></tt> is the initial temperature, <tt class="docutils literal"><span class="pre">k</span></tt> is
the heat transfer coefficient, <tt class="docutils literal"><span class="pre">T_s</span></tt> is the temperature of the
surroundings, <tt class="docutils literal"><span class="pre">t_end</span></tt> is the end time of the simulation, <tt class="docutils literal"><span class="pre">dt</span></tt> is the
time step, and <tt class="docutils literal"><span class="pre">theta</span></tt> corresponds to <span class="math">\(\theta\)</span>.  The <tt class="docutils literal"><span class="pre">cooling</span></tt>
function should return the temperature as an array <tt class="docutils literal"><span class="pre">T</span></tt> of values at
the mesh points and the time mesh <tt class="docutils literal"><span class="pre">t</span></tt>.  Construct verification
examples to check that the implementation works.</p>
<p><strong>Hint.</strong>
For verification, try to find an exact solution of the
discrete equations. A trick is to introduce <span class="math">\(u=T-T_s\)</span>, observe
that <span class="math">\(u^{n}=(T_0-T_s)A^n\)</span> for some amplification factor <span class="math">\(A\)</span>,
and then express this formula in terms of <span class="math">\(T^n\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">cooling.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-find-time-of-murder-from-body-temperature">
<span id="decay-app-exer-cooling-murder"></span><h3>Exercise 12: Find time of murder from body temperature<a class="headerlink" href="#exercise-12-find-time-of-murder-from-body-temperature" title="Permalink to this headline">¶</a></h3>
<p>A detective measures the temperature of a dead body to be 26.7 C at 2
pm. One hour later the temperature is 25.8 C. The question is when
death occurred.</p>
<p>Assume that Newton&#8217;s law of cooling <a href="#equation-decay:Newton:cooling">(80)</a> is an
appropriate mathematical model for the evolution of the temperature in
the body.  First, determine <span class="math">\(k\)</span> in <a href="#equation-decay:Newton:cooling">(80)</a> by
formulating a Forward Euler approximation with one time steep from
time 2 am to time 3 am, where knowing the two temperatures allows for
finding <span class="math">\(k\)</span>. Assume the temperature in the air to be 20 C. Thereafter,
simulate the temperature evolution from the time of murder, taken as
<span class="math">\(t=0\)</span>, when <span class="math">\(T=37\hbox{ C}\)</span>, until the temperature reaches 25.8 C. The
corresponding time allows for answering when death occurred.
Filename: <tt class="docutils literal"><span class="pre">detective.py</span></tt>.</p>
</div>
<div class="section" id="exercise-13-simulate-an-oscillating-cooling-process">
<span id="decay-app-exer-cooling-osc"></span><h3>Exercise 13: Simulate an oscillating cooling process<a class="headerlink" href="#exercise-13-simulate-an-oscillating-cooling-process" title="Permalink to this headline">¶</a></h3>
<p>The surrounding temperature <span class="math">\(T_s\)</span> in Newton&#8217;s law of cooling
<a href="#equation-decay:Newton:cooling">(80)</a> may vary in time. Assume that the
variations are periodic with period <span class="math">\(P\)</span> and amplitude <span class="math">\(a\)</span> around
a constant mean temperature <span class="math">\(T_m\)</span>:</p>
<div class="math">
\[T_s(t) = T_m + a\sin\left(\frac{2\pi}{P}t\right)
{\thinspace .}\]</div>
<p>Simulate a process with the following data: <span class="math">\(k=20 \hbox{ min}^{-1}\)</span>,
<span class="math">\(T(0)=5\)</span> C, <span class="math">\(T_m=25\)</span> C, <span class="math">\(a=2.5\)</span> C, and <span class="math">\(P=1\)</span> h. Also experiment with
<span class="math">\(P=10\)</span> min and <span class="math">\(P=3\)</span> h. Plot <span class="math">\(T\)</span> and <span class="math">\(T_s\)</span> in the same plot.
Filename: <tt class="docutils literal"><span class="pre">osc_cooling.py</span></tt>.</p>
</div>
<div class="section" id="exercise-14-radioactive-decay-of-carbon-14">
<span id="decay-app-exer-radio-c14"></span><h3>Exercise 14: Radioactive decay of Carbon-14<a class="headerlink" href="#exercise-14-radioactive-decay-of-carbon-14" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Carbon-14">Carbon-14</a> isotope,
whose radioactive decay is used extensively in dating organic material
that is tens of thousands of years old, has a half-life of <span class="math">\(5,730\)</span>
years.  Determine the age of an organic material that contains 8.4 percent
of its initial amount of Carbon-14.  Use a time unit of 1 year in the
computations.  The uncertainty in the half time of Carbon-14 is <span class="math">\(\pm
40\)</span> years.  What is the corresponding uncertainty in the estimate of
the age?</p>
<p><strong>Hint.</strong>
Use simulations with <span class="math">\(5,730\pm 40\)</span> y as input
and find the corresponding interval for the result.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">carbon14.py</span></tt>.</p>
</div>
<div class="section" id="exercise-15-simulate-stochastic-radioactive-decay">
<span id="decay-app-exer-stoch-nuclear"></span><h3>Exercise 15: Simulate stochastic radioactive decay<a class="headerlink" href="#exercise-15-simulate-stochastic-radioactive-decay" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to implement the stochastic model
described in the section <a class="reference internal" href="#decay-app-nuclear"><em>Radioactive Decay</em></a> and show that its
mean behavior approximates the solution of the corresponding
ODE model.</p>
<p>The simulation goes on for a time interval <span class="math">\([0,T]\)</span> divided into
<span class="math">\(N_t\)</span> intervals of length <span class="math">\(\Delta t\)</span>. We start with <span class="math">\(N_0\)</span>
atoms. In some time interval, we have <span class="math">\(N\)</span> atoms that have survived.
Simulate <span class="math">\(N\)</span> Bernoulli trials with probability <span class="math">\(\lambda\Delta t\)</span>
in this interval by drawing <span class="math">\(N\)</span> random numbers, each being 0 (survival)
or 1 (decay), where the probability of getting 1 is <span class="math">\(\lambda\Delta t\)</span>.
We are interested in the number of decays, <span class="math">\(d\)</span>, and the number of
survived atoms in the next interval is then <span class="math">\(N-d\)</span>.
The Bernoulli trials
are simulated by drawing <span class="math">\(N\)</span> uniformly distributed real numbers on
<span class="math">\([0,1]\)</span> and saying that 1 corresponds to a value less than <span class="math">\(\lambda\Delta t\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given lambda_, dt, N</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">uniform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">Bernoulli_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">uniform</span> <span class="o">&lt;</span> <span class="n">lambda_</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Bernoulli_trials</span><span class="o">.</span><span class="n">size</span>
</pre></div>
</div>
<p>Observe that <tt class="docutils literal"><span class="pre">uniform</span> <span class="pre">&lt;</span> <span class="pre">lambda_*dt</span></tt> is a boolean array whose true
and false values become 1 and 0, respectively, when converted to an
integer array.</p>
<p>Repeat the simulation over <span class="math">\([0,T]\)</span> a large number of times, compute the average
value of <span class="math">\(N\)</span> in each interval, and compare with the solution of
the corresponding ODE model.
Filename: <tt class="docutils literal"><span class="pre">stochastic_decay.py</span></tt>.</p>
</div>
<div class="section" id="exercise-16-radioactive-decay-of-two-substances">
<span id="decay-app-exer-radio-twosubst"></span><h3>Exercise 16: Radioactive decay of two substances<a class="headerlink" href="#exercise-16-radioactive-decay-of-two-substances" title="Permalink to this headline">¶</a></h3>
<p>Consider two radioactive substances A and B. The nuclei in substance A
decay to form nuclei of type B with a half-life <span class="math">\(A_{1/2}\)</span>, while
substance B decay to form type A nuclei with a half-life <span class="math">\(B_{1/2}\)</span>.
Letting <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> be the fractions of the initial amount of
material in substance A and B, respectively, the following system of
ODEs governs the evolution of <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>:</p>
<div class="math">
\[\frac{1}{\ln 2} u_A' = u_B/B_{1/2} - u_A/A_{1/2},\]</div>
<div class="math">
\[\frac{1}{\ln 2} u_B' = u_A/A_{1/2} - u_B/B_{1/2},\]</div>
<p>with <span class="math">\(u_A(0)=u_B(0)=1\)</span>.</p>
<p>Make a simulation program that solves for <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>.
Verify the implementation by computing analytically
the limiting values of
<span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> as <span class="math">\(t\rightarrow \infty\)</span> (assume <span class="math">\(u_A',u_B'\rightarrow 0\)</span>)
and comparing these with those obtained numerically.</p>
<p>Run the program for the case of <span class="math">\(A_{1/2}=10\)</span> minutes and <span class="math">\(B_{1/2}=50\)</span> minutes.
Use a time unit of 1 minute. Plot <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> versus time in the same
plot.
Filename: <tt class="docutils literal"><span class="pre">radioactive_decay_2subst.py</span></tt>.</p>
</div>
<div class="section" id="exercise-17-simulate-the-pressure-drop-in-the-atmosphere">
<span id="decay-app-exer-atm1"></span><h3>Exercise 17: Simulate the pressure drop in the atmosphere<a class="headerlink" href="#exercise-17-simulate-the-pressure-drop-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>We consider the models for atmospheric pressure in
the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>.
Make a program with three functions,</p>
<blockquote>
<div><ul class="simple">
<li>one computing the pressure <span class="math">\(p(z)\)</span> using a seven-layer model
and varying <span class="math">\(L\)</span>,</li>
<li>one computing <span class="math">\(p(z)\)</span> using a seven-layer model,
but with constant temperature in each layer, and</li>
<li>one computing <span class="math">\(p(z)\)</span> based on the
one-layer model.</li>
</ul>
</div></blockquote>
<p>How can these implementations be verified? Should ease of verification
impact how you code the functions?
Compare the three models in a plot.
Filename: <tt class="docutils literal"><span class="pre">atmospheric_pressure.py</span></tt>.</p>
</div>
<div class="section" id="exercise-18-make-a-program-for-vertical-motion-in-a-fluid">
<span id="decay-app-exer-drag-prog"></span><h3>Exercise 18: Make a program for vertical motion in a fluid<a class="headerlink" href="#exercise-18-make-a-program-for-vertical-motion-in-a-fluid" title="Permalink to this headline">¶</a></h3>
<p>Implement the Stokes&#8217; drag model <a href="#equation-decay:app:fallingbody:model:S">(74)</a>
and the quadratic drag model <a href="#equation-decay:app:fallingbody:model:q">(76)</a> from
the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>, using the Crank-Nicolson
scheme and a geometric mean for <span class="math">\(|v|v\)</span> as explained, and assume
constant fluid density.
At each time level, compute the Reynolds number
Re and choose the Stokes&#8217; drag model if <span class="math">\(\hbox{Re} &lt; 1\)</span> and the
quadratic drag model otherwise.</p>
<p>The computation of the numerical solution should take place either in
a stand-alone function (as in the section <a class="reference internal" href="#decay-py1"><em>Making a solver function</em></a>) or in a solver class
that looks up a problem class for physical data (as in the section <em class="xref std std-ref">decay:prog:se:class</em>). Create a module (see the section <em class="xref std std-ref">decay:prog:se:module</em>) and equip it with nose tests (see the section <em class="xref std std-ref">decay:prog:se:nose</em>) for automatically verifying the code.</p>
<p>Verification tests can be based on</p>
<blockquote>
<div><ul class="simple">
<li>the terminal velocity (see the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>),</li>
<li>the exact solution when the drag force is neglected
(see the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>),</li>
<li>the method of manufactured solutions (see the section <a class="reference internal" href="#decay-mms"><em>Verification via manufactured solutions</em></a>)
combined with computing
convergence rates (see the section <em class="xref std std-ref">decay:convergence:rate</em>).</li>
</ul>
</div></blockquote>
<p>Use, e.g., a quadratic polynomial for the velocity in the method of
manufactured solutions. The expected error is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>
from the centered finite difference approximation and the geometric
mean approximation for <span class="math">\(|v|v\)</span>.</p>
<p>A solution that is linear in <span class="math">\(t\)</span> will also be an exact solution of the
discrete equations in many problems.  Show that this is true for
linear drag (by adding a source term that depends on <span class="math">\(t\)</span>), but not
for quadratic drag because of the geometric mean approximation.  Use
the method of manufactured solutions to add a source term <em>in the
discrete equations for quadratic drag</em> such that a linear function of
<span class="math">\(t\)</span> is a solution. Add a nose test for checking that the linear
function is reproduced to machine precision in the case of both linear
and quadratic drag.</p>
<p>Apply the software to a case where a ball rises in water.  The
buoyancy force is here the driving force, but the drag will be
significant and balance the other forces after a short time.  A soccer
ball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set
the density of water, <span class="math">\(\varrho\)</span>, to <span class="math">\(1000\hbox{ kg/m}^3\)</span>, set the
dynamic viscosity, <span class="math">\(\mu\)</span>, to <span class="math">\(10^{-3}\hbox{ Pa s}\)</span>, and use a drag
coefficient for a sphere: 0.45. Plot the velocity of the rising ball.
Filename: <tt class="docutils literal"><span class="pre">vertical_motion.py</span></tt>.</p>
</div>
<div class="section" id="project-19-simulate-parachuting">
<span id="decay-app-exer-parachute"></span><h3>Project 19: Simulate parachuting<a class="headerlink" href="#project-19-simulate-parachuting" title="Permalink to this headline">¶</a></h3>
<p>The aim of this project is to develop a general solver for the
vertical motion of a body with quadratic air drag, verify the solver,
apply the solver to a skydiver in free fall, and finally apply the
solver to a complete parachute jump.</p>
<p>All the pieces of software implemented in this project
should be realized as Python functions and/or classes and collected
in one module.</p>
<p><strong>a)</strong>
Set up the differential equation problem that governs the velocity
of the motion.
The parachute jumper is subject to the gravity force and a quadratic
drag force. Assume constant density.
Add an extra source term be used for program verification.
Identify the input data to the problem.</p>
<p><strong>b)</strong>
Make a Python module for computing the velocity of the motion.
Also equip the module with functionality for plotting the velocity.</p>
<p><strong>Hint 1.</strong>
Use the Crank-Nicolson scheme with a geometric mean of <span class="math">\(|v|v\)</span> in time to
linearize the equation of motion with quadratic drag.</p>
<p><strong>Hint 2.</strong>
You can either use functions or classes for implementation.
If you choose functions, make a function
<tt class="docutils literal"><span class="pre">solver</span></tt> that takes all the input data in the problem as
arguments and that returns the velocity (as a mesh function) and
the time mesh. In case of a class-based implementation, introduce
a problem class with the physical data
and a solver class with the numerical data and a <tt class="docutils literal"><span class="pre">solve</span></tt> method
that stores the velocity and the mesh in the class.</p>
<p>Allow for a time-dependent area and drag coefficient in the
formula for the drag force.</p>
<p><strong>c)</strong>
Show that a linear function of <span class="math">\(t\)</span> does not fulfill the discrete
equations because of the geometric mean approximation
used for the quadratic drag
term.  Fit a source term, as in the method of manufactured solutions,
such that a linear function of <span class="math">\(t\)</span> is a solution of the discrete
equations. Make a nose test to check that this solution is reproduced
to machine precision.</p>
<p><strong>d)</strong>
The expected error in this problem goes like <span class="math">\(\Delta t^2\)</span> because we
use a centered finite difference approximation with error <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>
and a geometric mean approximation with error <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.
Use the method of manufactured solutions combined with computing
convergence rate to verify the code. Make a nose test for checking
that the convergence rate is correct.</p>
<p><strong>e)</strong>
Compute the drag force, the gravity
force, and the buoyancy force as a function of time. Create
a plot with these three forces.</p>
<p><strong>Hint.</strong>
You can either make a function <tt class="docutils literal"><span class="pre">forces(v,</span> <span class="pre">t,</span> <span class="pre">plot=None)</span></tt>
that returns the forces (as mesh functions) and <tt class="docutils literal"><span class="pre">t</span></tt> and shows
a plot on the screen and also saves the plot to a file with name <tt class="docutils literal"><span class="pre">plot</span></tt>
if <tt class="docutils literal"><span class="pre">plot</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>, or you can extend the solver class with
computation of forces and include plotting of forces in the
visualization class.</p>
<p><strong>f)</strong>
Compute the velocity of
a skydiver in free fall before the parachute opens.</p>
<p><strong>Hint.</strong>
Meade and Struthers <a class="reference internal" href="#ref6" id="id6">[Ref6]</a> provide some data relevant
to <a class="reference external" href="http://en.wikipedia.org/wiki/Parachuting">skydiving</a>.
The mass of the human body and equipment
can be set to <span class="math">\(100\)</span> kg.
A skydiver in spread-eagle formation has a cross-section of 0.5 <span class="math">\(\hbox{m}^2\)</span>
in the horizontal plane.
The density of air decreases varies altitude, but can be taken
as constant, 1 <span class="math">\(\hbox{kg/m}^3\)</span>, for altitudes relevant to
skydiving (0-4000 m).
The drag coefficient for a man in upright position can be set to 1.2.
Start with a zero velocity.
A free fall typically has a terminating velocity of 45 m/s. (This value
can be used to tune other parameters.)</p>
<p><strong>g)</strong>
The next task is to simulate
a parachute jumper during free fall and after the parachute opens.
At time <span class="math">\(t_p\)</span>, the parachute opens and
the drag coefficient and the cross-sectional
area change dramatically.
Use the program to simulate a jump from <span class="math">\(z=3000\)</span> m to the ground <span class="math">\(z=0\)</span>.
What is the maximum acceleration, measured in units of <span class="math">\(g\)</span>,
experienced by the jumper?</p>
<p><strong>Hint.</strong>
Following Meade and Struthers <a class="reference internal" href="#ref6" id="id7">[Ref6]</a>, one can set the
cross-section area perpendicular to the motion to 44 <span class="math">\(\hbox{m}^2\)</span>
when the parachute is open. Assume that it takes 8 s to increase
the area linearly from the original to the final value.
The drag coefficient for an open
parachute can be taken as 1.8, but tuned using the known value
of the typical terminating velocity reached before landing:
5.3 m/s. One can take the drag coefficient as a piecewise constant
function with an abrupt change at <span class="math">\(t_p\)</span>.
The parachute is typically released after <span class="math">\(t_p=60\)</span> s, but
larger values of <span class="math">\(t_p\)</span> can be used to make plots more illustrative.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">skydiving.py</span></tt>.</p>
</div>
<div class="section" id="exercise-20-formulate-vertical-motion-in-the-atmosphere">
<span id="decay-app-exer-drag-atm1"></span><h3>Exercise 20: Formulate vertical motion in the atmosphere<a class="headerlink" href="#exercise-20-formulate-vertical-motion-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>Vertical motion of a body in the atmosphere needs to take into
account a varying air density if the range of altitudes is
many kilometers. In this case, <span class="math">\(\varrho\)</span> varies with the altitude <span class="math">\(z\)</span>.
The equation of motion for the body is given in
the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>. Let us assume quadratic drag force
(otherwise the body has to be very, very small).
A differential equation problem for the air density, based on
the information for the one-layer atmospheric model in
the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>, can be set up as</p>
<div class="math">
\[p'(z) = -\frac{Mg}{R^*(T_0+Lz)} p,\]</div>
<div class="math">
\[\varrho = p \frac{M}{R^*T}
{\thinspace .}\]</div>
<p>To evaluate <span class="math">\(p(z)\)</span> we need the altitude <span class="math">\(z\)</span>. From the principle that the
velocity is the derivative of the position we have that</p>
<div class="math">
\[z'(t) = v(t),\]</div>
<p>where <span class="math">\(v\)</span> is the velocity of the body.</p>
<p>Explain in detail how the governing equations can be discretized
by the Forward Euler and the Crank-Nicolson methods.
Filename: <tt class="docutils literal"><span class="pre">falling_in_variable_density.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-21-simulate-vertical-motion-in-the-atmosphere">
<span id="decay-app-exer-drag-atm2"></span><h3>Exercise 21: Simulate vertical motion in the atmosphere<a class="headerlink" href="#exercise-21-simulate-vertical-motion-in-the-atmosphere" title="Permalink to this headline">¶</a></h3>
<p>Implement the Forward Euler or the Crank-Nicolson scheme
derived in <a class="reference internal" href="#decay-app-exer-drag-atm1"><em>Exercise 20: Formulate vertical motion in the atmosphere</em></a>.
Demonstrate the effect of air density variation on a falling
human, e.g., the famous fall of <a class="reference external" href="http://en.wikipedia.org/wiki/Felix_Baumgartner">Felix Baumgartner</a>. The drag coefficient can be set to 1.2.</p>
<p><strong>Remark.</strong>
In the Crank-Nicolson scheme one must solve a <span class="math">\(3\times 3\)</span> system of
equations at each time level, since <span class="math">\(p\)</span>, <span class="math">\(\varrho\)</span>, and <span class="math">\(v\)</span> are
coupled, while each equation can be stepped forward at a time with the
Forward Euler scheme.
Filename: <tt class="docutils literal"><span class="pre">falling_in_variable_density.py</span></tt>.</p>
</div>
<div class="section" id="exercise-22-compute-by-solving-an-ode">
<span id="decay-app-exer-signum"></span><h3>Exercise 22: Compute <span class="math">\(y=|x|\)</span> by solving an ODE<a class="headerlink" href="#exercise-22-compute-by-solving-an-ode" title="Permalink to this headline">¶</a></h3>
<p>Consider the ODE problem</p>
<div class="math">
\[\begin{split}y'(x) = \left\lbrace\begin{array}{ll}
-1, &amp; x &lt; 0,\\
1, &amp; x \geq 0
\end{array}\right.\quad x\in (-1, 1],
\quad y(1-)=1,\end{split}\]</div>
<p>which has the solution <span class="math">\(y(x)=|x|\)</span>.
Using a mesh <span class="math">\(x_0=-1\)</span>, <span class="math">\(x_1=0\)</span>, and <span class="math">\(x_2=1\)</span>, calculate by hand
<span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span> from the Forward Euler, Backward Euler, Crank-Nicolson,
and Leapfrog methods. Use all of the former three methods for computing
the <span class="math">\(y_1\)</span> value to be used in the Leapfrog calculation of <span class="math">\(y_2\)</span>.
Thereafter, visualize how these schemes perform for a uniformly partitioned
mesh with <span class="math">\(N=10\)</span> and <span class="math">\(N=11\)</span> points.
Filename: <tt class="docutils literal"><span class="pre">signum.py</span></tt>.</p>
</div>
<div class="section" id="exercise-23-simulate-growth-of-a-fortune-with-random-interest-rate">
<span id="decay-app-exer-interest"></span><h3>Exercise 23: Simulate growth of a fortune with random interest rate<a class="headerlink" href="#exercise-23-simulate-growth-of-a-fortune-with-random-interest-rate" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to compute the value of a fortune subject
to inflation and a random interest rate.
Suppose that the inflation is constant at <span class="math">\(i\)</span> percent per year and that the
annual interest rate, <span class="math">\(p\)</span>, changes randomly at each time step,
starting at some value <span class="math">\(p_0\)</span> at <span class="math">\(t=0\)</span>.
The random change is from a value <span class="math">\(p^n\)</span> at <span class="math">\(t=t_n\)</span> to
<span class="math">\(p_n +\Delta p\)</span> with probability 0.25 and <span class="math">\(p_n -\Delta p\)</span> with probability 0.25.
No change occurs with probability 0.5. There is also no change if
<span class="math">\(p^{n+1}\)</span> exceeds 15 or becomes below 1.
Use a time step of one month, <span class="math">\(p_0=i\)</span>, initial fortune scaled to 1,
and simulate 1000 scenarios of
length 20 years. Compute the mean evolution of one unit of money and the
corresponding
standard deviation. Plot the mean curve along with the mean plus one
standard deviation and the mean minus one standard deviation. This will
illustrate the uncertainty in the mean curve.</p>
<p><strong>Hint 1.</strong>
The following code snippet computes <span class="math">\(p^{n+1}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">new_interest_rate</span><span class="p">(</span><span class="n">p_n</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>  <span class="c"># uniformly distr. random number in [0,1)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.25</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">+</span> <span class="n">dp</span>
    <span class="k">elif</span> <span class="mf">0.25</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">-</span> <span class="n">dp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p_np1</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">p_np1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="k">else</span> <span class="n">p_n</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Hint 2.</strong>
If <span class="math">\(u_i(t)\)</span> is the value of the fortune in experiment number <span class="math">\(i\)</span>,
<span class="math">\(i=0,\ldots,N-1\)</span>,
the mean evolution of the fortune is</p>
<div class="math">
\[\bar u(t)= \frac{1}{N}\sum_{i=0}^{N-1} u_i(t),\]</div>
<p>and the standard deviation is</p>
<div class="math">
\[s(t) = \sqrt{\frac{1}{N-1}\left(- (\bar u(t))^2 +
                \sum_{i=0}^{N-1} (u_i(t))^2\right)}
{\thinspace .}\]</div>
<p>Suppose <span class="math">\(u_i(t)\)</span> is stored in an array <tt class="docutils literal"><span class="pre">u</span></tt>.
The mean and the standard deviation of the fortune
is most efficiently computed by
using two accumulation arrays, <tt class="docutils literal"><span class="pre">sum_u</span></tt> and <tt class="docutils literal"><span class="pre">sum_u2</span></tt>, and
performing <tt class="docutils literal"><span class="pre">sum_u</span> <span class="pre">+=</span> <span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">sum_u2</span> <span class="pre">+=</span> <span class="pre">u**2</span></tt> after every experiment.
This technique avoids storing all the <span class="math">\(u_i(t)\)</span> time series for
computing the statistics.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">random_interest.py</span></tt>.</p>
</div>
<div class="section" id="exercise-24-simulate-a-population-in-a-changing-environment">
<span id="decay-app-exer-pop-at"></span><h3>Exercise 24: Simulate a population in a changing environment<a class="headerlink" href="#exercise-24-simulate-a-population-in-a-changing-environment" title="Permalink to this headline">¶</a></h3>
<p>We shall study a population modeled by <a href="#equation-decay:app:pop:ueq">(65)</a> where
the environment, represented by <span class="math">\(r\)</span> and <span class="math">\(f\)</span>, undergoes changes with time.</p>
<p><strong>a)</strong>
Assume that there is a sudden drop (increase) in the birth (death)
rate at time <span class="math">\(t=t_r\)</span>,
because of limited nutrition or food supply:</p>
<div class="math">
\[\begin{split}a(t) =\left\lbrace\begin{array}{ll}
r_0, &amp; t&lt; t_r,\\
r_0 - A, &amp; t\geq t_r,\end{array}\right.\end{split}\]</div>
<p>This drop in population growth is compensated by a sudden net immigration
at time <span class="math">\(t_f&gt;t_r\)</span>:</p>
<div class="math">
\[\begin{split}f(t) =\left\lbrace\begin{array}{ll}
0, &amp; t&lt; t_f,\\
f_0, &amp; t\geq t_a,\end{array}\right.\end{split}\]</div>
<p>Start with <span class="math">\(r_0\)</span> and make <span class="math">\(A&gt;r_0\)</span>. Experiment with
these and other parameters to
illustrate the interplay of growth and decay in such a problem.
Filename: <tt class="docutils literal"><span class="pre">population_drop.py</span></tt>.</p>
<p><strong>b)</strong>
Now we assume that the environmental conditions changes periodically with
time so that we may take</p>
<div class="math">
\[r(t) = r_0 + A\sin\left(\frac{2\pi}{P}t\right)
{\thinspace .}\]</div>
<p>That is, the combined birth and death rate oscillates around <span class="math">\(r_0\)</span> with
a maximum change of <span class="math">\(\pm A\)</span> repeating over a period of length <span class="math">\(P\)</span> in time.
Set <span class="math">\(f=0\)</span> and experiment with the other parameters to illustrate typical
features of the solution.
Filename: <tt class="docutils literal"><span class="pre">population_osc.py</span></tt>.</p>
</div>
<div class="section" id="exercise-25-simulate-logistic-growth">
<span id="decay-app-exer-pop-logistic1"></span><h3>Exercise 25: Simulate logistic growth<a class="headerlink" href="#exercise-25-simulate-logistic-growth" title="Permalink to this headline">¶</a></h3>
<p>Solve the logistic ODE
<a href="#equation-decay:app:pop:logistic">(66)</a> using a Crank-Nicolson scheme where
<span class="math">\((u^{n+\frac{1}{2}})^2\)</span> is approximated by a <em>geometric mean</em>:</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2 \approx u^{n+1}u^n
{\thinspace .}\]</div>
<p>This trick makes the discrete equation linear in <span class="math">\(u^{n+1}\)</span>.
Filename: <tt class="docutils literal"><span class="pre">logistic_CN.py</span></tt>.</p>
</div>
<div class="section" id="exercise-26-rederive-the-equation-for-continuous-compound-interest">
<span id="decay-app-exer-interest-derive"></span><h3>Exercise 26: Rederive the equation for continuous compound interest<a class="headerlink" href="#exercise-26-rederive-the-equation-for-continuous-compound-interest" title="Permalink to this headline">¶</a></h3>
<p>The ODE model <a href="#equation-decay:app:interest:eq2">(68)</a> was derived under the assumption
that <span class="math">\(r\)</span> was constant. Perform an alternative derivation without
this assumption: 1) start with <a href="#equation-decay:app:interest:eq1">(67)</a>;
2) introduce a time step <span class="math">\(\Delta t\)</span> instead of <span class="math">\(m\)</span>: <span class="math">\(\Delta t = 1/m\)</span> if
<span class="math">\(t\)</span> is measured in years; 3) divide by <span class="math">\(\Delta t\)</span> and take the
limit <span class="math">\(\Delta t\rightarrow 0\)</span>. Simulate a case where the inflation is
at a constant level <span class="math">\(I\)</span> percent per year and the interest rate oscillates:
<span class="math">\(r=-I/2 + r_0\sin(2\pi t)\)</span>.
Compare solutions for <span class="math">\(r_0=I, 3I/2, 2I\)</span>.
Filename: <tt class="docutils literal"><span class="pre">interest_modeling.py</span></tt>.</p>
</div>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Ref1]</a></td><td><strong>H. P. Langtangen</strong>. <em>A Primer on Scientific Programming With Python</em>,
Springer,
2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Ref2]</a></td><td><strong>L. Petzold and U. M. Ascher</strong>. <em>Computer Methods for Ordinary Differential Equations and Differential-Algebraic Equations</em>,
SIAM,
1998.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Ref3]</a></td><td><strong>D. Griffiths, F. David and D. J. Higham</strong>. <em>Numerical Methods for Ordinary Differential Equations: Initial Value Problems</em>,
Springer,
2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Ref4]</a></td><td><strong>E. Hairer, S. P. Norsett and G. Wanner</strong>. <em>Solving Ordinary Differential Equations I. Nonstiff Problems</em>,
Springer,
1993.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[Ref5]</a></td><td><strong>G. Hairer and E. Wanner</strong>. <em>Solving Ordinary Differential Equations II</em>,
Springer,
2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref6]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> <strong>D. B. Meade and A. A. Struthers</strong>. Differential Equations in the New Millenium: the Parachute Problem,
<em>International Journal of Engineering Education</em>,
15(6),
pp. 417-424,
1999,
<a class="reference external" href="http://www.matematicas.unam.mx/gfgf/ode/ode_files/parachute.pdf">http://www.matematicas.unam.mx/gfgf/ode/ode_files/parachute.pdf</a>.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction to computing with finite difference methods</a><ul>
<li><a class="reference internal" href="#finite-difference-methods">Finite difference methods</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-exponential-decay">A basic model for exponential decay</a></li>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-rule">The unifying <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#constant-time-step">Constant time step</a></li>
<li><a class="reference internal" href="#compact-operator-notation-for-finite-differences">Compact operator notation for finite differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#function-for-computing-the-numerical-solution">Function for computing the numerical solution</a></li>
<li><a class="reference internal" href="#integer-division">Integer division</a></li>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
<li><a class="reference internal" href="#formatting-of-numbers">Formatting of numbers</a></li>
<li><a class="reference internal" href="#running-the-program">Running the program</a></li>
<li><a class="reference internal" href="#plotting-the-solution">Plotting the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-the-implementation">Verifying the implementation</a><ul>
<li><a class="reference internal" href="#running-a-few-algorithmic-steps-by-hand">Running a few algorithmic steps by hand</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-numerical-error-as-a-mesh-function">Computing the numerical error as a mesh function</a></li>
<li><a class="reference internal" href="#computing-the-norm-of-the-numerical-error">Computing the norm of the numerical error</a><ul>
<li><a class="reference internal" href="#scalar-computing">Scalar computing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plotting-solutions">Plotting solutions</a></li>
<li><a class="reference internal" href="#experiments-with-computing-and-plotting">Experiments with computing and plotting</a><ul>
<li><a class="reference internal" href="#combining-plot-files">Combining plot files</a></li>
<li><a class="reference internal" href="#plotting-with-scitools">Plotting with SciTools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-saving-implementation">Memory-saving implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-finite-difference-equations">Analysis of finite difference equations</a><ul>
<li><a class="reference internal" href="#experimental-investigation-of-oscillatory-solutions">Experimental investigation of oscillatory solutions</a></li>
<li><a class="reference internal" href="#exact-numerical-solution">Exact numerical solution</a></li>
<li><a class="reference internal" href="#stability">Stability</a></li>
<li><a class="reference internal" href="#comparing-amplification-factors">Comparing amplification factors</a></li>
<li><a class="reference internal" href="#series-expansion-of-amplification-factors">Series expansion of amplification factors</a></li>
<li><a class="reference internal" href="#the-fraction-of-numerical-and-exact-amplification-factors">The fraction of numerical and exact amplification factors</a></li>
<li><a class="reference internal" href="#the-global-error-at-a-point">The global error at a point</a></li>
<li><a class="reference internal" href="#integrated-errors">Integrated errors</a></li>
<li><a class="reference internal" href="#truncation-error">Truncation error</a></li>
<li><a class="reference internal" href="#consistency-stability-and-convergence">Consistency, stability, and convergence</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-1">Exercises  (1)</a><ul>
<li><a class="reference internal" href="#exercise-1-visualize-the-accuracy-of-finite-differences">Exercise 1: Visualize the accuracy of finite differences</a></li>
<li><a class="reference internal" href="#exercise-2-explore-the-rule-for-exponential-growth">Exercise 2: Explore the <span class="math">\(\theta\)</span>-rule for exponential growth</a></li>
</ul>
</li>
<li><a class="reference internal" href="#model-extensions">Model extensions</a><ul>
<li><a class="reference internal" href="#generalization-including-a-variable-coefficient">Generalization: including a variable coefficient</a></li>
<li><a class="reference internal" href="#generalization-including-a-source-term">Generalization: including a source term</a><ul>
<li><a class="reference internal" href="#schemes">Schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-the-generalized-model-problem">Implementation of the generalized model problem</a><ul>
<li><a class="reference internal" href="#deriving-the-rule-formula">Deriving the <span class="math">\(\theta\)</span>-rule formula</a></li>
<li><a class="reference internal" href="#the-python-code">The Python code</a></li>
<li><a class="reference internal" href="#coding-of-variable-coefficients">Coding of variable coefficients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-a-constant-solution">Verifying a constant solution</a></li>
<li><a class="reference internal" href="#verification-via-manufactured-solutions">Verification via manufactured solutions</a></li>
<li><a class="reference internal" href="#extension-to-systems-of-odes">Extension to systems of ODEs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-first-order-odes">General first-order ODEs</a><ul>
<li><a class="reference internal" href="#generic-form-of-first-order-odes">Generic form of first-order ODEs</a></li>
<li><a class="reference internal" href="#the-rule">The <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#an-implicit-2-step-backward-scheme">An implicit 2-step backward scheme</a></li>
<li><a class="reference internal" href="#leapfrog-schemes">Leapfrog schemes</a><ul>
<li><a class="reference internal" href="#the-ordinary-leapfrog-scheme">The ordinary Leapfrog scheme</a></li>
<li><a class="reference internal" href="#the-filtered-leapfrog-scheme">The filtered Leapfrog scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-2nd-order-runge-kutta-method">The 2nd-order Runge-Kutta method</a></li>
<li><a class="reference internal" href="#a-2nd-order-taylor-series-method">A 2nd-order Taylor-series method</a></li>
<li><a class="reference internal" href="#the-2nd-and-3rd-order-adams-bashforth-schemes">The 2nd- and 3rd-order Adams-Bashforth schemes</a></li>
<li><a class="reference internal" href="#the-4th-order-runge-kutta-method">The 4th-order Runge-Kutta method</a></li>
<li><a class="reference internal" href="#the-odespy-software">The Odespy software</a></li>
<li><a class="reference internal" href="#example-runge-kutta-methods">Example: Runge-Kutta methods</a><ul>
<li><a class="reference internal" href="#remark-about-using-the-rule-in-odespy">Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-adaptive-runge-kutta-methods">Example: Adaptive Runge-Kutta methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-2">Exercises  (2)</a><ul>
<li><a class="reference internal" href="#exercise-3-experiment-with-precision-in-tests-and-the-size-of">Exercise 3: Experiment with precision in tests and the size of <span class="math">\(u\)</span></a></li>
<li><a class="reference internal" href="#exercise-4-implement-the-2-step-backward-scheme">Exercise 4: Implement the 2-step backward scheme</a></li>
<li><a class="reference internal" href="#exercise-5-implement-the-2nd-order-adams-bashforth-scheme">Exercise 5: Implement the 2nd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-6-implement-the-3rd-order-adams-bashforth-scheme">Exercise 6: Implement the 3rd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-7-analyze-explicit-2nd-order-methods">Exercise 7: Analyze explicit 2nd-order methods</a></li>
<li><a class="reference internal" href="#problem-8-implement-and-investigate-the-leapfrog-scheme">Problem 8: Implement and investigate the Leapfrog scheme</a></li>
<li><a class="reference internal" href="#problem-9-make-a-unified-implementation-of-many-schemes">Problem 9: Make a unified implementation of many schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applications-of-exponential-decay-models">Applications of exponential decay models</a><ul>
<li><a class="reference internal" href="#scaling-1">Scaling  (1)</a></li>
<li><a class="reference internal" href="#evolution-of-a-population">Evolution of a population</a></li>
<li><a class="reference internal" href="#compound-interest-and-inflation">Compound interest and inflation</a></li>
<li><a class="reference internal" href="#radioactive-decay">Radioactive Decay</a><ul>
<li><a class="reference internal" href="#deterministic-model">Deterministic model</a></li>
<li><a class="reference internal" href="#stochastic-model">Stochastic model</a></li>
<li><a class="reference internal" href="#relation-between-stochastic-and-deterministic-models">Relation between stochastic and deterministic models</a></li>
</ul>
</li>
<li><a class="reference internal" href="#newton-s-law-of-cooling">Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#decay-of-atmospheric-pressure-with-altitude">Decay of atmospheric pressure with altitude</a><ul>
<li><a class="reference internal" href="#multiple-atmospheric-layers">Multiple atmospheric layers</a></li>
<li><a class="reference internal" href="#simplification">Simplification: <span class="math">\(L=0\)</span></a></li>
<li><a class="reference internal" href="#simplification-one-layer-model">Simplification: one-layer model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compaction-of-sediments">Compaction of sediments</a></li>
<li><a class="reference internal" href="#vertical-motion-of-a-body-in-a-viscous-fluid">Vertical motion of a body in a viscous fluid</a><ul>
<li><a class="reference internal" href="#overview-of-forces">Overview of forces</a></li>
<li><a class="reference internal" href="#equation-of-motion">Equation of motion</a></li>
<li><a class="reference internal" href="#terminal-velocity">Terminal velocity</a></li>
<li><a class="reference internal" href="#a-crank-nicolson-scheme">A Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#physical-data">Physical data</a></li>
<li><a class="reference internal" href="#verification">Verification</a></li>
<li><a class="reference internal" href="#scaling-2">Scaling  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#decay-odes-from-solving-a-pde-by-fourier-expansions">Decay ODEs from solving a PDE by Fourier expansions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-3">Exercises  (3)</a><ul>
<li><a class="reference internal" href="#exercise-10-derive-schemes-for-newton-s-law-of-cooling">Exercise 10: Derive schemes for Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#exercise-11-implement-schemes-for-newton-s-law-of-cooling">Exercise 11: Implement schemes for Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#exercise-12-find-time-of-murder-from-body-temperature">Exercise 12: Find time of murder from body temperature</a></li>
<li><a class="reference internal" href="#exercise-13-simulate-an-oscillating-cooling-process">Exercise 13: Simulate an oscillating cooling process</a></li>
<li><a class="reference internal" href="#exercise-14-radioactive-decay-of-carbon-14">Exercise 14: Radioactive decay of Carbon-14</a></li>
<li><a class="reference internal" href="#exercise-15-simulate-stochastic-radioactive-decay">Exercise 15: Simulate stochastic radioactive decay</a></li>
<li><a class="reference internal" href="#exercise-16-radioactive-decay-of-two-substances">Exercise 16: Radioactive decay of two substances</a></li>
<li><a class="reference internal" href="#exercise-17-simulate-the-pressure-drop-in-the-atmosphere">Exercise 17: Simulate the pressure drop in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-18-make-a-program-for-vertical-motion-in-a-fluid">Exercise 18: Make a program for vertical motion in a fluid</a></li>
<li><a class="reference internal" href="#project-19-simulate-parachuting">Project 19: Simulate parachuting</a></li>
<li><a class="reference internal" href="#exercise-20-formulate-vertical-motion-in-the-atmosphere">Exercise 20: Formulate vertical motion in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-21-simulate-vertical-motion-in-the-atmosphere">Exercise 21: Simulate vertical motion in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-22-compute-by-solving-an-ode">Exercise 22: Compute <span class="math">\(y=|x|\)</span> by solving an ODE</a></li>
<li><a class="reference internal" href="#exercise-23-simulate-growth-of-a-fortune-with-random-interest-rate">Exercise 23: Simulate growth of a fortune with random interest rate</a></li>
<li><a class="reference internal" href="#exercise-24-simulate-a-population-in-a-changing-environment">Exercise 24: Simulate a population in a changing environment</a></li>
<li><a class="reference internal" href="#exercise-25-simulate-logistic-growth">Exercise 25: Simulate logistic growth</a></li>
<li><a class="reference internal" href="#exercise-26-rederive-the-equation-for-continuous-compound-interest">Exercise 26: Rederive the equation for continuous compound interest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Introduction to computing with finite difference methods</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/main_decay.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Introduction to computing with finite difference methods"
             >previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>