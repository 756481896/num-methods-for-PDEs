
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Approximation of functions</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Approximation of functions" href="index.html" />
    <link rel="next" title="Finite element basis functions" href="._main_approx004.html" />
    <link rel="prev" title="Approximation of vectors" href="._main_approx002.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_approx004.html" title="Finite element basis functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_approx002.html" title="Approximation of vectors"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Approximation of functions</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="approximation-of-functions">
<span id="fem-approx-global"></span><h1>Approximation of functions<a class="headerlink" href="#approximation-of-functions" title="Permalink to this headline">¶</a></h1>
<p id="index-0">Let <span class="math">\(V\)</span> be a function space spanned by a set of <em>basis functions</em>
<span class="math">\({\psi}_0,\ldots,{\psi}_N\)</span>,</p>
<div class="math">
\[V = \hbox{span}\,\{{\psi}_0,\ldots,{\psi}_N\},\]</div>
<p>such that any function <span class="math">\(u\in V\)</span> can be written as a linear
combination of the basis functions:</p>
<div class="math" id="equation-fem:approx:ufem">
<span id="eq-fem-approx-ufem"></span><span class="eqno">(1)</span>\[     u = \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j{\thinspace .}\]</div>
<p>The index set <span class="math">\({\mathcal{I}_s}\)</span> is defined as <span class="math">\({\mathcal{I}_s} =\{0,\ldots,N\}\)</span> and is
from now on used
both for compact notation and for flexibility in the numbering of
elements in sequences.</p>
<p>For now, in this introduction, we shall look at functions of a
single variable <span class="math">\(x\)</span>:
<span class="math">\(u=u(x)\)</span>, <span class="math">\({\psi}_j={\psi}_j(x)\)</span>, <span class="math">\(j\in{\mathcal{I}_s}\)</span>. Later, we will almost
trivially extend the mathematical details
to functions of two- or three-dimensional physical spaces.
The approximation <a href="#equation-fem:approx:ufem">(1)</a> is typically used
to discretize a problem in space. Other methods, most notably
finite differences, are common for time discretization, although the
form <a href="#equation-fem:approx:ufem">(1)</a> can be used in time as well.</p>
<div class="section" id="the-least-squares-method-3">
<span id="fem-approx-ls"></span><h2>The least squares method  (3)<a class="headerlink" href="#the-least-squares-method-3" title="Permalink to this headline">¶</a></h2>
<p>Given a function <span class="math">\(f(x)\)</span>, how can we determine its best approximation
<span class="math">\(u(x)\in V\)</span>? A natural starting point is to apply the same reasoning
as we did for vectors in the section <a class="reference internal" href="._main_approx002.html#fem-approx-vec-np1dim"><span class="std std-ref">Approximation of general vectors</span></a>. That is,
we minimize the distance between <span class="math">\(u\)</span> and <span class="math">\(f\)</span>. However, this requires
a norm for measuring distances, and a norm is most conveniently
defined through an
inner product. Viewing a function as a vector of infinitely
many point values, one for each value of <span class="math">\(x\)</span>, the inner product of
two arbitrary functions <span class="math">\(f(x)\)</span> and <span class="math">\(g(x)\)</span> could
intuitively be defined as the usual summation of
pairwise &#8220;components&#8221; (values), with summation replaced by integration:</p>
<div class="math">
\[(f,g) = \int f(x)g(x)\, {\, \mathrm{d}x}
{\thinspace .}\]</div>
<p>To fix the integration domain, we let <span class="math">\(f(x)\)</span> and <span class="math">\({\psi}_i(x)\)</span>
be defined for a domain <span class="math">\(\Omega\subset\mathbb{R}\)</span>.
The inner product of two functions <span class="math">\(f(x)\)</span> and <span class="math">\(g(x)\)</span> is then</p>
<div class="math" id="equation-fem:approx:LS:innerprod">
<span id="eq-fem-approx-ls-innerprod"></span><span class="eqno">(2)</span>\[     (f,g) = \int_\Omega f(x)g(x)\, {\, \mathrm{d}x}\]\[     {\thinspace .}\]</div>
<p>The distance between <span class="math">\(f\)</span> and any function <span class="math">\(u\in V\)</span> is simply
<span class="math">\(f-u\)</span>, and the squared norm of this distance is</p>
<div class="math" id="equation-fem:approx:LS:E">
<span id="eq-fem-approx-ls-e"></span><span class="eqno">(3)</span>\[     E = (f(x)-\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x), f(x)-\sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x)){\thinspace .}\]</div>
<p>Note the analogy with <a class="reference internal" href="._main_approx002.html#eq-fem-vec-gene"><span class="std std-ref">(3.14)</span></a>: the given function
<span class="math">\(f\)</span> plays the role of the given vector <span class="math">\(\boldsymbol{f}\)</span>, and the basis function
<span class="math">\({\psi}_i\)</span> plays the role of the basis vector <span class="math">\(\boldsymbol{\psi}_i\)</span>.
We can rewrite <a href="#equation-fem:approx:LS:E">(3)</a>,
through similar steps as used for the result
<a class="reference internal" href="._main_approx002.html#eq-fem-vec-gene"><span class="std std-ref">(3.14)</span></a>, leading to</p>
<div class="math" id="equation-_auto11">
<span id="eq-auto11"></span><span class="eqno">(4)</span>\[     E(c_i, \ldots, c_N) = (f,f) -2\sum_{j\in{\mathcal{I}_s}} c_j(f,{\psi}_i)
     + \sum_{p\in{\mathcal{I}_s}}\sum_{q\in{\mathcal{I}_s}} c_pc_q({\psi}_p,{\psi}_q){\thinspace .}\]</div>
<p>Minimizing this function of <span class="math">\(N+1\)</span> scalar variables
<span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>, requires differentiation
with respect to <span class="math">\(c_i\)</span>, for all <span class="math">\(i\in{\mathcal{I}_s}\)</span>. The resulting
equations are very similar to those we had in the vector case,
and we hence end up with a
linear system of the form <a class="reference internal" href="._main_approx002.html#eq-fem-approx-vec-np1dim-eqsys"><span class="std std-ref">(3.18)</span></a>, with
basically the same expressions:</p>
<div class="math" id="equation-fem:approx:Aij">
<span id="eq-fem-approx-aij"></span><span class="eqno">(5)</span>\[     A_{i,j} = ({\psi}_i,{\psi}_j),\]</div>
<div class="math" id="equation-fem:approx:bi">
<span id="eq-fem-approx-bi"></span><span class="eqno">(6)</span>\[     b_i = (f,{\psi}_i){\thinspace .}\]</div>
</div>
<div class="section" id="the-projection-or-galerkin-method">
<h2>The projection (or Galerkin) method<a class="headerlink" href="#the-projection-or-galerkin-method" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">As in the section <a class="reference internal" href="._main_approx002.html#fem-approx-vec-np1dim"><span class="std std-ref">Approximation of general vectors</span></a>, the minimization of <span class="math">\((e,e)\)</span>
is equivalent to</p>
<div class="math" id="equation-fem:approx:Galerkin">
<span id="eq-fem-approx-galerkin"></span><span class="eqno">(7)</span>\[     (e,v)=0,\quad\forall v\in V{\thinspace .}\]</div>
<p>This is known as a projection of a function <span class="math">\(f\)</span> onto the subspace <span class="math">\(V\)</span>.
We may also call it a Galerkin method for approximating functions.
Using the same reasoning as
in
<a class="reference internal" href="._main_approx002.html#eq-fem-approx-vec-np1dim-galerkin"><span class="std std-ref">(3.21)</span></a>-<a class="reference internal" href="._main_approx002.html#eq-fem-approx-vec-np1dim-galerkin0"><span class="std std-ref">(3.22)</span></a>,
it follows that <a href="#equation-fem:approx:Galerkin">(7)</a> is equivalent to</p>
<div class="math" id="equation-fem:approx:Galerkin0">
<span id="eq-fem-approx-galerkin0"></span><span class="eqno">(8)</span>\[     (e,{\psi}_i)=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>Inserting <span class="math">\(e=f-u\)</span> in this equation and ordering terms, as in the
multi-dimensional vector case, we end up with a linear
system with a coefficient matrix <a href="#equation-fem:approx:Aij">(5)</a> and
right-hand side vector <a href="#equation-fem:approx:bi">(6)</a>.</p>
<p>Whether we work with vectors in the plane, general vectors, or
functions in function spaces, the least squares principle and
the projection or Galerkin method are equivalent.</p>
</div>
<div class="section" id="example-linear-approximation">
<span id="fem-approx-global-linear"></span><h2>Example: linear approximation<a class="headerlink" href="#example-linear-approximation" title="Permalink to this headline">¶</a></h2>
<p>Let us apply the theory in the previous section to a simple problem:
given a parabola <span class="math">\(f(x)=10(x-1)^2-1\)</span> for <span class="math">\(x\in\Omega=[1,2]\)</span>, find
the best approximation <span class="math">\(u(x)\)</span> in the space of all linear functions:</p>
<div class="math">
\[V = \hbox{span}\,\{1, x\}{\thinspace .}\]</div>
<p>With our notation, <span class="math">\({\psi}_0(x)=1\)</span>, <span class="math">\({\psi}_1(x)=x\)</span>, and <span class="math">\(N=1\)</span>.
We seek</p>
<div class="math">
\[u=c_0{\psi}_0(x) + c_1{\psi}_1(x) = c_0 + c_1x,\]</div>
<p>where
<span class="math">\(c_0\)</span> and <span class="math">\(c_1\)</span> are found by solving a <span class="math">\(2\times 2\)</span> the linear system.
The coefficient matrix has elements</p>
<div class="math" id="equation-_auto12">
<span id="eq-auto12"></span><span class="eqno">(9)</span>\[     A_{0,0} = ({\psi}_0,{\psi}_0) = \int_1^21\cdot 1\, {\, \mathrm{d}x} = 1,\]</div>
<div class="math" id="equation-_auto13">
<span id="eq-auto13"></span><span class="eqno">(10)</span>\[     A_{0,1} = ({\psi}_0,{\psi}_1) = \int_1^2 1\cdot x\, {\, \mathrm{d}x} = 3/2,\]</div>
<div class="math" id="equation-_auto14">
<span id="eq-auto14"></span><span class="eqno">(11)</span>\[     A_{1,0} = A_{0,1} = 3/2,\]</div>
<div class="math" id="equation-_auto15">
<span id="eq-auto15"></span><span class="eqno">(12)</span>\[     A_{1,1} = ({\psi}_1,{\psi}_1) = \int_1^2 x\cdot x\,{\, \mathrm{d}x} = 7/3{\thinspace .}\]</div>
<p>The corresponding right-hand side is</p>
<div class="math" id="equation-_auto16">
<span id="eq-auto16"></span><span class="eqno">(13)</span>\[     b_1 = (f,{\psi}_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, {\, \mathrm{d}x} = 7/3,\]</div>
<div class="math" id="equation-_auto17">
<span id="eq-auto17"></span><span class="eqno">(14)</span>\[     b_2 = (f,{\psi}_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, {\, \mathrm{d}x} = 13/3{\thinspace .}\]</div>
<p>Solving the linear system results in</p>
<div class="math" id="equation-_auto18">
<span id="eq-auto18"></span><span class="eqno">(15)</span>\[     c_0 = -38/3,\quad c_1 = 10,\]</div>
<p>and consequently</p>
<div class="math" id="equation-_auto19">
<span id="eq-auto19"></span><span class="eqno">(16)</span>\[     u(x) = 10x - \frac{38}{3}{\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-linear"><span class="std std-ref">Best approximation of a parabola by a straight line</span></a> displays the
parabola and its best approximation in the space of all linear functions.</p>
<div class="figure" id="id1">
<span id="fem-approx-global-fig-parabola-linear"></span><a class="reference internal image-reference" href="_images/parabola_ls_linear.png"><img alt="_images/parabola_ls_linear.png" src="_images/parabola_ls_linear.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Best approximation of a parabola by a straight line</em></span></p>
</div>
</div>
<div class="section" id="implementation-of-the-least-squares-method">
<span id="fem-approx-global-ls-code"></span><h2>Implementation of the least squares method<a class="headerlink" href="#implementation-of-the-least-squares-method" title="Permalink to this headline">¶</a></h2>
<div class="section" id="symbolic-integration">
<h3>Symbolic integration<a class="headerlink" href="#symbolic-integration" title="Permalink to this headline">¶</a></h3>
<p>The linear system can be computed either symbolically or
numerically (a numerical integration rule is needed in the latter case).
Let us first compute the system and its solution symbolically, i.e.,
using classical &#8220;pen and paper&#8221; mathematics with symbols.
The Python package <code class="docutils literal"><span class="pre">sympy</span></code> can greatly help with this type of
mathematics, and will therefore be frequently used in this text.
Some basic familiarity with <code class="docutils literal"><span class="pre">sympy</span></code> is assumed, typically
<code class="docutils literal"><span class="pre">symbols</span></code>, <code class="docutils literal"><span class="pre">integrate</span></code>, <code class="docutils literal"><span class="pre">diff</span></code>, <code class="docutils literal"><span class="pre">expand</span></code>, and <code class="docutils literal"><span class="pre">simplify</span></code>. Much can be learned
by studying the many applications of <code class="docutils literal"><span class="pre">sympy</span></code> that will be presented.</p>
<p>Below is a function for symbolic computation of the linear system,
where <span class="math">\(f(x)\)</span> is given as a <code class="docutils literal"><span class="pre">sympy</span></code> expression <code class="docutils literal"><span class="pre">f</span></code> involving
the symbol <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">psi</span></code> is a list of expressions for <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>,
and <code class="docutils literal"><span class="pre">Omega</span></code> is a 2-tuple/list holding the limits of the domain <span class="math">\(\Omega\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>

<span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c"># Note: c is a sympy Matrix object, solution is in c[:,0]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>Observe that we exploit the symmetry of the coefficient matrix:
only the upper triangular part is computed. Symbolic integration, also in
<code class="docutils literal"><span class="pre">sympy</span></code>, is often time consuming, and (roughly) halving the
work has noticeable effect on the waiting time for the computations to
finish.</p>
</div>
<div class="section" id="fall-back-on-numerical-integration">
<h3>Fall back on numerical integration<a class="headerlink" href="#fall-back-on-numerical-integration" title="Permalink to this headline">¶</a></h3>
<p>Obviously, <code class="docutils literal"><span class="pre">sympy</span></code> may fail to successfully integrate
<span class="math">\(\int_\Omega{\psi}_i{\psi}_j{\, \mathrm{d}x}\)</span>, and
especially <span class="math">\(\int_\Omega f{\psi}_i{\, \mathrm{d}x}\)</span>, symbolically.
Therefore, we should extend
the <code class="docutils literal"><span class="pre">least_squares</span></code> function such that it falls back on
numerical integration if the symbolic integration is unsuccessful.
In the latter case, the returned value from <code class="docutils literal"><span class="pre">sympy</span></code>&#8216;s
<code class="docutils literal"><span class="pre">integrate</span></code> function is an object of type <code class="docutils literal"><span class="pre">Integral</span></code>.
We can test on this type and utilize the <code class="docutils literal"><span class="pre">mpmath</span></code> module in
<code class="docutils literal"><span class="pre">sympy</span></code> to perform numerical integration of high precision.
Even when <code class="docutils literal"><span class="pre">sympy</span></code> manages to integrate symbolically, it can
take an undesirable long time. We therefore include an
argument <code class="docutils literal"><span class="pre">symbolic</span></code> that governs whether or not to try
symbolic integration. Here is a complete and
improved version of the previous function <code class="docutils literal"><span class="pre">least_squares</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="c"># Could not integrate symbolically,</span>
                <span class="c"># fall back on numerical integration</span>
                <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>

        <span class="n">integrand</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c"># symbolic solve</span>
    <span class="c"># c is a sympy Matrix object, numbers are in c[i,0]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>The function is found in the file <code class="docutils literal"><span class="pre">approx1D.py</span></code>.</p>
</div>
<div class="section" id="plotting-the-approximation">
<h3>Plotting the approximation<a class="headerlink" href="#plotting-the-approximation" title="Permalink to this headline">¶</a></h3>
<p>Comparing the given <span class="math">\(f(x)\)</span> and the approximate <span class="math">\(u(x)\)</span> visually is done
by the following function, which utilizes <code class="docutils literal"><span class="pre">sympy</span></code>&#8216;s <code class="docutils literal"><span class="pre">lambdify</span></code> tool to
convert a <code class="docutils literal"><span class="pre">sympy</span></code> expression to a Python function for numerical
computations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="mi">401</span>  <span class="c"># no of points in plot</span>
    <span class="n">xcoor</span>  <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">exact</span>  <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xcoor</span><span class="p">)</span>
    <span class="n">approx</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">xcoor</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">xcoor</span><span class="p">,</span> <span class="n">approx</span><span class="p">)</span>
    <span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">xcoor</span><span class="p">,</span> <span class="n">exact</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">([</span><span class="s">&#39;approximation&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
    <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">modules='numpy'</span></code> argument to <code class="docutils literal"><span class="pre">lambdify</span></code> is important
if there are mathematical functions, such as <code class="docutils literal"><span class="pre">sin</span></code> or <code class="docutils literal"><span class="pre">exp</span></code>
in the symbolic expressions in <code class="docutils literal"><span class="pre">f</span></code> or <code class="docutils literal"><span class="pre">u</span></code>, and these
mathematical functions are to be used with vector arguments, like
<code class="docutils literal"><span class="pre">xcoor</span></code> above.</p>
<p>Both the <code class="docutils literal"><span class="pre">least_squares</span></code> and <code class="docutils literal"><span class="pre">comparison_plot</span></code> functions are found in
the file <a class="reference external" href="http://tinyurl.com/nm5587k/approx/approx1D.py">approx1D.py</a>.  The
<code class="docutils literal"><span class="pre">comparison_plot</span></code> function in this file is more advanced and flexible
than the simplistic version shown above.  The file <code class="docutils literal"><span class="pre">ex_approx1D.py</span></code>
applies the <code class="docutils literal"><span class="pre">approx1D</span></code> module to accomplish the forthcoming examples.</p>
</div>
</div>
<div class="section" id="perfect-approximation">
<span id="fem-approx-global-exact"></span><h2>Perfect approximation<a class="headerlink" href="#perfect-approximation" title="Permalink to this headline">¶</a></h2>
<p>Let us use the code above to recompute the problem from
the section <a class="reference internal" href="#fem-approx-global-linear"><span class="std std-ref">Example: linear approximation</span></a> where we want to approximate
a parabola. What happens if we add an element <span class="math">\(x^2\)</span> to the basis and test what
the best approximation is if <span class="math">\(V\)</span> is the space of all parabolic functions?
The answer is quickly found by running</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">approx1D</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">10*x**2 - 20*x + 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sym</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">10*x**2 - 20*x + 9</span>
</pre></div>
</div>
<p>Now, what if we use <span class="math">\({\psi}_i(x)=x^i\)</span> for <span class="math">\(i=0,1,\ldots,N=40\)</span>?
The output from <code class="docutils literal"><span class="pre">least_squares</span></code> gives <span class="math">\(c_i=0\)</span> for <span class="math">\(i&gt;2\)</span>, which
means that the method finds the perfect approximation.</p>
<p>In fact, we have a general result that
if <span class="math">\(f\in V\)</span>, the least squares and projection/Galerkin methods compute
the exact solution <span class="math">\(u=f\)</span>.
The proof is straightforward: if <span class="math">\(f\in V\)</span>, <span class="math">\(f\)</span> can be expanded in
terms of the basis functions, <span class="math">\(f=\sum_{j\in{\mathcal{I}_s}} d_j{\psi}_j\)</span>, for
some coefficients <span class="math">\(\left\{ {d}_j \right\}_{j\in{\mathcal{I}_s}}\)</span>,
and the right-hand side then has entries</p>
<div class="math">
\[b_i = (f,{\psi}_i) = \sum_{j\in{\mathcal{I}_s}} d_j({\psi}_j, {\psi}_i) = \sum_{j\in{\mathcal{I}_s}} d_jA_{i,j}
{\thinspace .}\]</div>
<p>The linear system <span class="math">\(\sum_jA_{i,j}c_j = b_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>, is then</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}} c_jA_{i,j} = \sum_{j\in{\mathcal{I}_s}}d_jA_{i,j},
\quad i\in{\mathcal{I}_s},\]</div>
<p>which implies that <span class="math">\(c_i=d_i\)</span> for <span class="math">\(i\in{\mathcal{I}_s}\)</span>.</p>
</div>
<div class="section" id="ill-conditioning">
<span id="fem-approx-global-illconditioning"></span><h2>Ill-conditioning<a class="headerlink" href="#ill-conditioning" title="Permalink to this headline">¶</a></h2>
<p>The computational example in the section <a class="reference internal" href="#fem-approx-global-exact"><span class="std std-ref">Perfect approximation</span></a>
applies the <code class="docutils literal"><span class="pre">least_squares</span></code> function which invokes symbolic
methods to calculate and solve the linear system. The correct
solution <span class="math">\(c_0=9, c_1=-20, c_2=10, c_i=0\)</span> for <span class="math">\(i\geq 3\)</span> is perfectly
recovered.</p>
<p>Suppose we
convert the matrix and right-hand side to floating-point arrays
and then solve the system using finite-precision arithmetics, which
is what one will (almost) always do in real life. This time we
get astonishing results! Up to about <span class="math">\(N=7\)</span> we get a solution that
is reasonably close to the exact one. Increasing <span class="math">\(N\)</span> shows that
seriously wrong coefficients are computed.
Below is a table showing the solution of the linear system arising from
approximating a parabola
by functions on the form <span class="math">\(u(x)=c_0 + c_1x + c_2x^2 + \cdots + c_{10}x^{10}\)</span>.
Analytically, we know that <span class="math">\(c_j=0\)</span> for <span class="math">\(j&gt;2\)</span>, but numerically we may get
<span class="math">\(c_j\neq 0\)</span> for <span class="math">\(j&gt;2\)</span>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="25%" />
<col width="31%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">exact</th>
<th class="head"><code class="docutils literal"><span class="pre">sympy</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">numpy32</span></code></th>
<th class="head"><code class="docutils literal"><span class="pre">numpy64</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>9</td>
<td>9.62</td>
<td>5.57</td>
<td>8.98</td>
</tr>
<tr class="row-odd"><td>-20</td>
<td>-23.39</td>
<td>-7.65</td>
<td>-19.93</td>
</tr>
<tr class="row-even"><td>10</td>
<td>17.74</td>
<td>-4.50</td>
<td>9.96</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>-9.19</td>
<td>4.13</td>
<td>-0.26</td>
</tr>
<tr class="row-even"><td>0</td>
<td>5.25</td>
<td>2.99</td>
<td>0.72</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>0.18</td>
<td>-1.21</td>
<td>-0.93</td>
</tr>
<tr class="row-even"><td>0</td>
<td>-2.48</td>
<td>-0.41</td>
<td>0.73</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1.81</td>
<td>-0.013</td>
<td>-0.36</td>
</tr>
<tr class="row-even"><td>0</td>
<td>-0.66</td>
<td>0.08</td>
<td>0.11</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>0.12</td>
<td>0.04</td>
<td>-0.02</td>
</tr>
<tr class="row-even"><td>0</td>
<td>-0.001</td>
<td>-0.02</td>
<td>0.002</td>
</tr>
</tbody>
</table>
<p>The exact value of <span class="math">\(c_j\)</span>, <span class="math">\(j=0,1,\ldots,10\)</span>, appears in the first
column while the other columns correspond to results obtained
by three different methods:</p>
<blockquote>
<div><ul class="simple">
<li>Column 2: The matrix and vector are converted to
the data structure  <code class="docutils literal"><span class="pre">sympy.mpmath.fp.matrix</span></code> and the
<code class="docutils literal"><span class="pre">sympy.mpmath.fp.lu_solve</span></code> function is used to solve the system.</li>
<li>Column 3: The matrix and vector are converted to
<code class="docutils literal"><span class="pre">numpy</span></code> arrays with data type <code class="docutils literal"><span class="pre">numpy.float32</span></code>
(single precision floating-point number) and solved by
the <code class="docutils literal"><span class="pre">numpy.linalg.solve</span></code> function.</li>
<li>Column 4: As column 3, but the data type is
<code class="docutils literal"><span class="pre">numpy.float64</span></code> (double
precision floating-point number).</li>
</ul>
</div></blockquote>
<p>We see from the numbers in the table that
double precision performs much better than single precision.
Nevertheless, when plotting all these solutions the curves cannot be
visually distinguished (!). This means that the approximations look
perfect, despite the partially very wrong values of the coefficients.</p>
<p>Increasing <span class="math">\(N\)</span> to 12 makes the numerical solver in <code class="docutils literal"><span class="pre">numpy</span></code>
abort with the message: &#8220;matrix is numerically singular&#8221;.
A matrix has to be non-singular to be invertible, which is a requirement
when solving a linear system. Already when the matrix is close to
singular, it is <em>ill-conditioned</em>, which here implies that
the numerical solution algorithms are sensitive to round-off
errors and may produce (very) inaccurate results.</p>
<p>The reason why the coefficient matrix is nearly singular and
ill-conditioned is that our basis functions <span class="math">\({\psi}_i(x)=x^i\)</span> are
nearly linearly dependent for large <span class="math">\(i\)</span>.  That is, <span class="math">\(x^i\)</span> and <span class="math">\(x^{i+1}\)</span>
are very close for <span class="math">\(i\)</span> not very small. This phenomenon is
illustrated in Figure <a class="reference internal" href="#fem-approx-global-fig-illconditioning"><span class="std std-ref">The 15 first basis functions , </span></a>.
There are 15 lines in this figure, but only half of them are
visually distinguishable.
Almost linearly dependent basis functions give rise to an
ill-conditioned and almost singular matrix.  This fact can be
illustrated by computing the determinant, which is indeed very close
to zero (recall that a zero determinant implies a singular and
non-invertible matrix): <span class="math">\(10^{-65}\)</span> for <span class="math">\(N=10\)</span> and <span class="math">\(10^{-92}\)</span> for
<span class="math">\(N=12\)</span>. Already for <span class="math">\(N=28\)</span> the numerical determinant computation
returns a plain zero.</p>
<div class="figure" id="id2">
<span id="fem-approx-global-fig-illconditioning"></span><a class="reference internal image-reference" href="_images/ill_conditioning.png"><img alt="_images/ill_conditioning.png" src="_images/ill_conditioning.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">The 15 first basis functions <span class="math">\(x^i\)</span>, <span class="math">\(i=0,\ldots,14\)</span></span></p>
</div>
<p>On the other hand, the double precision <code class="docutils literal"><span class="pre">numpy</span></code> solver does run for
<span class="math">\(N=100\)</span>, resulting in answers that are not significantly worse than
those in the table above, and large powers are
associated with small coefficients (e.g., <span class="math">\(c_j&lt;10^{-2}\)</span> for <span class="math">\(10\leq
j\leq 20\)</span> and <span class="math">\(c&lt;10^{-5}\)</span> for <span class="math">\(j&gt;20\)</span>). Even for <span class="math">\(N=100\)</span> the
approximation still lies on top of the exact curve in a plot (!).</p>
<p>The conclusion is that visual inspection of the quality of the approximation
may not uncover fundamental numerical problems with the computations.
However, numerical analysts have studied approximations and ill-conditioning
for decades, and it is well known that the basis <span class="math">\(\{1,x,x^2,x^3,\ldots,\}\)</span>
is a bad basis. The best basis from a matrix conditioning point of view
is to have orthogonal functions such that <span class="math">\((\psi_i,\psi_j)=0\)</span> for
<span class="math">\(i\neq j\)</span>. There are many known sets of orthogonal polynomials and
other functions.
The functions used in the finite element methods are almost orthogonal,
and this property helps to avoid problems with solving matrix systems.
Almost orthogonal is helpful, but not enough when it comes to
partial differential equations, and ill-conditioning
of the coefficient matrix is a theme when solving large-scale matrix
systems arising from finite element discretizations.</p>
</div>
<div class="section" id="fourier-series">
<span id="fem-approx-global-fourier"></span><h2>Fourier series<a class="headerlink" href="#fourier-series" title="Permalink to this headline">¶</a></h2>
<p id="index-3">A set of sine functions is widely used for approximating functions
(the sines are also orthogonal as explained more in the section <a class="reference internal" href="#fem-approx-global-illconditioning"><span class="std std-ref">Ill-conditioning</span></a>).  Let us take</p>
<div class="math">
\[V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
{\thinspace .}\]</div>
<p>That is,</p>
<div class="math">
\[{\psi}_i(x) = \sin ((i+1)\pi x),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>An approximation to the parabola <span class="math">\(f(x)=10(x-1)^2-1\)</span> for <span class="math">\(x\in\Omega=[1,2]\)</span> from
the section <a class="reference internal" href="#fem-approx-global-linear"><span class="std std-ref">Example: linear approximation</span></a> can then be computed by the
<code class="docutils literal"><span class="pre">least_squares</span></code> function from the section <a class="reference internal" href="#fem-approx-global-ls-code"><span class="std std-ref">Implementation of the least squares method</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><span class="std std-ref">Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</span></a> (left) shows the oscillatory approximation
of <span class="math">\(\sum_{j=0}^Nc_j\sin ((j+1)\pi x)\)</span> when <span class="math">\(N=3\)</span>.
Changing <span class="math">\(N\)</span> to 11 improves the approximation considerably, see
Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><span class="std std-ref">Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</span></a> (right).</p>
<div class="figure" id="id3">
<span id="fem-approx-global-fig-parabola-sine1"></span><a class="reference internal image-reference" href="_images/parabola_ls_sines4_12.png"><img alt="_images/parabola_ls_sines4_12.png" src="_images/parabola_ls_sines4_12.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></span></p>
</div>
<p>There is an error <span class="math">\(f(0)-u(0)=9\)</span> at <span class="math">\(x=0\)</span> in Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><span class="std std-ref">Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</span></a> regardless of how large <span class="math">\(N\)</span> is, because all <span class="math">\({\psi}_i(0)=0\)</span> and hence
<span class="math">\(u(0)=0\)</span>. We may help the approximation to be correct at <span class="math">\(x=0\)</span> by
seeking</p>
<div class="math" id="equation-_auto20">
<span id="eq-auto20"></span><span class="eqno">(17)</span>\[     u(x) = f(0) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x)
     {\thinspace .}\]</div>
<p>However, this adjustment introduces a new problem at <span class="math">\(x=1\)</span> since
we now get an error <span class="math">\(f(1)-u(1)=f(1)-0=-1\)</span> at this point. A more
clever adjustment is to replace the <span class="math">\(f(0)\)</span> term by a term that
is <span class="math">\(f(0)\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(f(1)\)</span> at <span class="math">\(x=1\)</span>. A simple linear combination
<span class="math">\(f(0)(1-x) + xf(1)\)</span> does the job:</p>
<div class="math" id="equation-_auto21">
<span id="eq-auto21"></span><span class="eqno">(18)</span>\[     u(x) = f(0)(1-x) + xf(1) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x)
     {\thinspace .}\]</div>
<p>This adjustment of <span class="math">\(u\)</span> alters the linear system slightly. In the general
case, we set</p>
<div class="math">
\[u(x) = B(x) +  \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x),\]</div>
<p>and the linear system becomes</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}}({\psi}_i,{\psi}_j)c_j = (f-B,{\psi}_i),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>The calculations can still utilize the <code class="docutils literal"><span class="pre">least_squares</span></code> or
<code class="docutils literal"><span class="pre">least_squares_orth</span></code> functions, but solve for <span class="math">\(u-b\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">f1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">f0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f1</span>
<span class="n">u_sum</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">least_squares_orth</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">u_sum</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine2"><span class="std std-ref">Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term</span></a> shows the result
of the technique for
ensuring right boundary values. Even 3 sines can now adjust the
<span class="math">\(f(0)(1-x) + xf(1)\)</span> term such that <span class="math">\(u\)</span> approximates the parabola really
well, at least visually.</p>
<div class="figure" id="id4">
<span id="fem-approx-global-fig-parabola-sine2"></span><a class="reference internal image-reference" href="_images/parabola_ls_sines4_12_wfterm.png"><img alt="_images/parabola_ls_sines4_12_wfterm.png" src="_images/parabola_ls_sines4_12_wfterm.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term</em></span></p>
</div>
</div>
<div class="section" id="orthogonal-basis-functions">
<span id="fem-approx-global-orth"></span><h2>Orthogonal basis functions<a class="headerlink" href="#orthogonal-basis-functions" title="Permalink to this headline">¶</a></h2>
<p>The choice of sine functions <span class="math">\({\psi}_i(x)=\sin ((i+1)\pi x)\)</span> has a great
computational advantage: on <span class="math">\(\Omega=[0,1]\)</span> these basis functions are
<em>orthogonal</em>, implying that <span class="math">\(A_{i,j}=0\)</span> if <span class="math">\(i\neq j\)</span>. This
result is realized by trying</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integrate</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>in <a class="reference external" href="http://wolframalpha.com">WolframAlpha</a>
(avoid <code class="docutils literal"><span class="pre">i</span></code> in the integrand as this symbol means
the imaginary unit <span class="math">\(\sqrt{-1}\)</span>).
Asking WolframAlpha also
about <span class="math">\(\int_0^1\sin^2 (j\pi x) {\, \mathrm{d}x}\)</span>, we find that it equals
1/2.
With a diagonal matrix we can easily solve for the coefficients
by hand:</p>
<div class="math" id="equation-_auto22">
<span id="eq-auto22"></span><span class="eqno">(19)</span>\[     c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) {\, \mathrm{d}x},\quad i\in{\mathcal{I}_s},\]</div>
<p>which is nothing but the classical formula for the coefficients of
the Fourier sine series of <span class="math">\(f(x)\)</span> on <span class="math">\([0,1]\)</span>. In fact, when
<span class="math">\(V\)</span> contains the basic functions used in a Fourier series expansion,
the approximation method derived in the section <a class="reference internal" href="#fem-approx-global"><span class="std std-ref">Approximation of functions</span></a>
results in the classical Fourier series for <span class="math">\(f(x)\)</span> (see <a class="reference internal" href="._main_approx011.html#fem-approx-exer-fourier"><span class="std std-ref">Exercise 8: Fourier series as a least squares approximation</span></a>
for details).</p>
<p>With orthogonal basis functions we can make the
<code class="docutils literal"><span class="pre">least_squares</span></code> function (much) more efficient since we know that
the matrix is diagonal and only the diagonal elements need to be computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares_orth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">,</span>  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>As mentioned in the section <a class="reference internal" href="#fem-approx-global-ls-code"><span class="std std-ref">Implementation of the least squares method</span></a>, symbolic integration
may fail or take very long time. It is therefore natural to extend the
implementation above with a version where we can choose between symbolic
and numerical integration and fall back on the latter if the former
fails:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares_orth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># plain list to hold symbolic expressions</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c"># Diagonal matrix term</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c"># Right-hand side term</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span>
        <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span>  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;numerical integration of&#39;</span><span class="p">,</span> <span class="n">integrand</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>This function is found in the file <code class="docutils literal"><span class="pre">approx1D.py</span></code>. Observe that
we here assume that
<span class="math">\(\int_\Omega{\varphi}_i^2{\, \mathrm{d}x}\)</span> can always be symbolically computed,
which is not an unreasonable assumption
when the basis functions are orthogonal, but there is no guarantee,
so an improved version of the function above would implement
numerical integration also for the <code class="docutils literal"><span class="pre">A[i,i]</span></code> term.</p>
</div>
<div class="section" id="numerical-computations">
<h2>Numerical computations<a class="headerlink" href="#numerical-computations" title="Permalink to this headline">¶</a></h2>
<p>Sometimes the basis functions <span class="math">\({\psi}_i\)</span> and/or the function <span class="math">\(f\)</span>
have a nature that makes symbolic integration CPU-time
consuming or impossible.
Even though we implemented a fall back on numerical integration
of <span class="math">\(\int f{\varphi}_i {\, \mathrm{d}x}\)</span>, considerable time might still be required
by <code class="docutils literal"><span class="pre">sympy</span></code> just by <em>attempting</em> to integrate symbolically.
Therefore, it will be handy to have function for fast
<em>numerical integration and numerical solution
of the linear system</em>. Below is such a method. It requires
Python functions <code class="docutils literal"><span class="pre">f(x)</span></code> and <code class="docutils literal"><span class="pre">psi(x,i)</span></code> for <span class="math">\(f(x)\)</span> and <span class="math">\({\psi}_i(x)\)</span>
as input. The output is a mesh function
with values <code class="docutils literal"><span class="pre">u</span></code> on the mesh with points in the array <code class="docutils literal"><span class="pre">x</span></code>.
Three numerical integration methods are offered:
<code class="docutils literal"><span class="pre">scipy.integrate.quad</span></code> (precision set to <span class="math">\(10^{-8}\)</span>),
<code class="docutils literal"><span class="pre">sympy.mpmath.quad</span></code> (about machine precision), and a Trapezoidal
rule based on the points in <code class="docutils literal"><span class="pre">x</span></code> (unknown accuracy, but
increasing with the number of mesh points in <code class="docutils literal"><span class="pre">x</span></code>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares_numerical</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                            <span class="n">integration_method</span><span class="o">=</span><span class="s">&#39;scipy&#39;</span><span class="p">,</span>
                            <span class="n">orthogonal_basis</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">scipy.integrate</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">j_limit</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">orthogonal_basis</span> <span class="k">else</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j_limit</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">integration_method</span> <span class="o">==</span> <span class="s">&#39;scipy&#39;</span><span class="p">:</span>
                <span class="n">A_ij</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j</span><span class="p">),</span>
                    <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1E-9</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1E-9</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">integration_method</span> <span class="o">==</span> <span class="s">&#39;sympy&#39;</span><span class="p">:</span>
                <span class="n">A_ij</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j</span><span class="p">),</span>
                    <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">A_ij</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_ij</span>

        <span class="k">if</span> <span class="n">integration_method</span> <span class="o">==</span> <span class="s">&#39;scipy&#39;</span><span class="p">:</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">epsabs</span><span class="o">=</span><span class="mf">1E-9</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1E-9</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">integration_method</span> <span class="o">==</span> <span class="s">&#39;sympy&#39;</span><span class="p">:</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="n">trapezoidal</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_i</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">if</span> <span class="n">orthogonal_basis</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">trapezoidal</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate values by the Trapezoidal rule (mesh size dx).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Here is an example on calling the function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">pi</span>

<span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mi">501</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">least_squares_numerical</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tanh</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">pi</span><span class="p">),</span> <span class="n">psi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                               <span class="n">orthogonal_basis</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-interpolation-or-collocation-method">
<span id="fem-approx-global-interp"></span><h2>The interpolation (or collocation) method<a class="headerlink" href="#the-interpolation-or-collocation-method" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><span class="target" id="index-5"></span><span class="target" id="index-6"></span><p id="index-7">The principle of minimizing the distance between <span class="math">\(u\)</span> and <span class="math">\(f\)</span> is
an intuitive way of computing a best approximation <span class="math">\(u\in V\)</span> to <span class="math">\(f\)</span>.
However, there are other approaches as well.
One is to demand that <span class="math">\(u(x_{i}) = f(x_{i})\)</span> at some selected points
<span class="math">\(x_{i}\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>:</p>
<div class="math" id="equation-_auto23">
<span id="eq-auto23"></span><span class="eqno">(20)</span>\[     u(x_{i}) = \sum_{j\in{\mathcal{I}_s}} c_j {\psi}_j(x_{i}) = f(x_{i}),
     \quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>We recognize that the equation <span class="math">\(\sum_j c_j {\psi}_j(x_{i}) = f(x_{i})\)</span>
is actually a linear system with <span class="math">\(N+1\)</span> unknown coefficients <span class="math">\(\left\{ {c}_j \right\}_{j\in{\mathcal{I}_s}}\)</span>:</p>
<div class="math" id="equation-_auto24">
<span id="eq-auto24"></span><span class="eqno">(21)</span>\[     \sum_{j\in{\mathcal{I}_s}} A_{i,j}c_j = b_i,\quad i\in{\mathcal{I}_s},\]</div>
<p>with coefficient matrix and right-hand side vector given by</p>
<div class="math" id="equation-_auto25">
<span id="eq-auto25"></span><span class="eqno">(22)</span>\[     A_{i,j} = {\psi}_j(x_{i}),\]</div>
<div class="math" id="equation-_auto26">
<span id="eq-auto26"></span><span class="eqno">(23)</span>\[     b_i = f(x_{i}){\thinspace .}\]</div>
<p>This time the coefficient matrix is not symmetric because
<span class="math">\({\psi}_j(x_{i})\neq {\psi}_i(x_{j})\)</span> in general.
The method is often referred to as an <em>interpolation method</em>
since some point values of <span class="math">\(f\)</span> are given (<span class="math">\(f(x_{i})\)</span>) and we
fit a continuous function <span class="math">\(u\)</span> that goes through the <span class="math">\(f(x_{i})\)</span> points.
In this case the <span class="math">\(x_{i}\)</span> points are called <em>interpolation points</em>.
When the same approach is used to approximate differential equations,
one usually applies the name <em>collocation method</em> and
<span class="math">\(x_{i}\)</span> are known as <em>collocation points</em>.</p>
<p>Given <span class="math">\(f\)</span>  as a <code class="docutils literal"><span class="pre">sympy</span></code> symbolic expression <code class="docutils literal"><span class="pre">f</span></code>, <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>
as a list <code class="docutils literal"><span class="pre">psi</span></code>, and a set of points <span class="math">\(\left\{ {x}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>  as a list or array
<code class="docutils literal"><span class="pre">points</span></code>, the following Python function sets up and solves the matrix system
for the coefficients <span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">psi_sym</span> <span class="o">=</span> <span class="n">psi</span>  <span class="c"># save symbolic expression</span>
    <span class="c"># Turn psi and f into Python functions</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c"># c is a sympy Matrix object, turn to list</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">psi_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">interpolation</span></code> function is a part of the <code class="docutils literal"><span class="pre">approx1D</span></code>
module.</p>
<p>We found it convenient in the above function to turn the expressions <code class="docutils literal"><span class="pre">f</span></code> and
<code class="docutils literal"><span class="pre">psi</span></code> into ordinary Python functions of <code class="docutils literal"><span class="pre">x</span></code>, which can be called with
<code class="docutils literal"><span class="pre">float</span></code> values in the list <code class="docutils literal"><span class="pre">points</span></code> when building the matrix and
the right-hand side. The alternative is to use the <code class="docutils literal"><span class="pre">subs</span></code> method
to substitute the <code class="docutils literal"><span class="pre">x</span></code> variable in an expression by an element from
the <code class="docutils literal"><span class="pre">points</span></code> list. The following session illustrates both approaches
in a simple setting:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>              <span class="c"># symbolic expression involving x</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>               <span class="c"># a value of x</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>      <span class="c"># evaluate e for x=p</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span>
<span class="mf">0.250000000000000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="n">sympy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">Float</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>  <span class="c"># make Python function of e</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>              <span class="c"># evaluate e(x) for x=p</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span>
<span class="mf">0.25</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="nb">float</span>
</pre></div>
</div>
<p>A nice feature of the interpolation or collocation method is that it
avoids computing integrals. However, one has to decide on the location
of the <span class="math">\(x_{i}\)</span> points.  A simple, yet common choice, is to
distribute them uniformly throughout <span class="math">\(\Omega\)</span>.</p>
<div class="section" id="example-1">
<h3>Example  (1)<a class="headerlink" href="#example-1" title="Permalink to this headline">¶</a></h3>
<p>Let us illustrate the interpolation method by approximating
our parabola <span class="math">\(f(x)=10(x-1)^2-1\)</span> by a linear function on <span class="math">\(\Omega=[1,2]\)</span>,
using two collocation points <span class="math">\(x_0=1+1/3\)</span> and <span class="math">\(x_1=1+2/3\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting linear system becomes</p>
<div class="math">
\[\begin{split}\left(\begin{array}{ll}
1 &amp; 4/3\\
1 &amp; 5/3\\
\end{array}\right)
\left(\begin{array}{l}
c_0\\
c_1\\
\end{array}\right)
=
\left(\begin{array}{l}
1/9\\
31/9\\
\end{array}\right)\end{split}\]</div>
<p>with solution <span class="math">\(c_0=-119/9\)</span> and <span class="math">\(c_1=10\)</span>.
Figure <a class="reference internal" href="#fem-approx-global-linear-interp-fig1"><span class="std std-ref">Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</span></a> (left) shows the resulting
approximation <span class="math">\(u=-119/9 + 10x\)</span>.
We can easily test other interpolation points, say <span class="math">\(x_0=1\)</span> and <span class="math">\(x_1=2\)</span>.
This changes the line quite significantly, see
Figure <a class="reference internal" href="#fem-approx-global-linear-interp-fig1"><span class="std std-ref">Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</span></a> (right).</p>
<div class="figure" id="id5">
<span id="fem-approx-global-linear-interp-fig1"></span><a class="reference internal image-reference" href="_images/parabola_inter.png"><img alt="_images/parabola_inter.png" src="_images/parabola_inter.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</em></span></p>
</div>
</div>
</div>
<div class="section" id="the-regression-method">
<span id="fem-approx-global-regression"></span><h2>The regression method<a class="headerlink" href="#the-regression-method" title="Permalink to this headline">¶</a></h2>
<p>The interpolation method in the previous section used exactly
<span class="math">\(N+1\)</span> interpolation points. An alternative is to use <span class="math">\(m+1&gt;N+1\)</span>
interpolation points <span class="math">\(x_{0},x_{1},\ldots,x_{m}\)</span>.
This is particularly relevant if <span class="math">\(f\)</span> is just known
through measured point values and we have many such values.
The resulting method is called <em>regression</em> and
is well known from statistics when fitting a simple (usually polynomial)
function to a set of data points.</p>
<div class="section" id="overdetermined-equation-system">
<h3>Overdetermined equation system<a class="headerlink" href="#overdetermined-equation-system" title="Permalink to this headline">¶</a></h3>
<p>Intuitively, we would demand <span class="math">\(u\)</span> to equal <span class="math">\(f\)</span> at all the
data points <span class="math">\(x_{i}\)</span>, <span class="math">\(i0,1,\ldots,m\)</span>,</p>
<div class="math" id="equation-_auto27">
<span id="eq-auto27"></span><span class="eqno">(24)</span>\[     u(x_{i}) = \sum_{j\in{\mathcal{I}_s}} c_j {\psi}_j(x_{i}) = f(x_{i}),
     \quad i=0,1,\ldots,m{\thinspace .}\]</div>
<p>The fundamental problem here is that we have more equations than
unknowns since there are <span class="math">\(N+1\)</span> unknowns and <span class="math">\(m+1&gt;N+1\)</span> equations.
Such a system of equations is called an <em>overdetermined system</em>.
We can write it matrix form as</p>
<div class="math" id="equation-_auto28">
<span id="eq-auto28"></span><span class="eqno">(25)</span>\[     \sum_{j\in{\mathcal{I}_s}} A_{i,j}c_j = b_i,\quad i=0,1,\ldots,m,\]</div>
<p>with coefficient matrix and right-hand side vector given by</p>
<div class="math" id="equation-fem:approx:global:regression:Aij">
<span id="eq-fem-approx-global-regression-aij"></span><span class="eqno">(26)</span>\[     A_{i,j} = {\psi}_j(x_{i}),\]</div>
<div class="math" id="equation-fem:approx:global:regression:bi">
<span id="eq-fem-approx-global-regression-bi"></span><span class="eqno">(27)</span>\[     b_i = f(x_{i}){\thinspace .}\]</div>
<p>Note that the matrix is a <em>rectangular</em> <span class="math">\((m+1)\times(N+1)\)</span>
matrix since <span class="math">\(i=0,\ldots,m\)</span> and <span class="math">\(j=0,\ldots,N\)</span>.</p>
</div>
<div class="section" id="the-normal-equations-derived-from-a-least-squares-principle">
<h3>The normal equations derived from a least squares principle<a class="headerlink" href="#the-normal-equations-derived-from-a-least-squares-principle" title="Permalink to this headline">¶</a></h3>
<p>The least squares method is a common technique for solving
overdetermined equations systems. Let us write the overdetermined
system <span class="math">\(\sum_{j\in{\mathcal{I}_s}} A_{i,j}c_j = b_i\)</span> more compactly in matrix form
as <span class="math">\(Ac=b\)</span>.  Since we have more equations than unknowns, it is (in
general) impossible to find a vector <span class="math">\(c\)</span> that fulfills <span class="math">\(Ac=b\)</span>. The
best we can do is to make the residual <span class="math">\(r=b-Ac\)</span> as small as
possible. That is, we can find <span class="math">\(c\)</span> such it minimizes the norm
Euclidean norm of <span class="math">\(r\)</span>: <span class="math">\(||r||\)</span>.  The algebra simplifies significantly
by minimizing <span class="math">\(||r||^2\)</span> instead.  This principle corresponds to a
least squares method.</p>
<span class="target" id="index-8"></span><p id="index-9">The <span class="math">\(i\)</span>-th component of <span class="math">\(r\)</span> reads <span class="math">\(r_i = b_i -\sum_jA_{i,j}c_j\)</span>,
so <span class="math">\(||r||^2 = \sum_ir_i^2\)</span>.
Minimizing <span class="math">\(||r||^2\)</span> with respect to the unknowns <span class="math">\(c_0,\ldots,c_N\)</span>
implies that</p>
<div class="math" id="equation-fem:approx:global:regression:r2min">
<span id="eq-fem-approx-global-regression-r2min"></span><span class="eqno">(28)</span>\[     \frac{\partial}{\partial k}||r||^2=0,\quad k=0,\ldots,N,\]</div>
<p>which leads to</p>
<div class="math">
\[\frac{\partial}{\partial k}\sum_i r_i^2 =
\sum_i 2r_i\frac{\partial r_i}{\partial k}
=\sum_i 2r_i \frac{\partial}{\partial k}(b_i -\sum_jA_{i,j}c_j)
= 2\sum_i r_i(-A_{i,k}) = 0{\thinspace .}\]</div>
<p>By inserting <span class="math">\(r_i = b_i -\sum_jA_{i,j}c_j\)</span> the last expression we
get</p>
<div class="math">
\[\sum_i\left(b_i -\sum_jA_{i,j}c_j\right)\left(-A_{i,k}\right)
= -\sum_i b_iA_{i,k} + \sum_j (\sum_i A_{i,j}A_{i,k})c_j = 0{\thinspace .}\]</div>
<p>Introducing the transpose of <span class="math">\(A\)</span>, <span class="math">\(A^T\)</span>, we know that <span class="math">\(A^T_{i,j}=A_{j,i}\)</span>,
to the expression <span class="math">\(\sum_i A_{i,j}A_{i,k}\)</span> can be written
as <span class="math">\(\sum_i A^T{k,i}A_{i,j}\)</span> and recognized as the formula for the
matrix-matrix product <span class="math">\(A^TA\)</span>. Also, <span class="math">\(\sum_i b_i A_{i,k}\)</span> can be written
<span class="math">\(\sum_i A^T_{k,i}b_i\)</span> and recognized as the matrix-vector product
<span class="math">\(A^Tb\)</span>. These observations imply that <a href="#equation-fem:approx:global:regression:r2min">(28)</a>
is equivalent to the linear system</p>
<div class="math" id="equation-fem:approx:global:regression:normal1">
<span id="eq-fem-approx-global-regression-normal1"></span><span class="eqno">(29)</span>\[     \sum_j (\underbrace{\sum_i A^T{k,i}A_{i,j}}{=(A^TA)_{k,j}}
     c_j = \sum_i \underbrace{A^T_{k,i}b_i}{=(A^Tb)_k},\quad k=0,\ldots,N,\]</div>
<p>or in matrix form,</p>
<div class="math" id="equation-fem:approx:global:regression:normal2">
<span id="eq-fem-approx-global-regression-normal2"></span><span class="eqno">(30)</span>\[      A^TA = A^Tb{\thinspace .}\]</div>
<p>The equation system <a href="#equation-fem:approx:global:regression:normal1">(29)</a> or
<a href="#equation-fem:approx:global:regression:normal2">(30)</a> are known as the
<em>normal equations</em>.
With <span class="math">\(A\)</span> as an <span class="math">\((m+1)\times (N+1)\)</span> matrix, <span class="math">\(A^TA\)</span> becomes an <span class="math">\((N+1)\times (N+1)\)</span>
matrix, and <span class="math">\(A^Tb\)</span> becomes a vector of length <span class="math">\(N+1\)</span>. Often, <span class="math">\(m\gg N\)</span>,
so <span class="math">\(A^TA\)</span> has much smaller size than <span class="math">\(A\)</span>.</p>
<p>Many prefer to write the linear system
<a href="#equation-fem:approx:global:regression:normal1">(29)</a> on the standard form
<span class="math">\(\sum_j B_{i,j}=d_i\)</span>, <span class="math">\(i=0,\ldots,N\)</span>.  We can easily do so by
exchanging the <span class="math">\(i\)</span> and <span class="math">\(k\)</span> index (<span class="math">\(i\leftrightarrow k\)</span>), <span class="math">\(\sum_i
A^T{k,i}A_{i,j} = \sum_k A^T{i,k}A_{k,j}\)</span>, and setting <span class="math">\(B_{i,j}=\sum_k
A^T{i,k}A_{k,j}\)</span>. Similarly, we exchange <span class="math">\(i\)</span> and <span class="math">\(k\)</span> in the right-hand
side expression and get <span class="math">\(\sum_k A^T_{i,k}b_k = d_i\)</span>.  Expressing
<span class="math">\(B_{i,j}\)</span> and <span class="math">\(d_i\)</span> in terms of the <span class="math">\({\psi}_i\)</span> and <span class="math">\(x_{i}\)</span>, using
<a href="#equation-fem:approx:global:regression:Aij">(26)</a> and
<a href="#equation-fem:approx:global:regression:bi">(27)</a>, we end up with the formulas</p>
<div class="math" id="equation-fem:approx:global:regression:Bij">
<span id="eq-fem-approx-global-regression-bij"></span><span class="eqno">(31)</span>\[     B_{i,j} = \sum_k A^T{i,k}A_{k,j} = \sum_k A{k,i}A_{k,j}
     =\sum_{k=0}^m{\psi}_i(x_{k}{\psi}_j(x_{k},\]</div>
<div class="math" id="equation-fem:approx:global:regression:di">
<span id="eq-fem-approx-global-regression-di"></span><span class="eqno">(32)</span>\[     d_i =\sum_k A^T_{i,k}b_k = \sum_k A_{k,i}b_k =\sum_{k=0}^m
     {\psi}_i(x_{k})f(x_{k})\]</div>
</div>
<div class="section" id="implementation-1">
<h3>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h3>
<p>The following function defines the matrix entries <span class="math">\(B_{i,j}\)</span> according
to <a href="#equation-fem:approx:global:regression:Bij">(31)</a> and the right-hand side
entries <span class="math">\(d_i\)</span> according
<a href="#equation-fem:approx:global:regression:di">(32)</a>. Thereafter, it solves the
linear system <span class="math">\(\sum_jB_{i,j}c_j=d_i\)</span>.  The input data <code class="docutils literal"><span class="pre">f</span></code> and <code class="docutils literal"><span class="pre">psi</span></code>
hold <span class="math">\(f(x)\)</span> and <span class="math">\(x_{i}\)</span>, <span class="math">\(i=0,\ldots,N\)</span>, as symbolic expression, but
since <span class="math">\(m\)</span> is thought to be much larger than <span class="math">\(N\)</span>, and there are loops
from <span class="math">\(0\)</span> to <span class="math">\(m\)</span>, we use numerical computing to speed up the
computations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">regression</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="c"># Use numpy arrays and numerical computing</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Wrap psi and f in Python functions rather than expressions</span>
    <span class="c"># so that we can evaluate psi at points[i]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">psi_sym</span> <span class="o">=</span> <span class="n">psi</span>  <span class="c"># save symbolic expression</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
</div>
<div class="section" id="example-2">
<h3>Example  (2)<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h3>
<p>We repeat the computational example from the section <a class="reference internal" href="#fem-approx-global-interp"><span class="std std-ref">The interpolation (or collocation) method</span></a>, but this time with many more
points. The parabola <span class="math">\(f(x)=10(x-1)^2-1\)</span> is to be approximated by a
linear function on <span class="math">\(\Omega=[1,2]\)</span>. We divide <span class="math">\(\Omega\)</span> into <span class="math">\(m+2\)</span>
intervals and use the inner <span class="math">\(m+1\)</span> points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">m_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="c"># Create m+3 points and use the inner m+1 points</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_values</span><span class="p">:</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="o">+</span><span class="mi">3</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">regression</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
    <span class="n">comparison_plot</span><span class="p">(</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="s">&#39;parabola_by_regression_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
        <span class="n">points_legend</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> interpolation points&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">legend_loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-linear-regression-fig1"><span class="std std-ref">Approximation of a parabola by a regression method with varying number of points</span></a> shows results for
<span class="math">\(m+1=2\)</span> (left), <span class="math">\(m+1=8\)</span> (middle), and <span class="math">\(m+1=64\)</span> (right) data points.
The approximating function is not so sensitive to the number of
points as long as they cover a significant part of the domain (2 points
are too much in the middle, but 8 points cover almost the entire
domain, and 64 points do not improve the results much):</p>
<div class="math">
\[\begin{split}u(x) &amp;= 10x - 13.2,\quad 2\hbox{ points}\\
u(x) &amp;= 10x - 12.7,\quad 8\hbox{ points}\\
u(x) &amp;= 10x - 12.7,\quad 64\hbox{ points}\end{split}\]</div>
<div class="figure" id="id6">
<span id="fem-approx-global-linear-regression-fig1"></span><a class="reference internal image-reference" href="_images/parabola_by_regression.png"><img alt="_images/parabola_by_regression.png" src="_images/parabola_by_regression.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation of a parabola by a regression method with varying number of points</em></span></p>
</div>
<p>To explicitly make the link to classical regression in statistics, we
consider <span class="math">\(f=10(x-1)^2 - 1 + \epsilon\)</span>, where <span class="math">\(\epsilon\)</span> is a random,
normally distributed variable. The goal in classical regression is
to find the straight line that best fits the data points (in a least
squares sense). The only difference from the previous setup, is that
the <span class="math">\(f(x_{i})\)</span> values are based on a function formula, here <span class="math">\(10(x-1)^2-1\)</span>,
<em>plus</em> normally distributed noise.
Figure <a class="reference internal" href="#fem-approx-global-linear-regression-fig2"><span class="std std-ref">Approximation of a parabola with noise by a straight line</span></a> shows three sets of
data points, along with the original <span class="math">\(f(x)\)</span> function without noise, and
the straight line that is a least squares approximation to the data points.</p>
<div class="figure" id="id7">
<span id="fem-approx-global-linear-regression-fig2"></span><a class="reference internal image-reference" href="_images/noisy_parabola_by_linear_regression.png"><img alt="_images/noisy_parabola_by_linear_regression.png" src="_images/noisy_parabola_by_linear_regression.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation of a parabola with noise by a straight line</em></span></p>
</div>
<p>We can fit a parabola instead of a straight line, as done in
Figure <a class="reference internal" href="#fem-approx-global-linear-regression-fig3"><span class="std std-ref">Approximation of a parabola with noise by a parabola</span></a>. When <span class="math">\(m\)</span> becomes large,
the fitted parabola and the original parabola without noise become very close.</p>
<div class="figure" id="id8">
<span id="fem-approx-global-linear-regression-fig3"></span><a class="reference internal image-reference" href="_images/noisy_parabola_by_linear_regression.png"><img alt="_images/noisy_parabola_by_linear_regression.png" src="_images/noisy_parabola_by_linear_regression.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation of a parabola with noise by a parabola</em></span></p>
</div>
</div>
<div class="section" id="remark">
<h3>Remark<a class="headerlink" href="#remark" title="Permalink to this headline">¶</a></h3>
<p>The regression method is not much used for approximating differential
equations or given function, but is central in uncertainty quantification
methods such as polynomial chaos expansions.</p>
</div>
</div>
<div class="section" id="lagrange-polynomials">
<span id="fem-approx-global-lagrange"></span><h2>Lagrange polynomials<a class="headerlink" href="#lagrange-polynomials" title="Permalink to this headline">¶</a></h2>
<p id="index-10">In the section <a class="reference internal" href="#fem-approx-global-fourier"><span class="std std-ref">Fourier series</span></a> we explained the advantage
with having a diagonal matrix: formulas for the coefficients
<span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span> can then be derived by hand. For an interpolation (or
collocation) method a diagonal matrix implies that <span class="math">\({\psi}_j(x_{i})
= 0\)</span> if <span class="math">\(i\neq j\)</span>. One set of basis functions <span class="math">\({\psi}_i(x)\)</span> with this
property is the <em>Lagrange interpolating polynomials</em>, or just
<em>Lagrange polynomials</em>. (Although the functions are named after
Lagrange, they were first discovered by Waring in 1779, rediscovered
by Euler in 1783, and published by Lagrange in 1795.)  Lagrange
polynomials key building blocks in the finite element method, so
familiarity with these polynomials will be required anyway.</p>
<p>A Lagrange polynomial can be written as</p>
<div class="math" id="equation-fem:approx:global:Lagrange:poly">
<span id="eq-fem-approx-global-lagrange-poly"></span><span class="eqno">(33)</span>\[     {\psi}_i(x) =
     \prod_{j=0,j\neq i}^N
     \frac{x-x_{j}}{x_{i}-x_{j}}
     = \frac{x-x_0}{x_{i}-x_0}\cdots\frac{x-x_{i-1}}{x_{i}-x_{i-1}}\frac{x-x_{i+1}}{x_{i}-x_{i+1}}
     \cdots\frac{x-x_N}{x_{i}-x_N},\]</div>
<p>for <span class="math">\(i\in{\mathcal{I}_s}\)</span>.
We see from <a href="#equation-fem:approx:global:Lagrange:poly">(33)</a> that all the <span class="math">\({\psi}_i\)</span>
functions are polynomials of degree <span class="math">\(N\)</span> which have the property</p>
<div class="math" id="equation-fem:inter:prop">
<span id="eq-fem-inter-prop"></span><span id="index-11"></span><span class="eqno">(34)</span>\[\begin{split}     {\psi}_i(x_s) = \delta_{is},\quad \delta_{is} =
     \left\lbrace\begin{array}{ll}
     1, &amp; i=s,\\
     0, &amp; i\neq s,
     \end{array}\right.\end{split}\]</div>
<p>when <span class="math">\(x_s\)</span> is an interpolation (collocation) point.
Here we have used the <em>Kronecker delta</em> symbol <span class="math">\(\delta_{is}\)</span>.
This property implies that <span class="math">\(A_{i,j}=0\)</span> for <span class="math">\(i\neq j\)</span> and
<span class="math">\(A_{i,j}=1\)</span> when <span class="math">\(i=j\)</span>. The solution of the linear system is
then simply</p>
<div class="math" id="equation-_auto29">
<span id="eq-auto29"></span><span class="eqno">(35)</span>\[     c_i = f(x_{i}),\quad i\in{\mathcal{I}_s},\]</div>
<p>and</p>
<div class="math" id="equation-_auto30">
<span id="eq-auto30"></span><span class="eqno">(36)</span>\[     u(x) = \sum_{j\in{\mathcal{I}_s}} f(x_{i}){\psi}_i(x){\thinspace .}\]</div>
<p>The following function computes the Lagrange interpolating polynomial
<span class="math">\({\psi}_i(x)\)</span>, given the interpolation points <span class="math">\(x_{0},\ldots,x_{N}\)</span> in
the list or array <code class="docutils literal"><span class="pre">points</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
<p>The next function computes a complete basis using equidistant points throughout
<span class="math">\(\Omega\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">x</span></code> is an <code class="docutils literal"><span class="pre">sym.Symbol</span></code> object, we let the spacing between the
interpolation points, <code class="docutils literal"><span class="pre">h</span></code>, be a <code class="docutils literal"><span class="pre">sympy</span></code> rational number, so that we
get nice end results in the formulas for <span class="math">\({\psi}_i\)</span>.  The other case,
when <code class="docutils literal"><span class="pre">x</span></code> is a plain Python <code class="docutils literal"><span class="pre">float</span></code>, signifies numerical computing, and
then we let <code class="docutils literal"><span class="pre">h</span></code> be a floating-point number.  Observe that the
<code class="docutils literal"><span class="pre">Lagrange_polynomial</span></code> function works equally well in the symbolic and
numerical case - just think of <code class="docutils literal"><span class="pre">x</span></code> being an <code class="docutils literal"><span class="pre">sym.Symbol</span></code> object or a
Python <code class="docutils literal"><span class="pre">float</span></code>.  A little interactive session illustrates the
difference between symbolic and numerical computing of the basis
functions and points:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">points</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">psi</span>
<span class="p">[(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c"># numerical computing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">points</span>
<span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">psi</span>
<span class="p">[</span><span class="o">-</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
</pre></div>
</div>
<p>The Lagrange polynomials are very much used in finite element methods
because of their property <a href="#equation-fem:inter:prop">(34)</a>.</p>
<div class="section" id="approximation-of-a-polynomial">
<h3>Approximation of a polynomial<a class="headerlink" href="#approximation-of-a-polynomial" title="Permalink to this headline">¶</a></h3>
<p>The Galerkin or least squares method lead to an exact approximation
if <span class="math">\(f\)</span> lies in the space spanned by the basis functions. It could be
of interest to see how the interpolation method with Lagrange
polynomials as basis is able to approximate a polynomial, e.g.,
a parabola. Running</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">psi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>shows the result that up to <code class="docutils literal"><span class="pre">N=4</span></code> we achieve an exact approximation,
and then round-off errors start to grow, such that
<code class="docutils literal"><span class="pre">N=15</span></code> leads to a 15-degree polynomial for <span class="math">\(u\)</span> where
the coefficients in front of <span class="math">\(x^r\)</span> for <span class="math">\(r&gt;2\)</span> are
of size <span class="math">\(10^{-5}\)</span> and smaller.</p>
</div>
<div class="section" id="successful-example">
<h3>Successful example<a class="headerlink" href="#successful-example" title="Permalink to this headline">¶</a></h3>
<p>Trying out the Lagrange polynomial basis for approximating
<span class="math">\(f(x)=\sin 2\pi x\)</span> on <span class="math">\(\Omega =[0,1]\)</span> with the least squares
and the interpolation techniques can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">psi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-sine-ls-colloc"><span class="std std-ref">Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 3</span></a> shows the results.
There is little difference between the least squares and the interpolation
technique. Increasing <span class="math">\(N\)</span> gives visually better approximations.</p>
<div class="figure" id="id9">
<span id="fem-approx-global-lagrange-fig-sine-ls-colloc"></span><a class="reference internal image-reference" href="_images/Lagrange_ls_interp_sin_4.png"><img alt="_images/Lagrange_ls_interp_sin_4.png" src="_images/Lagrange_ls_interp_sin_4.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 3</em></span></p>
</div>
</div>
<div class="section" id="less-successful-example">
<span id="index-12"></span><h3>Less successful example<a class="headerlink" href="#less-successful-example" title="Permalink to this headline">¶</a></h3>
<p>The next example concerns interpolating <span class="math">\(f(x)=|1-2x|\)</span> on <span class="math">\(\Omega
=[0,1]\)</span> using Lagrange polynomials. Figure
<a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-7-14"><span class="std std-ref">Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</span></a> shows a peculiar
effect: the approximation starts to oscillate more and more as <span class="math">\(N\)</span>
grows. This numerical artifact is not surprising when looking at the
individual Lagrange polynomials. Figure
<a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-osc"><span class="std std-ref">Illustration of the oscillatory behavior of two Lagrange polynomials based on 12 uniformly spaced points (marked by circles)</span></a> shows two such
polynomials, <span class="math">\(\psi_2(x)\)</span> and <span class="math">\(\psi_7(x)\)</span>, both of degree 11 and
computed from uniformly spaced points <span class="math">\(x_{x_i}=i/11\)</span>,
<span class="math">\(i=0,\ldots,11\)</span>, marked with circles.  We clearly see the property of
Lagrange polynomials: <span class="math">\(\psi_2(x_{i})=0\)</span> and <span class="math">\(\psi_7(x_{i})=0\)</span> for
all <span class="math">\(i\)</span>, except <span class="math">\(\psi_2(x_{2})=1\)</span> and <span class="math">\(\psi_7(x_{7})=1\)</span>.  The most
striking feature, however, is the significant oscillation near the
boundary. The reason is easy to understand: since we force the
functions to zero at so many points, a polynomial of high degree is
forced to oscillate between the points.  The phenomenon is named
<em>Runge&#8217;s phenomenon</em> and you can read a more detailed explanation on
<a class="reference external" href="http://en.wikipedia.org/wiki/Runge%27s_phenomenon">Wikipedia</a>.</p>
</div>
<div class="section" id="remedy-for-strong-oscillations">
<span id="index-13"></span><h3>Remedy for strong oscillations<a class="headerlink" href="#remedy-for-strong-oscillations" title="Permalink to this headline">¶</a></h3>
<p>The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:</p>
<div class="math" id="equation-_auto31">
<span id="eq-auto31"></span><span class="eqno">(37)</span>\[     x_{i} = \frac{1}{2} (a+b) + \frac{1}{2}(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,\]</div>
<p>on the interval <span class="math">\(\Omega = [a,b]\)</span>.
Here is a flexible version of the <code class="docutils literal"><span class="pre">Lagrange_polynomials_01</span></code> function above,
valid for any interval <span class="math">\(\Omega =[a,b]\)</span> and with the possibility to generate
both uniformly distributed points and Chebyshev nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomials</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">point_distribution</span><span class="o">=</span><span class="s">&#39;uniform&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s">&#39;Chebyshev&#39;</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">Chebyshev_nodes</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">psi</span><span class="p">,</span> <span class="n">points</span>

<span class="k">def</span> <span class="nf">Chebyshev_nodes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
    <span class="k">return</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> \
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>All the functions computing Lagrange polynomials listed
above are found in the module file <code class="docutils literal"><span class="pre">Lagrange.py</span></code>.</p>
<p>Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-cheb-7-14"><span class="std std-ref">Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right)</span></a> shows the
improvement of using Chebyshev nodes, compared with the equidistant
points in Figure
<a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-7-14"><span class="std std-ref">Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</span></a>.  The reason for
this improvement is that the corresponding Lagrange polynomials have
much smaller oscillations, which can be seen by comparing Figure
<a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-cheb-osc"><span class="std std-ref">Illustration of the less oscillatory behavior of two Lagrange polynomials based on 12 Chebyshev points (marked by circles)</span></a> (Chebyshev
points) with Figure
<a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-osc"><span class="std std-ref">Illustration of the oscillatory behavior of two Lagrange polynomials based on 12 uniformly spaced points (marked by circles)</span></a> (equidistant
points). Note the different scale on the vertical axes in the two
figures.</p>
<p>Another cure for undesired oscillations of higher-degree interpolating
polynomials is to use lower-degree Lagrange polynomials on many small
patches of the domain. This is actually the idea pursued in the finite
element method. For instance, linear Lagrange polynomials on <span class="math">\([0,1/2]\)</span>
and <span class="math">\([1/2,1]\)</span> would yield a perfect approximation to <span class="math">\(f(x)=|1-2x|\)</span> on
<span class="math">\(\Omega = [0,1]\)</span> since <span class="math">\(f\)</span> is piecewise linear.</p>
<div class="figure" id="id10">
<span id="fem-approx-global-lagrange-fig-abs-lag-unif-7-14"></span><a class="reference internal image-reference" href="_images/Lagrange_interp_abs_8_15.png"><img alt="_images/Lagrange_interp_abs_8_15.png" src="_images/Lagrange_interp_abs_8_15.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</em></span></p>
</div>
<div class="figure" id="id11">
<span id="fem-approx-global-lagrange-fig-abs-lag-unif-osc"></span><a class="reference internal image-reference" href="_images/Lagrange_basis_12.png"><img alt="_images/Lagrange_basis_12.png" src="_images/Lagrange_basis_12.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of the oscillatory behavior of two Lagrange polynomials based on 12 uniformly spaced points (marked by circles)</em></span></p>
</div>
<div class="figure" id="id12">
<span id="fem-approx-global-lagrange-fig-abs-lag-cheb-7-14"></span><a class="reference internal image-reference" href="_images/Lagrange_interp_abs_Cheb_8_15.png"><img alt="_images/Lagrange_interp_abs_Cheb_8_15.png" src="_images/Lagrange_interp_abs_Cheb_8_15.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right)</em></span></p>
</div>
<div class="figure" id="id13">
<span id="fem-approx-global-lagrange-fig-abs-lag-cheb-osc"></span><a class="reference internal image-reference" href="_images/Lagrange_basis_Cheb_12.png"><img alt="_images/Lagrange_basis_Cheb_12.png" src="_images/Lagrange_basis_Cheb_12.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of the less oscillatory behavior of two Lagrange polynomials based on 12 Chebyshev points (marked by circles)</em></span></p>
</div>
<p>How does the least squares or projection methods work with Lagrange
polynomials?
We can just call the <code class="docutils literal"><span class="pre">least_squares</span></code> function, but
<code class="docutils literal"><span class="pre">sympy</span></code> has problems integrating the <span class="math">\(f(x)=|1-2x|\)</span>
function times a polynomial, so we need to fall back on numerical
integration.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="c"># Could not integrate symbolically, fall back</span>
                <span class="c"># on numerical integration with mpmath.quad</span>
                <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</div>
<p>The idea of avoiding oscillatory solutions by
using lower-order Lagrange polynomials on smaller patches
throughout the domain, is important in the finite element
method, and the next section introduces finite element basis
functions based on Lagrange polynomials.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Approximation of functions</a><ul>
<li><a class="reference internal" href="#the-least-squares-method-3">The least squares method  (3)</a></li>
<li><a class="reference internal" href="#the-projection-or-galerkin-method">The projection (or Galerkin) method</a></li>
<li><a class="reference internal" href="#example-linear-approximation">Example: linear approximation</a></li>
<li><a class="reference internal" href="#implementation-of-the-least-squares-method">Implementation of the least squares method</a><ul>
<li><a class="reference internal" href="#symbolic-integration">Symbolic integration</a></li>
<li><a class="reference internal" href="#fall-back-on-numerical-integration">Fall back on numerical integration</a></li>
<li><a class="reference internal" href="#plotting-the-approximation">Plotting the approximation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#perfect-approximation">Perfect approximation</a></li>
<li><a class="reference internal" href="#ill-conditioning">Ill-conditioning</a></li>
<li><a class="reference internal" href="#fourier-series">Fourier series</a></li>
<li><a class="reference internal" href="#orthogonal-basis-functions">Orthogonal basis functions</a></li>
<li><a class="reference internal" href="#numerical-computations">Numerical computations</a></li>
<li><a class="reference internal" href="#the-interpolation-or-collocation-method">The interpolation (or collocation) method</a><ul>
<li><a class="reference internal" href="#example-1">Example  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-regression-method">The regression method</a><ul>
<li><a class="reference internal" href="#overdetermined-equation-system">Overdetermined equation system</a></li>
<li><a class="reference internal" href="#the-normal-equations-derived-from-a-least-squares-principle">The normal equations derived from a least squares principle</a></li>
<li><a class="reference internal" href="#implementation-1">Implementation  (1)</a></li>
<li><a class="reference internal" href="#example-2">Example  (2)</a></li>
<li><a class="reference internal" href="#remark">Remark</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lagrange-polynomials">Lagrange polynomials</a><ul>
<li><a class="reference internal" href="#approximation-of-a-polynomial">Approximation of a polynomial</a></li>
<li><a class="reference internal" href="#successful-example">Successful example</a></li>
<li><a class="reference internal" href="#less-successful-example">Less successful example</a></li>
<li><a class="reference internal" href="#remedy-for-strong-oscillations">Remedy for strong oscillations</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_approx002.html"
                        title="previous chapter">Approximation of vectors</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_approx004.html"
                        title="next chapter">Finite element basis functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_approx003.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_approx004.html" title="Finite element basis functions"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_approx002.html" title="Approximation of vectors"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Approximation of functions</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>