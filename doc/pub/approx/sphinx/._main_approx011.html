
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exercises</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Approximation of functions" href="index.html" />
    <link rel="next" title="Bibliography" href="._main_approx012.html" />
    <link rel="prev" title="Finite elements in 2D and 3D" href="._main_approx010.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_approx012.html" title="Bibliography"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_approx010.html" title="Finite elements in 2D and 3D"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Approximation of functions</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-1-linear-algebra-refresher">
<span id="fem-approx-exer-linalg1"></span><h2>Problem 1: Linear algebra refresher<a class="headerlink" href="#problem-1-linear-algebra-refresher" title="Permalink to this headline">¶</a></h2>
<p>Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.</p>
<p><strong>a)</strong>
Prove that vectors in the plane <span class="math">\((a,b)\)</span> form a vector space
by showing that all the axioms of a vector space are satisfied.</p>
<p><strong>b)</strong>
Prove that all linear functions of the form <span class="math">\(ax+b\)</span> constitute a vector space,
<span class="math">\(a,b\in\mathbb{R}\)</span>.</p>
<p><strong>c)</strong>
Show that all quadratic functions of the form <span class="math">\(1 + ax^2 + bx\)</span> <em>do not</em>
constitute a vector space.</p>
<p><strong>d)</strong>
Check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form <span class="math">\(ax+b\)</span>, <span class="math">\(a,b\in\mathbb{R}\)</span>,
defined on some interval <span class="math">\(\Omega=[A,B]\)</span>.
Show that this particular inner product satisfies the
general requirements of an inner product in a vector space.</p>
<p>Filename: <code class="docutils literal"><span class="pre">linalg1</span></code>.</p>
</div>
<div class="section" id="problem-2-approximate-a-three-dimensional-vector-in-a-plane">
<span id="fem-approx-exer-vec-3dby2d"></span><h2>Problem 2: Approximate a three-dimensional vector in a plane<a class="headerlink" href="#problem-2-approximate-a-three-dimensional-vector-in-a-plane" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(\boldsymbol{f} = (1,1,1)\)</span> in <span class="math">\(\mathbb{R}^3\)</span>, find the best approximation vector
<span class="math">\(\boldsymbol{u}\)</span> in the plane spanned by the unit vectors <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span>.
Repeat the calculations using the vectors <span class="math">\((2,1)\)</span> and <span class="math">\((1,2)\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vec111_approx</span></code>.</p>
</div>
<div class="section" id="problem-3-approximate-a-parabola-by-a-sine">
<span id="fem-approx-exer-parabola-sine"></span><h2>Problem 3: Approximate a parabola by a sine<a class="headerlink" href="#problem-3-approximate-a-parabola-by-a-sine" title="Permalink to this headline">¶</a></h2>
<p>Given the function <span class="math">\(f(x)=1 + 2x(1-x)\)</span> on <span class="math">\(\Omega=[0,1]\)</span>, we want to
find an approximation in the function space</p>
<div class="math">
\[V = \hbox{span}\{1, \sin(\pi x)\}{\thinspace .}\]</div>
<p><strong>a)</strong>
Sketch or plot <span class="math">\(f(x)\)</span>. Think intuitively how an expansion in terms
of the basis functions of <span class="math">\(V\)</span>, <span class="math">\({\psi}_0(x)=1\)</span>, <span class="math">\({\psi}_1(x)=\sin(\pi x)\)</span>,
can be construction to yield a best approximation to <span class="math">\(f\)</span>. Or
phrased differently, see if you can guess the coefficients <span class="math">\(c_0\)</span> and <span class="math">\(c_1\)</span>
in the expansion</p>
<div class="math">
\[u(x) = c_0{\psi}_0 + c_1{\psi}_1 = c_0 + c_1\sin (\pi x){\thinspace .}\]</div>
<p>Compute the <span class="math">\(L^2\)</span> error <span class="math">\(||f-u||_{L^2}=(\int_0^1(f-u)^2{\, \mathrm{d}x})^{1/2}\)</span>.</p>
<p><strong>Hint.</strong>
If you make a mesh function <code class="docutils literal"><span class="pre">e</span></code> of the error
on some mesh with uniformly spaced coordinates in
the array <code class="docutils literal"><span class="pre">xc</span></code>, the integral can be approximated as <code class="docutils literal"><span class="pre">np.sqrt(dx*np.sum(e**2))</span></code>,
where <code class="docutils literal"><span class="pre">dx=xc[0]-xc[1]</span></code> is the mesh spacing and <code class="docutils literal"><span class="pre">np</span></code> is an alias for the
<code class="docutils literal"><span class="pre">numpy</span></code> module in Python.</p>
<p><strong>b)</strong>
Perform the hand calculations for a least squares approximation.</p>
<p>Filename: <code class="docutils literal"><span class="pre">parabola_sin</span></code>.</p>
</div>
<div class="section" id="problem-4-approximate-the-exponential-function-by-power-functions">
<span id="fem-approx-exer-exp-powers"></span><h2>Problem 4: Approximate the exponential function by power functions<a class="headerlink" href="#problem-4-approximate-the-exponential-function-by-power-functions" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math">\(V\)</span> be a function space with basis functions <span class="math">\(x^i\)</span>,
<span class="math">\(i=0,1,\ldots,N\)</span>.  Find the best approximation to <span class="math">\(f(x)=\exp(-x)\)</span> on
<span class="math">\(\Omega =[0,8]\)</span> among all functions in <span class="math">\(V\)</span> for <span class="math">\(N=2,4,6\)</span>. Illustrate
the three approximations in three separate plots.</p>
<p><strong>Hint.</strong>
Apply the <code class="docutils literal"><span class="pre">lest_squares</span></code> and
<code class="docutils literal"><span class="pre">comparison_plot</span></code> functions in the <code class="docutils literal"><span class="pre">approx1D.py</span></code> module as these
make the exercise easier to solve.</p>
<p>Filename: <code class="docutils literal"><span class="pre">exp_powers</span></code>.</p>
</div>
<div class="section" id="problem-5-approximate-the-sine-function-by-power-functions">
<span id="fem-approx-exer-sin-powers"></span><h2>Problem 5: Approximate the sine function by power functions<a class="headerlink" href="#problem-5-approximate-the-sine-function-by-power-functions" title="Permalink to this headline">¶</a></h2>
<p>In this exercise we want to approximate the sine function by polynomials
of order <span class="math">\(N+1\)</span>. Consider two bases:</p>
<div class="math">
\[\begin{split}V_1 &amp;= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\
V_2 &amp;= \{1,x,x^2,x^3,\ldots, x^N\}{\thinspace .}\end{split}\]</div>
<p>The basis <span class="math">\(V_1\)</span> is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while <span class="math">\(V_2\)</span>
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.</p>
<p>Compute the best approximation to <span class="math">\(f(x)=\sin(x)\)</span> among all functions
in <span class="math">\(V_1\)</span> and <span class="math">\(V_2\)</span> on two domains of increasing sizes: <span class="math">\(\Omega_{1,k} =
[0, k\pi]\)</span>, <span class="math">\(k=2,3\ldots,6\)</span> and <span class="math">\(\Omega_{2,k} = [-k\pi /2, k\pi/2]\)</span>,
<span class="math">\(k=2,3,4,5\)</span>.  Make plots for all combinations of <span class="math">\(V_1\)</span>, <span class="math">\(V_2\)</span>,
<span class="math">\(\Omega_1\)</span>, <span class="math">\(\Omega_2\)</span>, <span class="math">\(k=2,3,\ldots,6\)</span>.</p>
<p>Add a plot of the <span class="math">\(N\)</span>-th degree Taylor polynomial approximation of
<span class="math">\(\sin(x)\)</span> around <span class="math">\(x=0\)</span>.</p>
<p><strong>Hint.</strong>
You can make a loop over <span class="math">\(V_1\)</span> and <span class="math">\(V_2\)</span>, a loop over
<span class="math">\(\Omega_1\)</span> and <span class="math">\(\Omega_2\)</span>, and a loop over <span class="math">\(k\)</span>. Inside the loops,
call the functions <code class="docutils literal"><span class="pre">least_squares</span></code> and
<code class="docutils literal"><span class="pre">comparison_plot</span></code> from the <code class="docutils literal"><span class="pre">approx1D</span></code> module.
<span class="math">\(N=7\)</span> is a suggested value.</p>
<p>Filename: <code class="docutils literal"><span class="pre">sin_powers</span></code>.</p>
</div>
<div class="section" id="problem-6-approximate-a-steep-function-by-sines">
<span id="fem-approx-exer-tanh-sine1"></span><h2>Problem 6: Approximate a steep function by sines<a class="headerlink" href="#problem-6-approximate-a-steep-function-by-sines" title="Permalink to this headline">¶</a></h2>
<p>Find the best approximation of <span class="math">\(f(x) = \tanh (s(x-\pi))\)</span> on
<span class="math">\([0, 2\pi]\)</span> in the space <span class="math">\(V\)</span> with basis
<span class="math">\({\psi}_i(x) = \sin((2i+1)x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s} = \{0,\ldots,N\}\)</span>.
Make a movie showing how <span class="math">\(u=\sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j(x)\)</span>
approximates <span class="math">\(f(x)\)</span> as <span class="math">\(N\)</span> grows. Choose <span class="math">\(s\)</span> such that <span class="math">\(f\)</span> is
steep (<span class="math">\(s=20\)</span> is appropriate).</p>
<p><strong>Hint 1.</strong>
One may naively call the <code class="docutils literal"><span class="pre">least_squares_orth</span></code> and <code class="docutils literal"><span class="pre">comparison_plot</span></code>
from the <code class="docutils literal"><span class="pre">approx1D</span></code> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <code class="docutils literal"><span class="pre">least_squares_orth</span></code>
compute with only one basis function at a time and accumulate
the corresponding <code class="docutils literal"><span class="pre">u</span></code> in the total solution.</p>
<p><strong>Hint 2.</strong>
<code class="docutils literal"><span class="pre">ffmpeg</span></code> or <code class="docutils literal"><span class="pre">avconv</span></code> may skip frames when plot files are combined to
a movie. Since there are few files and we want to see each of them,
use <code class="docutils literal"><span class="pre">convert</span></code> to make an animated GIF file (<code class="docutils literal"><span class="pre">-delay</span> <span class="pre">200</span></code> is
suitable).</p>
<p>Filename: <code class="docutils literal"><span class="pre">tanh_sines</span></code>.</p>
<div class="section" id="remarks-1">
<h3>Remarks  (1)<a class="headerlink" href="#remarks-1" title="Permalink to this headline">¶</a></h3>
<p>Approximation of a discontinuous (or steep) <span class="math">\(f(x)\)</span> by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in <span class="math">\(f\)</span>.
This is known as the <a class="reference external" href="http://en.wikipedia.org/wiki/Gibbs_phenomenon">Gibb&#8217;s phenomenon</a>.</p>
</div>
</div>
<div class="section" id="problem-7-approximate-a-steep-function-by-sines-with-boundary-adjustment">
<span id="fem-approx-exer-tanh-sine3"></span><h2>Problem 7: Approximate a steep function by sines with boundary adjustment<a class="headerlink" href="#problem-7-approximate-a-steep-function-by-sines-with-boundary-adjustment" title="Permalink to this headline">¶</a></h2>
<p>We study the same approximation problem as in
<a class="reference internal" href="#fem-approx-exer-tanh-sine1"><span class="std std-ref">Problem 6: Approximate a steep function by sines</span></a>. Since <span class="math">\({\psi}_i(0)={\psi}_i(2\pi)=0\)</span>
for all <span class="math">\(i\)</span>, <span class="math">\(u=0\)</span> at the boundary points <span class="math">\(x=0\)</span> and <span class="math">\(x=2\pi\)</span>, while
<span class="math">\(f(0)=-1\)</span> and <span class="math">\(f(2\pi)=1\)</span>. This discrepancy at the boundary can be
removed by adding a boundary function <span class="math">\(B(x)\)</span>:</p>
<div class="math">
\[u(x) = B(x) + \sum_{j\in{\mathcal{I}_s}} c_j{\psi}_j(x),\]</div>
<p>where <span class="math">\(B(x)\)</span> has the right boundary values: <span class="math">\(B(x_L)=f(x_L)\)</span> and
<span class="math">\(B(x_R)=f(x_R)\)</span>, with <span class="math">\(x_L=0\)</span> and <span class="math">\(x_R=2\pi\)</span> as the boundary points.
A linear choice of <span class="math">\(B(x)\)</span> is</p>
<div class="math">
\[B(x) = \frac{(x_R-x)f(x_L) + (x-x_L)f(x_R)}{x_R-x_L}{\thinspace .}\]</div>
<p><strong>a)</strong>
Use the basis
<span class="math">\({\psi}_i(x) = \sin((i+1)x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s} = \{0,\ldots,N\}\)</span>
and plot <span class="math">\(u\)</span> and <span class="math">\(f\)</span> for <span class="math">\(N=16\)</span>. (It suffices to make plots for even <span class="math">\(i\)</span>.)</p>
<p><strong>b)</strong>
Use the basis from <a class="reference internal" href="#fem-approx-exer-tanh-sine1"><span class="std std-ref">Problem 6: Approximate a steep function by sines</span></a>,
<span class="math">\({\psi}_i(x) = \sin((2i+1)x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s} = \{0,\ldots,N\}\)</span>.
(It suffices to make plots for even <span class="math">\(i\)</span>.)
Observe that the approximation converges to a piecewise
linear function!</p>
<p><strong>c)</strong>
Use the basis
<span class="math">\({\psi}_i(x) = \sin(2(i+1)x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s} = \{0,\ldots,N\}\)</span>,
and observe that the approximation converges to a piecewise
constant function.</p>
<p>Filename: <code class="docutils literal"><span class="pre">tanh_sines_boundary_term</span></code>.</p>
<div class="section" id="remarks-2">
<h3>Remarks  (2)<a class="headerlink" href="#remarks-2" title="Permalink to this headline">¶</a></h3>
<p>The strange results in b) and c) are due to the choice of
basis. In b), <span class="math">\({\varphi}_i(x)\)</span> is an odd function around
<span class="math">\(x=\pi/2\)</span> and <span class="math">\(x=3\pi/2\)</span>. No combination of basis functions
is able to approximate the flat regions of <span class="math">\(f\)</span>.
All basis functions in c) are even around <span class="math">\(x=\pi/2\)</span> and <span class="math">\(x=3\pi/2\)</span>,
but odd at <span class="math">\(x=0,\pi,2\pi\)</span>. With all the sines represented, as in a),
the approximation is not constrained with a particular symmetry
behavior.</p>
</div>
</div>
<div class="section" id="exercise-8-fourier-series-as-a-least-squares-approximation">
<span id="fem-approx-exer-fourier"></span><h2>Exercise 8: Fourier series as a least squares approximation<a class="headerlink" href="#exercise-8-fourier-series-as-a-least-squares-approximation" title="Permalink to this headline">¶</a></h2>
<p><strong>a)</strong>
Given a function <span class="math">\(f(x)\)</span> on an interval <span class="math">\([0,L]\)</span>, look up the formula
for the coefficients <span class="math">\(a_j\)</span> and <span class="math">\(b_j\)</span> in the Fourier series of <span class="math">\(f\)</span>:</p>
<div class="math">
\[f(x) = \frac{1}{2}a_0 +
\sum_{j=1}^\infty a_j\cos \left(j\frac{2\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{2\pi x}{L}\right){\thinspace .}\]</div>
<p><strong>b)</strong>
Let an infinite-dimensional vector space <span class="math">\(V\)</span> have the basis functions
<span class="math">\(\cos j\frac{2\pi x}{L}\)</span> for <span class="math">\(j=0,1,\dots,\infty\)</span> and
<span class="math">\(\sin j\frac{2\pi x}{L}\)</span> for <span class="math">\(j=1,\dots,\infty\)</span>.  Show that the least squares
approximation method from the section <a class="reference internal" href="._main_approx003.html#fem-approx-global"><span class="std std-ref">Approximation of functions</span></a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of <span class="math">\(f(x)\)</span> (see also
the section <a class="reference internal" href="._main_approx003.html#fem-approx-global-fourier"><span class="std std-ref">Fourier series</span></a>).</p>
<p><strong>Hint.</strong>
You may choose</p>
<div class="math" id="equation-fem:approx:exer:Fourier:basis">
<span id="eq-fem-approx-exer-fourier-basis"></span><span class="eqno">(1)</span>\[     {\psi}_{2i} = \cos\left( i\frac{2\pi}{L}x\right),\quad
     {\psi}_{2i+1} = \sin\left( i\frac{2\pi}{L}x\right),\]</div>
<p>for <span class="math">\(i=0,1,\ldots,N\rightarrow\infty\)</span>.</p>
<p><strong>c)</strong>
Choose <span class="math">\(f(x) = H(x-\frac{1}{2})\)</span> on <span class="math">\(\Omega=[0,1]\)</span>, where <span class="math">\(H\)</span> is the
Heaviside function: <span class="math">\(H(x)=0\)</span> for <span class="math">\(x&lt;0\)</span>, <span class="math">\(H(x)=1\)</span> for <span class="math">\(x&gt;0\)</span> and
<span class="math">\(H(0)=\frac{1}{2}\)</span>. Find the coefficients <span class="math">\(a_j\)</span> and <span class="math">\(b_j\)</span> in the
Fourier series for <span class="math">\(f(x)\)</span>. Plot the sum for <span class="math">\(j=2N+1\)</span>, where <span class="math">\(N=5\)</span> and
<span class="math">\(N=100\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Fourier_ls</span></code>.</p>
</div>
<div class="section" id="problem-9-approximate-a-steep-function-by-lagrange-polynomials">
<span id="fem-approx-exer-tanh-lagrange"></span><h2>Problem 9: Approximate a steep function by Lagrange polynomials<a class="headerlink" href="#problem-9-approximate-a-steep-function-by-lagrange-polynomials" title="Permalink to this headline">¶</a></h2>
<p>Use interpolation with uniformly distributed
points and Chebychev nodes to approximate</p>
<div class="math">
\[f(x) = -\tanh(s(x-\frac{1}{2})),\quad x\in [0,1],\]</div>
<p>by Lagrange polynomials for <span class="math">\(s=5\)</span> and <span class="math">\(s=20\)</span>, and <span class="math">\(N=3,7,11,15\)</span>.
Combine <span class="math">\(2\times 2\)</span> plots of the approximation for the four
<span class="math">\(N\)</span> values, and create such figures for the four combinations of
<span class="math">\(s\)</span> values and point types.</p>
<p>Filename: <code class="docutils literal"><span class="pre">tanh_Lagrange</span></code>.</p>
</div>
<div class="section" id="problem-10-approximate-a-steep-function-by-lagrange-polynomials-and-regression">
<span id="fem-approx-exer-tanh-lagrange-regression"></span><h2>Problem 10: Approximate a steep function by Lagrange polynomials and regression<a class="headerlink" href="#problem-10-approximate-a-steep-function-by-lagrange-polynomials-and-regression" title="Permalink to this headline">¶</a></h2>
<p>Redo <a class="reference internal" href="#fem-approx-exer-tanh-lagrange"><span class="std std-ref">Problem 9: Approximate a steep function by Lagrange polynomials</span></a>, but apply a regression
method with <span class="math">\(N\)</span>-degree Lagrange polynomials and <span class="math">\(2N+1\)</span>
data points. Recall that
<a class="reference internal" href="#fem-approx-exer-tanh-lagrange"><span class="std std-ref">Problem 9: Approximate a steep function by Lagrange polynomials</span></a> applies <span class="math">\(N+1\)</span> points and
the resulting approximation interpolates <span class="math">\(f\)</span> at these points, while
a regression method with more points does not interpolate <span class="math">\(f\)</span> at the
data points.
Do more points and a regression method help reduce
the oscillatory behavior of Lagrange polynomial approximations?</p>
<p>Filename: <code class="docutils literal"><span class="pre">tanh_Lagrange_regression</span></code>.</p>
</div>
<div class="section" id="problem-11-define-nodes-and-elements">
<span id="fem-approx-fe-exer-mesh1"></span><h2>Problem 11: Define nodes and elements<a class="headerlink" href="#problem-11-define-nodes-and-elements" title="Permalink to this headline">¶</a></h2>
<p>Consider a domain <span class="math">\(\Omega =[0,2]\)</span> divided into the three elements
<span class="math">\([0,1]\)</span>, <span class="math">\([1,1.2]\)</span>, and <span class="math">\([1.2,2]\)</span>.</p>
<p>For P1 and P2 elements, set up the list of coordinates and nodes
(<code class="docutils literal"><span class="pre">nodes</span></code>) and the numbers of the nodes that belong to each element
(<code class="docutils literal"><span class="pre">elements</span></code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_numberings1</span></code>.</p>
</div>
<div class="section" id="problem-12-define-vertices-cells-and-dof-maps">
<span id="fem-approx-fe-exer-mesh2"></span><h2>Problem 12: Define vertices, cells, and dof maps<a class="headerlink" href="#problem-12-define-vertices-cells-and-dof-maps" title="Permalink to this headline">¶</a></h2>
<p>Repeat <a class="reference internal" href="#fem-approx-fe-exer-mesh1"><span class="std std-ref">Problem 11: Define nodes and elements</span></a>, but define the
data structures <code class="docutils literal"><span class="pre">vertices</span></code>, <code class="docutils literal"><span class="pre">cells</span></code>, and <code class="docutils literal"><span class="pre">dof_map</span></code> instead of
<code class="docutils literal"><span class="pre">nodes</span></code> and <code class="docutils literal"><span class="pre">elements</span></code>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_numberings2</span></code>.</p>
</div>
<div class="section" id="problem-13-construct-matrix-sparsity-patterns">
<span id="fem-approx-fe-exer-defmesh-sparsity"></span><h2>Problem 13: Construct matrix sparsity patterns<a class="headerlink" href="#problem-13-construct-matrix-sparsity-patterns" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#fem-approx-fe-exer-mesh1"><span class="std std-ref">Problem 11: Define nodes and elements</span></a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a <span class="math">\(5\times 5\)</span> matrix and fill in the entries that will be nonzero.</p>
<p><strong>Hint.</strong>
A matrix entry <span class="math">\((i,j)\)</span> is nonzero if <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are nodes in the
same element.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_sparsity_pattern</span></code>.</p>
</div>
<div class="section" id="problem-14-perform-symbolic-finite-element-computations">
<span id="fem-approx-fe-exer-asinwt-symbolic"></span><h2>Problem 14: Perform symbolic finite element computations<a class="headerlink" href="#problem-14-perform-symbolic-finite-element-computations" title="Permalink to this headline">¶</a></h2>
<p>Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating <span class="math">\(f(x) = \sin (x)\)</span> on
<span class="math">\(\Omega=[0, \pi]\)</span> by two P1 elements of size <span class="math">\(\pi/2\)</span>.  Solve the
system and compare <span class="math">\(u(\pi/2)\)</span> with the exact value 1.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_sin_P1</span></code>.</p>
</div>
<div class="section" id="problem-15-approximate-a-steep-function-by-p1-and-p2-elements">
<span id="fem-approx-exer-tanh-p1p2"></span><h2>Problem 15: Approximate a steep function by P1 and P2 elements<a class="headerlink" href="#problem-15-approximate-a-steep-function-by-p1-and-p2-elements" title="Permalink to this headline">¶</a></h2>
<p>Given</p>
<div class="math">
\[f(x) = \tanh(s(x-\frac{1}{2}))\]</div>
<p>use the Galerkin or least squares method with finite elements to find
an approximate function <span class="math">\(u(x)\)</span>. Choose <span class="math">\(s=20\)</span> and try
<span class="math">\(N_e=4,8,16\)</span> P1 elements and
<span class="math">\(N_e=2,4,8\)</span> P2 elements.
Integrate <span class="math">\(f{\varphi}_i\)</span> numerically.</p>
<p><strong>Hint.</strong>
You can automate the computations by calling the <code class="docutils literal"><span class="pre">approximate</span></code> method
in the <code class="docutils literal"><span class="pre">fe_approx1D_numint</span></code> module.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_tanh_P1P2</span></code>.</p>
</div>
<div class="section" id="problem-16-approximate-a-steep-function-by-p3-and-p4-elements">
<span id="fem-approx-exer-tanh-p3p4"></span><h2>Problem 16: Approximate a steep function by P3 and P4 elements<a class="headerlink" href="#problem-16-approximate-a-steep-function-by-p3-and-p4-elements" title="Permalink to this headline">¶</a></h2>
<p><strong>a)</strong>
Solve <a class="reference internal" href="#fem-approx-exer-tanh-p1p2"><span class="std std-ref">Problem 15: Approximate a steep function by P1 and P2 elements</span></a> using <span class="math">\(N_e=1,2,4\)</span> P3 and P4
elements.</p>
<p><strong>b)</strong>
How will an interpolation method work in
this case with the same number of nodes?</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_tanh_P3P4</span></code>.</p>
</div>
<div class="section" id="exercise-17-investigate-the-approximation-error-in-finite-elements">
<span id="fem-approx-fe-exer-asinwt-interpol-error"></span><h2>Exercise 17: Investigate the approximation error in finite elements<a class="headerlink" href="#exercise-17-investigate-the-approximation-error-in-finite-elements" title="Permalink to this headline">¶</a></h2>
<p>The theory <a class="reference internal" href="._main_approx007.html#eq-fem-approx-fe-error-theorem"><span class="std std-ref">(8.1)</span></a> from the section <a class="reference internal" href="._main_approx007.html#fem-approx-fe-error"><span class="std std-ref">Computing the error of the approximation</span></a> predicts that the error in the Pd
approximation of a function should behave as <span class="math">\(h^{d+1}\)</span>, where <span class="math">\(h\)</span> is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough <span class="math">\(h\)</span>).  Choose three examples:
<span class="math">\(f(x)=Ae^{-\omega x}\)</span> on <span class="math">\([0,3/\omega]\)</span>, <span class="math">\(f(x) = A\sin (\omega x)\)</span> on
<span class="math">\(\Omega=[0, 2\pi/\omega]\)</span> for constant <span class="math">\(A\)</span> and <span class="math">\(\omega\)</span>, and
<span class="math">\(f(x)=\sqrt{x}\)</span> on <span class="math">\([0,1]\)</span>.</p>
<p><strong>Hint.</strong>
Run a series of experiments: <span class="math">\((h_i,E_i)\)</span>, <span class="math">\(i=0,\ldots,m\)</span>, where <span class="math">\(E_i\)</span>
is the <span class="math">\(L^2\)</span> norm of the error corresponding to element length <span class="math">\(h_i\)</span>.
Assume an error model <span class="math">\(E=Ch^r\)</span> and compute <span class="math">\(r\)</span> from two successive
experiments:</p>
<div class="math">
\[r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1{\thinspace .}\]</div>
<p>Hopefully, the sequence <span class="math">\(r_0,\ldots,r_{m-1}\)</span> converges to the true
<span class="math">\(r\)</span>, and <span class="math">\(r_{m-1}\)</span> can be taken as an approximation to <span class="math">\(r\)</span>.
Run such experiments for different <span class="math">\(d\)</span> for the different <span class="math">\(f(x)\)</span> functions.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Pd_approx_error</span></code>.</p>
</div>
<div class="section" id="problem-18-approximate-a-step-function-by-finite-elements">
<span id="fem-approx-fe-exer-heaviside"></span><h2>Problem 18: Approximate a step function by finite elements<a class="headerlink" href="#problem-18-approximate-a-step-function-by-finite-elements" title="Permalink to this headline">¶</a></h2>
<p>Approximate the step function</p>
<div class="math">
\[\begin{split}f(x) = \left\lbrace\begin{array}{ll}
0 &amp; 0\leq x &lt; {1/2},\\
1 &amp; {1/2} \leq x \geq {1/2}
\end{array}\right.\end{split}\]</div>
<p>by 2, 4, and 8 P1 and P2 elements. Compare
approximations visually.</p>
<p><strong>Hint.</strong>
This <span class="math">\(f\)</span> can also be expressed in terms of the Heaviside function <span class="math">\(H(x)\)</span>:
<span class="math">\(f(x) = H(x-{1/2})\)</span>.
Therefore, <span class="math">\(f\)</span> can be defined by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Heaviside</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sym</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>making the <code class="docutils literal"><span class="pre">approximate</span></code> function in the
<code class="docutils literal"><span class="pre">fe_approx1D.py</span></code> module an obvious candidate to solve the
problem. However, <code class="docutils literal"><span class="pre">sympy</span></code> does not handle symbolic integration
with this particular integrand, and the <code class="docutils literal"><span class="pre">approximate</span></code> function faces a problem
when converting <code class="docutils literal"><span class="pre">f</span></code> to a Python function (for plotting) since
<code class="docutils literal"><span class="pre">Heaviside</span></code> is not an available function in <code class="docutils literal"><span class="pre">numpy</span></code>. It is better to make
special-purpose code for this case or perform all
calculations by hand.</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_Heaviside_P1P2</span></code>.</p>
</div>
<div class="section" id="exercise-19-2d-approximation-with-orthogonal-functions">
<span id="fem-approx-fe-exer-2dsines-symbolic"></span><h2>Exercise 19: 2D approximation with orthogonal functions<a class="headerlink" href="#exercise-19-2d-approximation-with-orthogonal-functions" title="Permalink to this headline">¶</a></h2>
<p>Assume we have basis functions <span class="math">\({\varphi}_i(x,y)\)</span> in 2D that are
orthogonal
such that <span class="math">\(({\varphi}_i,{\varphi}_j)=0\)</span> when <span class="math">\(i\neq j\)</span>.
The function <code class="docutils literal"><span class="pre">least_squares</span></code> in the
file <a class="reference external" href="http://tinyurl.com/nm5587k/approx/fe_approx2D.py">approx2D.py</a> will then spend much time on computing off-diagonal terms
in the coefficient matrix that we know are zero.
To speed up the computations, make a
version <code class="docutils literal"><span class="pre">least_squares_orth</span></code> that utilizes the orthogonality among the
basis functions. Apply the function to approximate</p>
<div class="math">
\[f(x,y) = x(1-x)y(1-y)e^{-x-y}\]</div>
<p>on <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> via basis functions</p>
<div class="math">
\[{\varphi}_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,\]</div>
<p>where <span class="math">\(p=0,\ldots,N_x\)</span> and <span class="math">\(q=0,\ldots,N_y\)</span>.</p>
<p><strong>Hint.</strong>
Get ideas from the function <code class="docutils literal"><span class="pre">least_squares_orth</span></code> in
the section <a class="reference internal" href="._main_approx003.html#fem-approx-global-orth"><span class="std std-ref">Orthogonal basis functions</span></a> and
file <a class="reference external" href="http://tinyurl.com/nm5587k/approx/fe_approx1D.py">approx1D.py</a>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">approx2D_ls_orth</span></code>.</p>
</div>
<div class="section" id="exercise-20-use-the-trapezoidal-rule-and-p1-elements">
<span id="fem-approx-fe-exer-1d-trapez"></span><h2>Exercise 20: Use the Trapezoidal rule and P1 elements<a class="headerlink" href="#exercise-20-use-the-trapezoidal-rule-and-p1-elements" title="Permalink to this headline">¶</a></h2>
<p>Consider approximation of some <span class="math">\(f(x)\)</span> on an interval <span class="math">\(\Omega\)</span> using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a class="reference internal" href="._main_approx008.html#eq-fem-approx-fe-numint1-trapez"><span class="std std-ref">(9.1)</span></a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form <span class="math">\(c_i=f(x_{i})\)</span> for <span class="math">\(i\in{\mathcal{I}_s}\)</span>.
Filename: <code class="docutils literal"><span class="pre">fe_P1_trapez</span></code>.</p>
</div>
<div class="section" id="exercise-21-compare-p1-elements-and-interpolation">
<span id="fem-approx-fe-exer-1d-p1-vs-interp"></span><h2>Exercise 21: Compare P1 elements and interpolation<a class="headerlink" href="#exercise-21-compare-p1-elements-and-interpolation" title="Permalink to this headline">¶</a></h2>
<p>We shall approximate the function</p>
<div class="math">
\[f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],\]</div>
<p>where <span class="math">\(n\in\mathbb{Z}\)</span> and <span class="math">\(\epsilon \geq 0\)</span>.</p>
<p><strong>a)</strong>
Plot <span class="math">\(f(x)\)</span> for <span class="math">\(n=1,2,3\)</span> and find the wave length of the function.</p>
<p><strong>b)</strong>
We want to use <span class="math">\(N_P\)</span> elements per wave length. Show that the number
of elements is then <span class="math">\(nN_P\)</span>.</p>
<p><strong>c)</strong>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an <span class="math">\(f\)</span> with just one wave length in <span class="math">\(\Omega = [0,1]\)</span>.
Set <span class="math">\(\epsilon = 0.5\)</span>.</p>
<p>Run the least squares or projection/Galerkin method for
<span class="math">\(N_P=2,4,8,16,32\)</span>. Compute the error <span class="math">\(E=||u-f||_{L^2}\)</span>.</p>
<p><strong>Hint.</strong>
Use the <code class="docutils literal"><span class="pre">fe_approx1D_numint</span></code> module to compute <span class="math">\(u\)</span> and use
the technique from the section <a class="reference internal" href="._main_approx007.html#fem-approx-fe-error"><span class="std std-ref">Computing the error of the approximation</span></a> to
compute the norm of the error.</p>
<p><strong>d)</strong>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute <span class="math">\(u(x)\)</span> (recall that <span class="math">\(c_i\)</span> is now simply <span class="math">\(f(x_{i})\)</span>).
Compute the error <span class="math">\(E=||u-f||_{L^2}\)</span>.
Which method seems to be most accurate?</p>
<p>Filename: <code class="docutils literal"><span class="pre">fe_P1_vs_interp</span></code>.</p>
</div>
<div class="section" id="exercise-22-implement-3d-computations-with-global-basis-functions">
<span id="fem-approx-fe-exer-3d-approx3d"></span><h2>Exercise 22: Implement 3D computations with global basis functions<a class="headerlink" href="#exercise-22-implement-3d-computations-with-global-basis-functions" title="Permalink to this headline">¶</a></h2>
<p>Extend the <a class="reference external" href="http://tinyurl.com/nm5587k/approx/approx2D.py">approx2D.py</a> code to 3D
applying ideas from the section <a class="reference internal" href="._main_approx009.html#fem-approx-3d-global"><span class="std std-ref">Extension to 3D</span></a>.
Use a 3D generalization of the test problem in the section <a class="reference internal" href="._main_approx009.html#fem-approx-2d-global-code"><span class="std std-ref">Implementation  (4)</span></a> to test the implementation.
Filename: <code class="docutils literal"><span class="pre">approx3D</span></code>.</p>
</div>
<div class="section" id="exercise-23-use-simpson-s-rule-and-p2-elements">
<span id="fem-approx-fe-exer-1d-simpson"></span><h2>Exercise 23: Use Simpson&#8217;s rule and P2 elements<a class="headerlink" href="#exercise-23-use-simpson-s-rule-and-p2-elements" title="Permalink to this headline">¶</a></h2>
<p>Redo <a class="reference internal" href="#fem-approx-fe-exer-1d-trapez"><span class="std std-ref">Exercise 20: Use the Trapezoidal rule and P1 elements</span></a>, but use P2
elements and Simpson&#8217;s rule based on sampling the integrands at
the nodes in the reference cell.
Filename: <code class="docutils literal"><span class="pre">fe_P2_simpson</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Exercises</a><ul>
<li><a class="reference internal" href="#problem-1-linear-algebra-refresher">Problem 1: Linear algebra refresher</a></li>
<li><a class="reference internal" href="#problem-2-approximate-a-three-dimensional-vector-in-a-plane">Problem 2: Approximate a three-dimensional vector in a plane</a></li>
<li><a class="reference internal" href="#problem-3-approximate-a-parabola-by-a-sine">Problem 3: Approximate a parabola by a sine</a></li>
<li><a class="reference internal" href="#problem-4-approximate-the-exponential-function-by-power-functions">Problem 4: Approximate the exponential function by power functions</a></li>
<li><a class="reference internal" href="#problem-5-approximate-the-sine-function-by-power-functions">Problem 5: Approximate the sine function by power functions</a></li>
<li><a class="reference internal" href="#problem-6-approximate-a-steep-function-by-sines">Problem 6: Approximate a steep function by sines</a><ul>
<li><a class="reference internal" href="#remarks-1">Remarks  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#problem-7-approximate-a-steep-function-by-sines-with-boundary-adjustment">Problem 7: Approximate a steep function by sines with boundary adjustment</a><ul>
<li><a class="reference internal" href="#remarks-2">Remarks  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-8-fourier-series-as-a-least-squares-approximation">Exercise 8: Fourier series as a least squares approximation</a></li>
<li><a class="reference internal" href="#problem-9-approximate-a-steep-function-by-lagrange-polynomials">Problem 9: Approximate a steep function by Lagrange polynomials</a></li>
<li><a class="reference internal" href="#problem-10-approximate-a-steep-function-by-lagrange-polynomials-and-regression">Problem 10: Approximate a steep function by Lagrange polynomials and regression</a></li>
<li><a class="reference internal" href="#problem-11-define-nodes-and-elements">Problem 11: Define nodes and elements</a></li>
<li><a class="reference internal" href="#problem-12-define-vertices-cells-and-dof-maps">Problem 12: Define vertices, cells, and dof maps</a></li>
<li><a class="reference internal" href="#problem-13-construct-matrix-sparsity-patterns">Problem 13: Construct matrix sparsity patterns</a></li>
<li><a class="reference internal" href="#problem-14-perform-symbolic-finite-element-computations">Problem 14: Perform symbolic finite element computations</a></li>
<li><a class="reference internal" href="#problem-15-approximate-a-steep-function-by-p1-and-p2-elements">Problem 15: Approximate a steep function by P1 and P2 elements</a></li>
<li><a class="reference internal" href="#problem-16-approximate-a-steep-function-by-p3-and-p4-elements">Problem 16: Approximate a steep function by P3 and P4 elements</a></li>
<li><a class="reference internal" href="#exercise-17-investigate-the-approximation-error-in-finite-elements">Exercise 17: Investigate the approximation error in finite elements</a></li>
<li><a class="reference internal" href="#problem-18-approximate-a-step-function-by-finite-elements">Problem 18: Approximate a step function by finite elements</a></li>
<li><a class="reference internal" href="#exercise-19-2d-approximation-with-orthogonal-functions">Exercise 19: 2D approximation with orthogonal functions</a></li>
<li><a class="reference internal" href="#exercise-20-use-the-trapezoidal-rule-and-p1-elements">Exercise 20: Use the Trapezoidal rule and P1 elements</a></li>
<li><a class="reference internal" href="#exercise-21-compare-p1-elements-and-interpolation">Exercise 21: Compare P1 elements and interpolation</a></li>
<li><a class="reference internal" href="#exercise-22-implement-3d-computations-with-global-basis-functions">Exercise 22: Implement 3D computations with global basis functions</a></li>
<li><a class="reference internal" href="#exercise-23-use-simpson-s-rule-and-p2-elements">Exercise 23: Use Simpson&#8217;s rule and P2 elements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_approx010.html"
                        title="previous chapter">Finite elements in 2D and 3D</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_approx012.html"
                        title="next chapter">Bibliography</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_approx011.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_approx012.html" title="Bibliography"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_approx010.html" title="Finite elements in 2D and 3D"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Approximation of functions</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>