<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,normal equations,$A^TA=A^Tb$ (normal equations),Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec23'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec24'),
              ('Implementation', 3, None, '___sec25'),
              ('Example', 3, None, '___sec26'),
              ('Remark', 3, None, '___sec27'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec29'),
              ('Successful example', 3, None, '___sec30'),
              ('Less successful example', 3, None, '___sec31'),
              ('Remedy for strong oscillations', 3, None, '___sec32'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec35'),
              ('The basis functions', 2, None, '___sec36'),
              ('Construction principles', 3, None, '___sec37'),
              ('Properties of $\\basphi_i$', 3, None, '___sec38'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec39'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec40'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec41'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec43'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec44'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec46'),
              ('Assembly of element matrices', 3, None, '___sec47'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec48'),
              ('The element vector', 3, None, '___sec49'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec51'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec52'),
              ('Formulas for local basis functions', 3, None, '___sec53'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fdm',
               'fem:deq:1D:approx:fem_vs_fdm'),
              ('Computations in physical space', 3, None, '___sec68'),
              ('Elementwise computations', 3, None, '___sec69'),
              ('Terminology', 3, None, '___sec70'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec77'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec79'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec82'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec85'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec86'),
              ('Element matrices and vectors', 3, None, '___sec87'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec88'),
              ('Affine mapping of the reference cell', 2, None, '___sec89'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec90'),
              ('Computing integrals', 2, None, '___sec91'),
              ('Exercises', 1, None, '___sec92'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec99'),
              ('Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec101'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec118')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="approx-sol.html">Approximation of functions</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#fem:approx:vec" style="font-size: 80%;">Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global" style="font-size: 80%;">Approximation of functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe" style="font-size: 80%;">Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:approx:fe:fd" style="font-size: 80%;">Comparison of finite element and finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol007.html#fem:approx:fe:element" style="font-size: 80%;">A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol008.html#___sec77" style="font-size: 80%;">Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:2D" style="font-size: 80%;">Approximation of functions in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec85" style="font-size: 80%;">Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol012.html#___sec118" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0011"></a>
<!-- !split -->

<h1 id="___sec92">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg1">Problem 1: Linear algebra refresher</h2>

<p>
Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.

<p>
<b>a)</b>
Prove that vectors in the plane \( (a,b) \) form a vector space
by showing that all the axioms of a vector space are satisfied.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

<p>
The axioms of a vector space go as follows (see
<a href="https://en.wikipedia.org/wiki/Vector_space" target="_self">Wikipedia</a>, but
we use slightly different notation below):

<ol>
 <li> The sum of \( u \) and \( v \), denoted by \( u + v \), is in V.</li>
 <li> \( u + v = v + u \).</li>
 <li> \( (u + v) + w = u + (v + w) \).</li>
 <li> There is a <em>zero</em> vector \( 0 \) in V such that \( u + 0 = u \).</li>
 <li> For each \( u \) in V, there is a vector \( -u \) in V such that \( u + (-u) = 0 \).</li>
 <li> The scalar multiple of \( u \) by \( \gamma \), denoted by \( \gamma u \), is in V.</li>
 <li> \( \gamma (u + v) = \gamma u + \gamma v \).</li>
 <li> \( (\gamma + \delta)u = \gamma u + \delta u \) for scalar \( \gamma \) and \( \delta \).</li>
 <li> \( \gamma(\delta u) = \gamma\delta u \).</li>
<li> \( 1u = u \).</li>
</ol>

We must show that each axiom is fulfilled by planar vectors and their
mathematical rules. Let \( u=(a,b) \) and \( v=(c,d) \).

<p>
Axiom 1:

$$ u+v = (a,b)+(c,d)=(a+c, b+d),$$

is a planar vector and therefore in \( V \).

<p>
Axiom 2:

$$ u+v = (a,b)+(c,d)=(a+c, b+d) = (c+a, d+b) = v + u\tp$$

<p>
Axiom 3:

$$ (u+v) + w = ((a,b) + (c,d)) + (e,f) = (a,b) + ((c,d) + (e,f)) = u + (v+w)\tp$$

<p>
Axiom 4: The \( (0,0) \) vector is the 0 element,

$$ u + 0 = (a,b) + (0,0) = (a+0, b+0) = (a,b) = u\tp$$

<p>
Axiom 5: Let \( -u \) element is \( (-a,-b) \), so

$$ u + (-u) = (a,b) + (-a,-b) = (0,0) = 0\tp$$

<p>
Axiom 6:

$$ \gamma u = \gamma\cdot(a,b)= (\gamma a, \gamma b),$$

is also a planar vector and therefore in \( V \).

<p>
Axiom 7:

$$ \gamma (u + v) = \gamma \cdot((a,b) + (c,d) = \gamma (a,b) + \gamma (c,d)\tp$$

<p>
Axiom 8:

$$ (\gamma + \delta)u = (\gamma + \delta)(a,b) = \gamma (a,b) + \delta (a,b) = \gamma u + \delta u\tp$$

<p>
Axiom 9:

$$ \gamma (\delta u) = \gamma (\delta\cdot (a,b)) = \gamma (\delta a, \delta b) = (\gamma\delta a, \gamma\delta b) = \gamma\delta u\tp$$

<p>
Axiom 10:

$$ 1u = 1(a,b) = (1\cdot a, 1\cdot b) = (a,b) = u\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Prove that all linear functions of the form \( ax+b \) constitute a vector space,
\( a,b\in\Real \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_2">

<p>
Let \( u=ax+b \) and \( v=cx+d \). We verify each axiom.

<p>
Axiom 1:

$$ u+v = ax + b + cx + d = (a+c)x + (b + d),$$

is also a linear function and therefore in \( V \).

<p>
Axiom 2:

$$ u+v = ax+b + cx+ d = cx+d + ax+ b = v + u\tp$$

<p>
Axiom 3:

$$ (u+v) + w = (ax+b + cx+ d) + ex + f = ax+b + cx+ d + ex + f
ax+b + (cx+ d + ex + f) = u + (v+w)\tp$$

<p>
Axiom 4: The \( 0x+0=0 \) function is the 0 element,

$$ u + 0 = ax + b + 0 = ax + b = u\tp$$

<p>
Axiom 5: Let \( -u \) element is \( -ax-b \), so

$$ u + (-u) = ax + b + (-ax - b) = 0\tp$$

<p>
Axiom 6:

$$ \gamma u = \gamma(ax +b)= \gamma ax + \gamma b,$$

is also a linear function and therefore in \( V \).

<p>
Axiom 7:

$$ \gamma (u + v) = \gamma (ax+b + cx+ d) = \gamma ax + \gamma b + \gamma cx + \gamma d = \gamma(ax + b) + \gamma(cd + d) = \gamma u + \gamma v\tp$$

<p>
Axiom 8:

$$ (\gamma + \delta)u = (\gamma + \delta)(ax + b) = \gamma (ax+b) + \delta (ax+b) = \gamma u + \delta u\tp$$

<p>
Axiom 9:

$$ \gamma (\delta u) = \gamma (\delta(ax+b))) = \gamma\delta u\tp$$

<p>
Axiom 10:

$$ 1u = 1(ax+b) = ax+b = u\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Show that all quadratic functions of the form \( 1 + ax^2 + bx \) <em>do not</em>
constitute a vector space.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_3">

<p>
Let \( u=ax^2+bx + 1 \) and \( v=cx^2 + dx + 1 \). We try to verify each axiom.

<p>
Axiom 1:

$$ u+v = ax^2 + bx + 1 + cx^2 + dx + 1 = (a+c)x^2 + (b+d)x + 2,$$

but this quadratic function is not in \( V \) because the constant term is 2
and not 1. Consequently, quadratic functions of the particular
form \( 1 + ax^2 + bx \) do not constitute a vector space.
The more general form  \( ax^2 + bx +c \) for arbitrary constants \( a \), \( b \), and
\( c \) makes functions that span a function space.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
Check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form \( ax+b \), \( a,b\in\Real \),
defined on some interval \( \Omega=[A,B] \).
Show that this particular inner product satisfies the
general requirements of an inner product in a vector space.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_4">

<p>
According to <a href="https://en.wikipedia.org/wiki/Inner_product_space" target="_self">Wikipedia</a>,
an inner product space, with an inner product \( (u,v) \), has three axioms
(we drop the possibility of complex numbers and assume everything is real):

<ol>
<li> Symmetry: \( (u,v) \) = \( (v,u) \)</li>
<li> Linearity in the first argument: \( \gamma u, v) = \gamma (u,v) \)</li>
<li> Positive-definiteness: \( (u,u)\geq 0 \) and \( (u,u)=0 \) implies \( u=0 \)</li>
</ol>

A possible inner product for linear functions on a domain \( \Omega \) is

$$ (u,v) = \int_A^B uv\dx = \int_A^B (ax+b)(cx+d)\dx\tp$$

Symmetry is obvious since \( uv=vu \):

$$ (u,v) = \int_A^B uv\dx = \int_A^B vu d = (v,u)\tp$$

Linearity in the first argument:

$$  (\gamma u,v) = \gamma\int_A^B(\gamma u)v\dx = \gamma\int_A^B uv\dx = \gamma (u,v)\tp$$

Positive-definiteness:

$$ (u,u) = \int_A^B(ax+b)^2\dx\geq 0,$$

since the integral of a function \( f(x)\geq \) must be greater than or equal to
zero, and in particular,

$$ (u,u)=0\quad\Rightarrow\quad \int_A^B(ax+b)^2\dx = 0,$$

implies \( ax+b=0 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>linalg1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:vec:3Dby2D">Problem 2: Approximate a three-dimensional vector in a plane</h2>

<p>
Given \( \f = (1,1,1) \) in \( \Real^3 \), find the best approximation vector
\( \u \) in the plane spanned by the unit vectors \( (1,0) \) and \( (0,1) \).
Repeat the calculations using the vectors \( (2,1) \) and \( (1,2) \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
We have the vector \( \pmb{f} = (1,1,1) \).
Our aim is to approximate this with a vector in the vector-space spanned by the unit vectors \( \pmb{\phi_0} \) and \( \pmb{\phi_1} \). We seek a solution \( u = c_0 \phi_0 + c_1 \phi_1 \). To do this we use the least-square-method and solve the equation \( \pmb{A c} = \pmb{b} \). Or written out:

$$
\left[\begin{array}{cc}
A_{0,0} & A_{0,1} \\A_{1,0} & A_{1,1}
\end{array}\right]
\left[ \begin{array}{c} c_0 \\ c_1 \end{array} \right]
=
\left[ \begin{array}{c} b_0 \\ b_1 \end{array} \right]
$$

where \( A_{i,j} = ( \pmb{\phi_i}, \pmb{\phi_j} ) \) and \( b_i = ( \pmb{\phi_i}, \pmb{f} ) \).

<p>
We start with \( \pmb{\phi_0} = (0,1) \), \( \pmb{\phi_1} = (1,0) \).
Calculations give

$$
\begin{align*}
A_{0,0} &= ([1,0],[1,0]) = 1,\\ 
A_{0,1} &= ([1,0],[0,1]) = 0,
A_{1,0} &= ([0,1],[1,0]) = 0,
A_{1,1} &= ([0,1],[0,1]) = 1,
b_0 &= ([1,0],[1,1,1]) = 1,
b_0 &= ([0,1],[1,1,1]) = 1.
\end{align*}
$$

The result becomes $ c_0 = c_1 =1$, and hence

$$ u = 1\cdot\pmb{\phi_0}  + 1\cdot\pmb{\phi_1}.$$

<p>
Then we proceed with
\( \pmb{\phi_0} = (2,1) \), \( \pmb{\phi_1} = (1,2) \).
Calculations give

$$
\begin{align*}
A_{0,0} &= ([2,1],[2,1]) = 2\cdot 2 + 1\cdot 1 = 5,
A_{0,1} &= ([2,1],[1,2]) = 2\cdot 1 + 1\cdot 2 = 4,
A_{1,0} &= ([1,2],[2,1]) = 1\cdot 2 + 2\cdot 1 = 4,
A_{1,1} &= ([1,2],[1,2]) = 1\cdot 1 + 2\cdot 2 = 5,
b_0 &= ([2,1],[1,1,1]) = 2\cdot 1 + 1\cdot 1 = 3,
b_0 &= ([1,2],[1,1,1]) = 1\cdot 1 + 2\cdot 1 = 3.
\end{align*}
$$

Solving for the \( c_i \) values results in $ c_0 = c_1 =\frac{1}{3}$ and
hence

$$ u = \frac{1}{3}\cdot \pmb{\phi_0}  + \frac{1}{3}\cdot \pmb{\phi_1} .$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>vec111_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:parabola_sine">Problem 3: Approximate a parabola by a sine</h2>

<p>
Given the function \( f(x)=1 + 2x(1-x) \) on \( \Omega=[0,1] \), we want to
find an approximation in the function space

$$ V = \hbox{span}\{1, \sin(\pi x)\}\tp$$

<p>
<b>a)</b>
Sketch or plot \( f(x) \). Think intuitively how an expansion in terms
of the basis functions of \( V \), \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=\sin(\pi x) \),
can be construction to yield a best approximation to \( f \). Or
phrased differently, see if you can guess the coefficients \( c_0 \) and \( c_1 \)
in the expansion

$$ u(x) = c_0\baspsi_0 + c_1\baspsi_1 = c_0 + c_1\sin (\pi x)\tp$$

Compute the \( L^2 \) error \( ||f-u||_{L^2}=(\int_0^1(f-u)^2\dx)^{1/2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_1">

<p>
If you make a mesh function <code>e</code> of the error
on some mesh with uniformly spaced coordinates in
the array <code>xc</code>, the integral can be approximated as <code>np.sqrt(dx*np.sum(e**2))</code>,
where <code>dx=xc[0]-xc[1]</code> is the mesh spacing and <code>np</code> is an alias for the
<code>numpy</code> module in Python.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_2">

<p>
The function \( \baspsi_0=1 \) can be used to &quot;take care of&quot; of the
constant 1 in \( f \), while \( \baspsi_1=\sin(\pi x) \) can approximate
the parabola. The maximum of \( f \) is 3/2, so we should use
\( u(x) = 1\cdot\baspsi_0 + \frac{1}{2}\baspsi_1 \).

<p>
Plotting and the computation of the \( L^2 \) error can be done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

xc <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">101</span>)  <span style="color: #408080; font-style: italic"># x coordinates for plotting</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x&#39;</span>)
psi_0 <span style="color: #666666">=</span> <span style="color: #666666">1</span>
psi_1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)

half <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>)
u <span style="color: #666666">=</span> <span style="color: #666666">1*</span>psi_0 <span style="color: #666666">+</span> half<span style="color: #666666">*</span>psi_1

<span style="color: #408080; font-style: italic"># How to combine c_0*psi_0 + c_1*psi_1 to match f?</span>
<span style="color: #408080; font-style: italic"># Intuitively, c_0=c_1=1...</span>
<span style="color: #408080; font-style: italic"># Turn u to function so we can plot and compute with it</span>
u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], u, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;L2 error of intuitive approximation:&#39;</span>,
e <span style="color: #666666">=</span> f(xc) <span style="color: #666666">-</span> u(xc)
dx <span style="color: #666666">=</span> xc[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> xc[<span style="color: #666666">0</span>]
<span style="color: #008000; font-weight: bold">print</span> np<span style="color: #666666">.</span>sqrt(dx<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(e<span style="color: #666666">**2</span>))

plt<span style="color: #666666">.</span>plot(xc, f(xc), <span style="color: #BA2121">&#39;r--&#39;</span>)
plt<span style="color: #666666">.</span>plot(xc, u(xc), <span style="color: #BA2121">&#39;b-&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;exact&#39;</span>, <span style="color: #BA2121">&#39;intuitive approximation&#39;</span>])
</pre></div>
<p>
The \( L^2 \) error becomes \( 0.0179 \).

<p>
<center><p><img src="fig-approx/parabola_sin_a.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Perform the hand calculations for a least squares approximation.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_3">

<p>
The least squares method ends up with a linear system where the
coefficient matrix has entries \( A_{i,j}=\int_0^1\baspsi_i\baspsi_j\dx \)
and the right-hand side has entries \( b_i=\int_0^1\baspsi_i\dx \).
We can use <code>sympy</code> do carry out the integrals:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Do the calculations in the least squares or project method</span>
A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>, <span style="color: #666666">2</span>))
b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((<span style="color: #666666">2</span>, <span style="color: #666666">1</span>))
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi_0<span style="color: #666666">*</span>psi_0, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi_0<span style="color: #666666">*</span>psi_1, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
A[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
A[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi_1<span style="color: #666666">*</span>psi_1, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(f(x)<span style="color: #666666">*</span>psi_0, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
b[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(f(x)<span style="color: #666666">*</span>psi_1, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;A:&#39;</span>, A
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;b:&#39;</span>, b
c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
c <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(c[i,<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;c:&#39;</span>, c, [c_<span style="color: #666666">.</span>evalf() <span style="color: #008000; font-weight: bold">for</span> c_ <span style="color: #AA22FF; font-weight: bold">in</span> c]
u <span style="color: #666666">=</span> c[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi_0 <span style="color: #666666">+</span> c[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>psi_1
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;u:&#39;</span>, u
</pre></div>
<p>
Looking at the results, we get the linear system

$$
\left(\begin{matrix}1 & \frac{2}{\pi}\\\frac{2}{\pi} & \frac{1}{2}\end{matrix}\right)
\left(\begin{bmatrix}
\frac{- 24 \pi^{2} - 96 + 4 \pi^{4}}{3 \pi^{2} \left(-8 + \pi^{2}\right)}\\ 
\frac{- 4 \pi^{2} + 48}{3 \pi \left(-8 + \pi^{2}\right)}
\end{bmatrix}\right) =
\left(\begin{matrix}
\frac{4}{3}\\ 
\frac{8}{\pi^{3}} + \frac{2}{\pi}
\end{matrix}\right)
$$

The resulting best approximation reads

$$ u(x) = \frac{4 \left(- \pi^{2} + 12\right) \sin{\left (\pi x \right )}}{3 \pi \left(-8 + \pi^{2}\right)} + \frac{- 24 \pi^{2} - 96 + 4 \pi^{4}}{3 \pi^{2} \left(-8 + \pi^{2}\right)}\approx 1.025 + 0.484\sin(\pi x)$$

The \( L^2 \) error turns out to be \( 0.00876 \).
To conclude, the least squares method is slightly better than the intuition
in this case.

<p>
<center><p><img src="fig-approx/parabola_sin_b.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>parabola_sin</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:exp:powers">Problem 4: Approximate the exponential function by power functions</h2>

<p>
Let \( V \) be a function space with basis functions \( x^i \),
\( i=0,1,\ldots,N \).  Find the best approximation to \( f(x)=\exp(-x) \) on
\( \Omega =[0,8] \) among all functions in \( V \) for \( N=2,4,6 \). Illustrate
the three approximations in three separate plots.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
Apply the <code>lest_squares</code> and
<code>comparison_plot</code> functions in the <code>approx1D.py</code> module as these
make the exercise easier to solve.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_2">

<p>
A suitable code is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> least_squares, comparison_plot
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> factorial
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x)

Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">8</span>]

<span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">2</span>,<span style="color: #666666">4</span>,<span style="color: #666666">6</span>:
    psi <span style="color: #666666">=</span> [x<span style="color: #666666">**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    u, c <span style="color: #666666">=</span> least_squares(f,psi,Omega)
    <span style="color: #008000; font-weight: bold">print</span> N, u
    plt<span style="color: #666666">.</span>figure()
    comparison_plot(f, u, Omega, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_exp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> N,
                    plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> N)
</pre></div>
<p>
For the case \( N=2 \) the program prints the following, here edited for clearer
reading:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A:
Matrix([[8, 32, 512/3], [32, 512/3, 1024], [512/3, 1024, 32768/5]])
b:
Matrix([[-exp(-8) + 1], [-9*exp(-8) + 1], [-82*exp(-8) + 2]])

f: exp(-x)
u: x**2*(-465*exp(-8)/4096 + 105/4096) + x*(-141/512 +
   405*exp(-8)/512) - 111*exp(-8)/128 + 87/128
</pre></div>
<p>
<center><p><img src="fig-approx/exp_powers_N2.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>exp_powers</code>.

<p>
<!-- Taylor: these polynomials go so far off on [0,8] that it is not a -->
<!-- good idea to add them. -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:sin:powers">Problem 5: Approximate the sine function by power functions</h2>

<p>
In this exercise we want to approximate the sine function by polynomials
of order \( N+1 \). Consider two bases:

$$
\begin{align*}
V_1 &= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\ 
V_2 &= \{1,x,x^2,x^3,\ldots, x^N\}\tp
\end{align*}
$$

The basis \( V_1 \) is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while \( V_2 \)
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.

<p>
Compute the best approximation to \( f(x)=\sin(x) \) among all functions
in \( V_1 \) and \( V_2 \) on two domains of increasing sizes: \( \Omega_{1,k} =
[0, k\pi] \), \( k=2,3\ldots,6 \) and \( \Omega_{2,k} = [-k\pi /2, k\pi/2] \),
\( k=2,3,4,5 \).  Make plots for all combinations of \( V_1 \), \( V_2 \),
\( \Omega_1 \), \( \Omega_2 \), \( k=2,3,\ldots,6 \).

<p>
Add a plot of the \( N \)-th degree Taylor polynomial approximation of
\( \sin(x) \) around \( x=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
You can make a loop over \( V_1 \) and \( V_2 \), a loop over
\( \Omega_1 \) and \( \Omega_2 \), and a loop over \( k \). Inside the loops,
call the functions <code>least_squares</code> and
<code>comparison_plot</code> from the <code>approx1D</code> module.
\( N=7 \) is a suggested value.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_2">

<p>
Suitable code is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> least_squares, comparison_plot
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin(x)
N <span style="color: #666666">=</span> <span style="color: #666666">7</span>
psi_bases <span style="color: #666666">=</span> [[x<span style="color: #666666">**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, N<span style="color: #666666">+1</span>, <span style="color: #666666">2</span>)],  <span style="color: #408080; font-style: italic"># V_1</span>
             [x<span style="color: #666666">**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, N<span style="color: #666666">+1</span>)]]     <span style="color: #408080; font-style: italic"># V_2</span>
symbolic <span style="color: #666666">=</span> <span style="color: #008000">False</span>

<span style="color: #008000; font-weight: bold">for</span> V, psi <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(psi_bases):
    <span style="color: #008000; font-weight: bold">for</span> domain_no <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">3</span>):
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>):
            <span style="color: #008000; font-weight: bold">if</span> symbolic:
                Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, k<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi] <span style="color: #008000; font-weight: bold">if</span> domain_no <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
                        [<span style="color: #666666">-</span>k<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>, k<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>]
            <span style="color: #008000; font-weight: bold">else</span>:
                <span style="color: #408080; font-style: italic"># cannot use sym.pi with numerical sympy computing</span>
                Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, k<span style="color: #666666">*</span>pi] <span style="color: #008000; font-weight: bold">if</span> domain_no <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> \ 
                        [<span style="color: #666666">-</span>k<span style="color: #666666">*</span>pi<span style="color: #666666">/2</span>, k<span style="color: #666666">*</span>pi<span style="color: #666666">/2</span>]

            u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega, symbolic<span style="color: #666666">=</span>symbolic)

            comparison_plot(
                f, u, Omega,
                ymin<span style="color: #666666">=-2</span>, ymax<span style="color: #666666">=2</span>,
                filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_N</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_V</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">Omega</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">k</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                (N, V, k, domain_no),
                plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sin(x) on [0,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">*pi/2] by </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>
                (k, <span style="color: #BA2121">&#39;,&#39;</span><span style="color: #666666">.</span>join([<span style="color: #008000">str</span>(p) <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> psi])))
            <span style="color: #408080; font-style: italic"># Need to kill the plot to proceed!</span>
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;png&#39;</span>, <span style="color: #BA2121">&#39;pdf&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images -2 &#39;</span> <span style="color: #666666">+</span> \ 
                  <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39;tmp_N</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_V</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">Omega</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">k</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.&#39;</span> <span style="color: #666666">%</span>
                            (N, V, k, domain_no) <span style="color: #666666">+</span> ext
                            <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>)]) <span style="color: #666666">+</span> \ 
                  <span style="color: #BA2121">&#39; sin_powers_N</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_V</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_Omega</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.&#39;</span> <span style="color: #666666">%</span> (N, V, domain_no) <span style="color: #666666">+</span> ext
            <span style="color: #008000; font-weight: bold">print</span> cmd
            os<span style="color: #666666">.</span>system(cmd)

<span style="color: #408080; font-style: italic"># Show the standard Taylor series approximation</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> factorial, pi
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">12*</span>pi<span style="color: #666666">/2.</span>]
u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,N<span style="color: #666666">+1</span>):
    u <span style="color: #666666">=</span> u <span style="color: #666666">+</span> ((<span style="color: #666666">-1</span>)<span style="color: #666666">**</span>k<span style="color: #666666">*</span>x<span style="color: #666666">**</span>(<span style="color: #666666">1+2*</span>k))<span style="color: #666666">/</span><span style="color: #008000">float</span>(factorial(<span style="color: #666666">1+2*</span>k))
<span style="color: #408080; font-style: italic"># Shorter: u = sum(((-1)**k*x**(1+2*k))/float(factorial(1+2*k))</span>
<span style="color: #408080; font-style: italic"># for k in range(0,10))</span>
comparison_plot(f, u, Omega, <span style="color: #BA2121">&#39;sin_taylor</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> k,
                ymin<span style="color: #666666">=-1.5</span>, ymax<span style="color: #666666">=1.5</span>)
</pre></div>
<p>
The odd powers (\( V_1 \) space) behave not so good on \( \Omega_{1,k} \),
but better on \( \Omega_{2,k} \):

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 48:  \( V_1 \) space, \( \Omega_{1,k} \) domain. </p></center>
<p><img src="fig-approx/sin_powers_N7_V1_Omega1.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 49:  \( V_1 \) space, \( \Omega_{2,k} \) domain. </p></center>
<p><img src="fig-approx/sin_powers_N7_V1_Omega2.png" align="bottom" width=800></p>
</center>

<p>
Including also even powers (\( V_2 \) space) is clearly much better:

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 50:  \( V_2 \) space, \( \Omega_{1,k} \) domain. </p></center>
<p><img src="fig-approx/sin_powers_N7_V2_Omega1.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 51:  \( V_2 \) space, \( \Omega_{2,k} \) domain. </p></center>
<p><img src="fig-approx/sin_powers_N7_V2_Omega2.png" align="bottom" width=800></p>
</center>

<p>
Comparison with a standard Taylor series shows that it is very inferior
as an approximation over the entire domain, but much more accurate
close to the origin (as expected, since the Taylor series is constructed
with this property, while the least squares method tries to find a good
approximation over the entire domain).

<p>
<center><p><img src="fig-approx/sin_taylor7.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>sin_powers</code>.

<p>
<!-- Solveig explanations based on f-B approx -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</h2>

<p>
Find the best approximation of \( f(x) = \tanh (s(x-\pi)) \) on
\( [0, 2\pi] \) in the space \( V \) with basis
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
Make a movie showing how \( u=\sum_{j\in\If}c_j\baspsi_j(x) \)
approximates \( f(x) \) as \( N \) grows. Choose \( s \) such that \( f \) is
steep (\( s=20 \) is appropriate).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_1">

<p>
One may naively call the <code>least_squares_orth</code> and <code>comparison_plot</code>
from the <code>approx1D</code> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <code>least_squares_orth</code>
compute with only one basis function at a time and accumulate
the corresponding <code>u</code> in the total solution.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_2">

<p>
<code>ffmpeg</code> or <code>avconv</code> may skip frames when plot files are combined to
a movie. Since there are few files and we want to see each of them,
use <code>convert</code> to make an animated GIF file (<code>-delay 200</code> is
suitable).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_3">

<p>
The code may read

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> least_squares_orth, comparison_plot
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

<span style="color: #408080; font-style: italic"># Naive approach: (not utilizing the fact that i+1 computations can</span>
<span style="color: #408080; font-style: italic"># make use of i computations)</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">naive</span>(f, s, Omega, N<span style="color: #666666">=10</span>):
    psi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        psi<span style="color: #666666">.</span>append(sym<span style="color: #666666">.</span>sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x))
        u, c <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        comparison_plot(f, u, Omega, <span style="color: #BA2121">&#39;tmp_sin</span><span style="color: #BB6688; font-weight: bold">%02d</span><span style="color: #BA2121">x&#39;</span> <span style="color: #666666">%</span> i,
                        legend_loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>, show<span style="color: #666666">=</span><span style="color: #008000">True</span>)

<span style="color: #408080; font-style: italic"># Efficient approach: compute just the matrix diagonal</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">efficient</span>(f, s, Omega, N<span style="color: #666666">=10</span>):
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)]
        next_term, c <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega, <span style="color: #008000">False</span>)
        u <span style="color: #666666">=</span> u <span style="color: #666666">+</span> next_term
        comparison_plot(f, u, Omega, <span style="color: #BA2121">&#39;tmp_sin</span><span style="color: #BB6688; font-weight: bold">%02d</span><span style="color: #BA2121">x&#39;</span> <span style="color: #666666">%</span> i,
                        legend_loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>, show<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                        plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, i=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (s, i))

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    s <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># steepness</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>tanh(s<span style="color: #666666">*</span>(x<span style="color: #666666">-</span>sym<span style="color: #666666">.</span>pi))
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi
    Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">2*</span>pi]  <span style="color: #408080; font-style: italic"># sym.pi did not work here</span>
    efficient(f, s, Omega, N<span style="color: #666666">=10</span>)
    <span style="color: #408080; font-style: italic"># Make movie</span>
    <span style="color: #408080; font-style: italic"># avconv/ffmpeg skips frames, use convert instead (few files)</span>
    cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;convert -delay 200 tmp_sin*.png tanh_sines_approx.gif&#39;</span>
    os<span style="color: #666666">.</span>system(cmd)
    <span style="color: #408080; font-style: italic"># Make static plots, 3 figures on 2 lines</span>
    <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;pdf&#39;</span>, <span style="color: #BA2121">&#39;png&#39;</span>:
        cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> -3 &#39;</span> <span style="color: #666666">%</span> ext
        cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tmp_sin00x tmp_sin01x tmp_sin02x tmp_sin04x &#39;</span>
        cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tmp_sin07x tmp_sin10x tanh_sines_approx&#39;</span>
        os<span style="color: #666666">.</span>system(cmd)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center><p><img src="mov-approx/tanh_sines.gif" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>tanh_sines</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec99">Remarks </h3>

<p>
Approximation of a discontinuous (or steep) \( f(x) \) by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in \( f \).
This is known as the <a href="http://en.wikipedia.org/wiki/Gibbs_phenomenon" target="_self">Gibb's phenomenon</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine3">Problem 7: Approximate a steep function by sines with boundary adjustment</h2>

<p>
We study the same approximation problem as in
<a href="#fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</a>. Since \( \baspsi_i(0)=\baspsi_i(2\pi)=0 \)
for all \( i \), \( u=0 \) at the boundary points \( x=0 \) and \( x=2\pi \), while
\( f(0)=-1 \) and \( f(2\pi)=1 \). This discrepancy at the boundary can be
removed by adding a boundary function \( B(x) \):

$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
$$

where \( B(x) \) has the right boundary values: \( B(x_L)=f(x_L) \) and
\( B(x_R)=f(x_R) \), with \( x_L=0 \) and \( x_R=2\pi \) as the boundary points.
A linear choice of \( B(x) \) is

$$ B(x) = \frac{(x_R-x)f(x_L) + (x-x_L)f(x_R)}{x_R-x_L}\tp$$

<p>
<b>a)</b>
Use the basis
\( \baspsi_i(x) = \sin((i+1)x) \), \( i\in\If = \{0,\ldots,N\} \)
and plot \( u \) and \( f \) for \( N=16 \). (It suffices to make plots for even \( i \).)

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_1">

<p>
With a boundary term \( B(x) \) we call <code>least_squares_orth</code> with
<code>f-B</code> as right-hand side function, and we must remember to add \( B \) to \( u \).

<p>
We can extend the code from <a href="#fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</a> and
let the function <code>efficient</code> handle different choices of basis.
Appropriate code for all three subexercises is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> least_squares_orth, comparison_plot
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">tanh_sines_approx</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">efficient</span>(f, B, s, Omega, N<span style="color: #666666">=10</span>, basis<span style="color: #666666">=</span><span style="color: #BA2121">&#39;a&#39;</span>):
    u <span style="color: #666666">=</span> B
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">if</span> basis <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;a&#39;</span>:
            psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)]
        <span style="color: #008000; font-weight: bold">elif</span> basis <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;b&#39;</span>:
            psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)]
        <span style="color: #008000; font-weight: bold">elif</span> basis <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;c&#39;</span>:
            psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>sin(<span style="color: #666666">2*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)]
        next_term, c <span style="color: #666666">=</span> least_squares_orth(f<span style="color: #666666">-</span>B, psi, Omega, <span style="color: #008000">False</span>)
        u <span style="color: #666666">=</span> u <span style="color: #666666">+</span> next_term
        <span style="color: #408080; font-style: italic"># Make only plot for i even</span>
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            comparison_plot(f, u, Omega, <span style="color: #BA2121">&#39;tmp_sin</span><span style="color: #BB6688; font-weight: bold">%02d</span><span style="color: #BA2121">x&#39;</span> <span style="color: #666666">%</span> i,
                            legend_loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>, show<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                            plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, i=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (s, i))


<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    s <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># steepness</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>tanh(s<span style="color: #666666">*</span>(x<span style="color: #666666">-</span>sym<span style="color: #666666">.</span>pi))
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi
    Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">2*</span>pi]  <span style="color: #408080; font-style: italic"># sym.pi did not work here</span>

    <span style="color: #408080; font-style: italic"># sin((i+1)*x) basis</span>
    xL <span style="color: #666666">=</span> Omega[<span style="color: #666666">0</span>]
    xR <span style="color: #666666">=</span> Omega[<span style="color: #666666">1</span>]
    B <span style="color: #666666">=</span> ((xR<span style="color: #666666">-</span>x)<span style="color: #666666">*</span>f<span style="color: #666666">.</span>subs(x, xL) <span style="color: #666666">+</span> (x<span style="color: #666666">-</span>xL)<span style="color: #666666">*</span>f<span style="color: #666666">.</span>subs(x, xR))<span style="color: #666666">/</span>(xR<span style="color: #666666">-</span>xL)
    <span style="color: #008000; font-weight: bold">for</span> exercise <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;a&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>:
        efficient(f, B, s, Omega, N<span style="color: #666666">=16</span>, basis<span style="color: #666666">=</span>exercise)
        <span style="color: #408080; font-style: italic"># Make movie</span>
        cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;convert -delay 200 tmp_sin*.png &#39;</span>
        cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tanh_sines_boundary_term_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">.gif&#39;</span> <span style="color: #666666">%</span> exercise
        os<span style="color: #666666">.</span>system(cmd)
        <span style="color: #408080; font-style: italic"># Make static plots, 3 figures on 2 lines</span>
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;pdf&#39;</span>, <span style="color: #BA2121">&#39;png&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> -3 &#39;</span> <span style="color: #666666">%</span> ext
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tmp_sin00x tmp_sin02x tmp_sin04x tmp_sin08x &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tmp_sin12x tmp_sin16x &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;tanh_sines_boundary_term_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> exercise
            os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
<center><p><img src="fig-approx/tanh_sines_boundary_term_a.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Use the basis from <a href="#fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</a>,
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
(It suffices to make plots for even \( i \).)
Observe that the approximation converges to a piecewise
linear function!

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_2">

<p>
<center><p><img src="mov-approx/tanh_sines_boundary_term_b.gif" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Use the basis
\( \baspsi_i(x) = \sin(2(i+1)x) \), \( i\in\If = \{0,\ldots,N\} \),
and observe that the approximation converges to a piecewise
constant function.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_3">

<p>
<center><p><img src="mov-approx/tanh_sines_boundary_term_c.gif" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>tanh_sines_boundary_term</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec101">Remarks </h3>

<p>
The strange results in b) and c) are due to the choice of
basis. In b), \( \basphi_i(x) \) is an odd function around
\( x=\pi/2 \) and \( x=3\pi/2 \). No combination of basis functions
is able to approximate the flat regions of \( f \).
All basis functions in c) are even around \( x=\pi/2 \) and \( x=3\pi/2 \),
but odd at \( x=0,\pi,2\pi \). With all the sines represented, as in a),
the approximation is not constrained with a particular symmetry
behavior.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</h2>

<p>
<b>a)</b>
Given a function \( f(x) \) on an interval \( [0,L] \), look up the formula
for the coefficients \( a_j \) and \( b_j \) in the Fourier series of \( f \):

$$
\begin{equation*}
f(x) = \frac{1}{2}a_0 +
\sum_{j=1}^\infty a_j\cos \left(j\frac{2\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{2\pi x}{L}\right)\tp
\end{equation*}
$$

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_2">

<p>
From <a href="https://en.wikipedia.org/wiki/Fourier_series" target="_self">Wikipedia</a> we
have

$$
\begin{align*}
a_j &= \frac{2}{L}\int_0^P f(x)\cos\left(j\frac{2\pi x}{L}\right) \dx,\\ 
b_j &= \frac{2}{L}\int_0^P f(x)\sin\left(j\frac{2\pi x}{L}\right) \dx\tp
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Let an infinite-dimensional vector space \( V \) have the basis functions
\( \cos j\frac{2\pi x}{L} \) for \( j=0,1,\dots,\infty \) and
\( \sin j\frac{2\pi x}{L} \) for \( j=1,\dots,\infty \).  Show that the least squares
approximation method from the section <a href="._approx-sol003.html#fem:approx:global">Approximation of functions</a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of \( f(x) \) (see also
the section <a href="._approx-sol003.html#fem:approx:global:Fourier">Fourier series</a>).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_1">

<p>
You may choose

$$
\begin{equation}
\baspsi_{2i} = \cos\left( i\frac{2\pi}{L}x\right),\quad
\baspsi_{2i+1} = \sin\left( i\frac{2\pi}{L}x\right),
\tag{125}
\end{equation}
$$

for \( i=0,1,\ldots,N\rightarrow\infty \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_3">

<p>
The entries in the linear system arising from the least squares method
are \( A_{i,j}=\int_0^L\baspsi_i\baspsi_j\dx \) and \( b_i=\int_0^L
f(x)\baspsi_i \dx \). To avoid name clash between the right-hand side
components of the linear system and the \( b_i \) coefficients in the
Fourier series, we use the symbol \( q_i \) for the former.
With the basis functions in
<a href="#mjx-eqn-125">(125)</a> we get four different types
of integrals:

$$
\begin{align*}
A_{2i,2j} &= \int_0^L \cos\left( i\frac{2\pi}{L}x\right)
\cos\left( j\frac{2\pi}{L}x\right)\dx = A_{2j,2i},\\ 
A_{2i, 2j+1} &= \int_0^L \cos\left( i\frac{2\pi}{L}x\right)
\sin\left( j\frac{2\pi}{L}x\right)\dx,\\ 
A_{2i+1,2j} &= \int_0^L \sin\left( i\frac{2\pi}{L}x\right)
\cos\left( j\frac{2\pi}{L}x\right)\dx,\\ 
A_{2i+1, 2j+1} &= \int_0^L \sin\left( i\frac{2\pi}{L}x\right)
\sin\left( j\frac{2\pi}{L}x\right)dx,\\ 
q_{2i} &= \int_0^L f(x)\cos\left( i\frac{2\pi}{L}x\right)\dx,\\ 
q_{2i+1} &= \int_0^L f(x)\sin\left( i\frac{2\pi}{L}x\right)\dx\tp
\end{align*}
$$

Now, the sine and cosine basis functions are orthogonal on \( [0,L] \).
We have in general

$$
\begin{align*}
\int_0^L
\cos\left( i\frac{2\pi}{L}x\right) \cos\left( j\frac{2\pi}{L}x\right)\dx
&=0,\quad i\neq j,\\ 
\int_0^L
\cos\left( i\frac{2\pi}{L}x\right) \cos\left( j\frac{2\pi}{L}x\right)\dx
&=\frac{L}{2},\quad i= j\neq 0,\\ 
\int_0^L
\cos\left( i\frac{2\pi}{L}x\right) \cos\left( j\frac{2\pi}{L}x\right)\dx
&=L,\quad i= j= 0,\\ 
\int_0^L
\sin\left( i\frac{2\pi}{L}x\right) \sin\left( j\frac{2\pi}{L}x\right)\dx
&=0,\quad i\neq j,\\ 
\int_0^L
\sin\left( i\frac{2\pi}{L}x\right) \sin\left( j\frac{2\pi}{L}x\right)\dx
&=\frac{L}{2},\quad i= j,\\ 
\int_0^L
\cos\left( i\frac{2\pi}{L}x\right) \sin\left( j\frac{2\pi}{L}x\right)\dx
&=0\tp
\end{align*}
$$

These results imply that only diagonal terms in the coefficient matrix
are different from zero. We have

$$
\begin{align*}
A_{0,0} &= L,\\ 
A_{2i,2i} &= \frac{L}{2},\quad i>0,\\ 
A_{2i+1,2i+1} &= \frac{L}{2}\tp
\end{align*}
$$

The unknown vector with components \( c_i \) must be arranged as

$$ (a_0, b_1, a_1, b_2, a_2, b_3, \ldots)\tp $$

We then get

$$ A_{0,0}a_0=q_0,\quad A_{1,1}b_1=q_1,\quad A_{2,2}a_1=q_2,\quad A_{3,3}b_2=q_3,\ldots$$

These equations lead to the formulas

$$
\begin{align*}
a_0 &= \frac{1}{L}\int_0^P f(x)\dx,\\ 
b_1 &= \frac{2}{L}\int_0^P f(x)\sin\left( \frac{2\pi}{L}x\right)\dx,\\ 
a_1 &= \frac{2}{L}\int_0^P f(x)\cos\left( \frac{2\pi}{L}x\right)\dx,\\ 
b_2 &= \frac{2}{L}\int_0^P f(x)\sin\left( 2\frac{2\pi}{L}x\right)\dx,\\ 
a_2 &= \frac{2}{L}\int_0^P f(x)\cos\left( 2\frac{2\pi}{L}x\right)\dx\tp
\end{align*}
$$

which can be generalized to

$$
\begin{align*}
a_0 &= \frac{1}{L}\int_0^P f(x)\dx,\\ 
a_j &= \frac{2}{L}\int_0^P f(x)\cos\left( j\frac{2\pi}{L}x\right)\dx,\ j>0,\\ 
b_j &= \frac{2}{L}\int_0^P f(x)\sin\left( j\frac{2\pi}{L}x\right)\dx,\ j>0,
\end{align*}
$$

and these are the standard formulas for the Fourier coefficients in a)
if we recognize that the \( a_0 \) above is twice the \( a_0 \) in the
expressions in a).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Choose \( f(x) = H(x-\half) \) on \( \Omega=[0,1] \), where \( H \) is the
Heaviside function: \( H(x)=0 \) for \( x < 0 \), \( H(x)=1 \) for \( x>0 \) and
\( H(0)=\half \). Find the coefficients \( a_j \) and \( b_j \) in the
Fourier series for \( f(x) \). Plot the sum for \( j=2N+1 \), where \( N=5 \) and
\( N=100 \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_4">

<p>
The formulas give

$$
\begin{align*}
a_0 &= 2\int_0^1 f(x)\dx = 2\int_{\half}^1 \dx,\\ 
a_j &= 2\int_0^1 f(x)\cos\left( 2j\pi x\right)\dx
= 2\int_{\half}^1 \cos\left( 2j\pi x\right)\dx,\\ 
b_j &= 2\int_{\half}^1 \sin\left( 2j\pi x\right)\dx\tp
\end{align*}
$$

The integrals are readily computed by <code>sympy</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> j <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;k&#39;</span>, integer<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> integrate(cos(<span style="color: #666666">2*</span>j<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x), (x,Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>),<span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> I
<span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> integrate(cos(<span style="color: #666666">2*0*</span>pi<span style="color: #666666">*</span>x), (x,Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>),<span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> I
<span style="color: #666666">1/2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> integrate(sin(<span style="color: #666666">2*</span>j<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x), (x,Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>),<span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> I
(<span style="color: #666666">-1</span>)<span style="color: #666666">**</span>j<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>pi<span style="color: #666666">*</span>j) <span style="color: #666666">-</span> <span style="color: #666666">1/</span>(<span style="color: #666666">2*</span>pi<span style="color: #666666">*</span>j)
</pre></div>
<p>
This means that we have the series

$$ u(x) = \frac{1}{2} + 2\sum_{j=1}^\infty \frac{(-1)^j - 1}{2\pi j}
\sin\left( 2j\pi x\right)\tp$$

We only get a nonzero coefficient for \( j \) odd:

$$ u(x) = \frac{1}{2} -2\sum_{k=1}^\infty \frac{1}{(2k+1)\pi}
\sin\left( 2(2k+1)\pi x\right)\tp$$

<p>
Appropriate computer code for visualizing the series goes like

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> sin

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Heaviside_series</span>(x, N):
    s <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        s <span style="color: #666666">+=</span> <span style="color: #666666">-2.0/</span>((<span style="color: #666666">2*</span>k<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi)<span style="color: #666666">*</span>sin(<span style="color: #666666">2*</span>(<span style="color: #666666">2*</span>k<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x)
    <span style="color: #008000; font-weight: bold">return</span> s

x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1001</span>)
<span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">5</span>, <span style="color: #666666">100</span>:
    H <span style="color: #666666">=</span> Heaviside_series(x, N)
    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(x, H)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;$N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">$&#39;</span> <span style="color: #666666">%</span> N], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> N)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> N)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center><p><img src="fig-approx/Fourier_Heaviside.png" align="bottom" width=800></p></center>

<p>
We clearly see the Gibbs' phenomenon: oscillations and overshoot around
the point of discontinuity in the function we try to approximate.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>Fourier_ls</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</h2>

<p>
Use interpolation with uniformly distributed
points and Chebychev nodes to approximate

$$
\begin{equation*} f(x) = -\tanh(s(x-\half)),\quad x\in [0,1],\end{equation*}
$$

by Lagrange polynomials for \( s=5 \) and \( s=20 \), and \( N=3,7,11,15 \).
Combine \( 2\times 2 \) plots of the approximation for the four
\( N \) values, and create such figures for the four combinations of
\( s \) values and point types.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_9_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_9_1">

<p>
The following code does the work (symbolically):

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(os<span style="color: #666666">.</span>pardir, <span style="color: #BA2121">&#39;src-approx&#39;</span>))
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> interpolation, comparison_plot
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Lagrange</span> <span style="color: #008000; font-weight: bold">import</span> Lagrange_polynomials
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
N_values <span style="color: #666666">=</span> <span style="color: #666666">3</span>, <span style="color: #666666">7</span>, <span style="color: #666666">11</span>, <span style="color: #666666">15</span>

<span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">5</span>, <span style="color: #666666">20</span>:
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>tanh(s<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>))  <span style="color: #408080; font-style: italic"># sympy expression</span>
    <span style="color: #008000; font-weight: bold">for</span> distribution <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;uniform&#39;</span>, <span style="color: #BA2121">&#39;Chebyshev&#39;</span>:
        <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> N_values:
	    phi, points <span style="color: #666666">=</span> Lagrange_polynomials(
                x, N, Omega,
                point_distribution<span style="color: #666666">=</span>distribution)

	    u, c <span style="color: #666666">=</span> interpolation(f, phi, points)
	    filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;tmp_tanh_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, s, distribution)
	    comparison_plot(f, u, Omega, filename,
			    plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
			    (s, N, distribution))
        <span style="color: #408080; font-style: italic"># Combine plot files (2x2)</span>
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;png&#39;</span>, <span style="color: #BA2121">&#39;pdf&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images &#39;</span> <span style="color: #666666">+</span> ext <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([
                <span style="color: #BA2121">&#39;tmp_tanh_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, s, distribution)
                <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> N_values])
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; tanh_Lagrange_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_s</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (distribution, s)
            os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
For a smooth function (\( s=5 \)), the difference between uniform points and
Chebyshev nodes is not substantial:

<p>
<center><p><img src="fig-approx/tanh_Lagrange_uniform_s5.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/tanh_Lagrange_Chebyshev_s5.png" align="bottom" width=800></p></center>

<p>
However, for a steep function (\( s=20 \)) the overshoot and oscillations
associated with uniform points must be considered unacceptable for
larger \( N \) values:

<p>
<center><p><img src="fig-approx/tanh_Lagrange_uniform_s20.png" align="bottom" width=800></p></center>

<p>
Switching to Chebyshev points does give a great improvement, but
we still have oscillatory approximations:

<p>
<center><p><img src="fig-approx/tanh_Lagrange_Chebyshev_s20.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>tanh_Lagrange</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange:regression">Problem 10: Approximate a steep function by Lagrange polynomials and regression</h2>

<p>
Redo <a href="#fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</a>, but apply a regression
method with \( N \)-degree Lagrange polynomials and \( 2N+1 \)
data points. Recall that
<a href="#fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</a> applies \( N+1 \) points and
the resulting approximation interpolates \( f \) at these points, while
a regression method with more points does not interpolate \( f \) at the
data points.
Do more points and a regression method help reduce
the oscillatory behavior of Lagrange polynomial approximations?

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_1">

<p>
We start out with the program from
<a href="#fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</a>. This time we need
to call <code>Lagrange_polynomails</code> twice: first to compute the \( \baspsi(x) \)
functions (of degree \( N \)) and then to compute the data points corresponding
to a uniform or Chebyshev distribution of \( 2N+1 \) nodes.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(os<span style="color: #666666">.</span>pardir, <span style="color: #BA2121">&#39;src-approx&#39;</span>))
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> regression, comparison_plot
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Lagrange</span> <span style="color: #008000; font-weight: bold">import</span> Lagrange_polynomials
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
N_values <span style="color: #666666">=</span> <span style="color: #666666">3</span>, <span style="color: #666666">7</span>, <span style="color: #666666">11</span>, <span style="color: #666666">15</span>

<span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">5</span>, <span style="color: #666666">20</span>:
    f <span style="color: #666666">=</span> <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>tanh(s<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>))  <span style="color: #408080; font-style: italic"># sympy expression</span>
    <span style="color: #008000; font-weight: bold">for</span> distribution <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;uniform&#39;</span>, <span style="color: #BA2121">&#39;Chebyshev&#39;</span>:
        <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> N_values:
            <span style="color: #408080; font-style: italic"># Compute the points from a 2*N Lagrange polynomial</span>
	    dummy, points <span style="color: #666666">=</span> Lagrange_polynomials(
                x, <span style="color: #666666">2*</span>N, Omega,
                point_distribution<span style="color: #666666">=</span>distribution)
            <span style="color: #408080; font-style: italic"># Compute phi from N points Lagrange polynomial</span>
	    phi, dummy <span style="color: #666666">=</span> Lagrange_polynomials(
                x, N, Omega,
                point_distribution<span style="color: #666666">=</span>distribution)
            points <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(points, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
            point_values <span style="color: #666666">=</span> <span style="color: #666666">-</span>np<span style="color: #666666">.</span>tanh(s<span style="color: #666666">*</span>(points<span style="color: #666666">-0.5</span>))

	    u, c <span style="color: #666666">=</span> regression(f, phi, points)
	    filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;tmp_tanh_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, s, distribution)
	    comparison_plot(f, u, Omega, filename,
			    plot_title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;s=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span>
			    (s, N, distribution),
                            points<span style="color: #666666">=</span>points, point_values<span style="color: #666666">=</span>point_values,
                            points_legend<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> points&#39;</span> <span style="color: #666666">%</span> (<span style="color: #666666">2*</span>N))
        <span style="color: #408080; font-style: italic"># Combine plot files (2x2)</span>
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;png&#39;</span>, <span style="color: #BA2121">&#39;pdf&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images &#39;</span> <span style="color: #666666">+</span> ext <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([
                <span style="color: #BA2121">&#39;tmp_tanh_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, s, distribution)
                <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> N_values])
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; tanh_Lagrange_regr_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_s</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (distribution, s)
            os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
An important point is to convert <code>points</code> to a <code>numpy</code> array using
<code>dtype=float</code>. Leaving out this second argument makes an array
of objects of symbolic expressions, and we cannot apply <code>tanh</code> to it.

<p>
The oscillatory behavior is much reduced using more points and a
regression method, and the difference between uniform and Chebyshev
points is minor, even in the steep case \( s=20 \):

<p>
<center><p><img src="fig-approx/tanh_Lagrange_regr_uniform_s20.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/tanh_Lagrange_regr_Chebyshev_s20.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>tanh_Lagrange_regression</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</h2>

<p>
Consider a domain \( \Omega =[0,2] \) divided into the three elements
\( [0,1] \), \( [1,1.2] \), and \( [1.2,2] \).

<p>
For P1 and P2 elements, set up the list of coordinates and nodes
(<code>nodes</code>) and the numbers of the nodes that belong to each element
(<code>elements</code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_1">

<p>
We can write up figure sketches and the data structure in code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># P1 elements</span>
<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes    <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes    <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]


<span style="color: #408080; font-style: italic"># P2 elements</span>

<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    0  1  2  3  4  5  6</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.1</span>, <span style="color: #666666">1.6</span>, <span style="color: #666666">2</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">nodes:    6  5  4  3  2  1  0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

nodes <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.6</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1.1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_numberings1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh2">Problem 12: Define vertices, cells, and dof maps</h2>

<p>
Repeat <a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a>, but define the
data structures <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> instead of
<code>nodes</code> and <code>elements</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_12_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_12_1">

<p>
Written in Python, the solution becomes

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># P1 elements</span>
<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">dofs:     0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #408080; font-style: italic"># elements:   0   1   2</span>
<span style="color: #408080; font-style: italic"># vertices: 0   1   2   3</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">dofs:     3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]


<span style="color: #408080; font-style: italic"># P2 elements</span>

<span style="color: #408080; font-style: italic"># Left to right numbering</span>
<span style="color: #408080; font-style: italic"># elements:   0   1   2</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--0--|--1--|--2--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 0     1     2     3</span>
<span style="color: #BA2121; font-style: italic">dofs:     0  1  2  3  4  5  6</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]

<span style="color: #408080; font-style: italic"># Right to left numbering</span>
<span style="color: #408080; font-style: italic"># elements:   2   1   0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">elements: |--2--|--1--|--0--|</span>
<span style="color: #BA2121; font-style: italic">vertices: 3     2     1     0</span>
<span style="color: #BA2121; font-style: italic">dofs:     6  5  4  3  2  1  0</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

vertices <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
cells    <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
dof_map  <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_numberings2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:defmesh:sparsity">Problem 13: Construct matrix sparsity patterns</h2>

<p>
<a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a \( 5\times 5 \) matrix and fill in the entries that will be nonzero.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_13_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_13_1">

<p>
A matrix entry \( (i,j) \) is nonzero if \( i \) and \( j \) are nodes in the
same element.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_13_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_13_2">

<p>
If we create an empty matrix, we can run through all elements and
then over all local node pairs and mark that the corresponding
entry \( (i,j) \) in the global matrix is a nonzero entry.
The <code>elements</code> data structure is sufficient. Below is a program
that fills matrix entries with an <code>X</code> and prints the matrix sparsity
pattern.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sparsity_pattern</span>(elements, N_n):
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    matrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N_n, N_n), dtype<span style="color: #666666">=</span><span style="color: #008000">str</span>)
    matrix[:,:] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;0&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> elements:
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> e:
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> e:
                matrix[i,j] <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;X&#39;</span>
    matrix <span style="color: #666666">=</span> matrix<span style="color: #666666">.</span>tolist()
    matrix <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([matrix[i][j]
                                  <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(matrix[i]))])
                        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(matrix))])
    <span style="color: #008000; font-weight: bold">return</span> matrix


<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, left-to-right numbering&#39;</span>
N_n <span style="color: #666666">=</span> <span style="color: #666666">4</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>]]
<span style="color: #008000; font-weight: bold">print</span> sparsity_pattern(elements, N_n)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, right-to-left numbering&#39;</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">3</span>,<span style="color: #666666">2</span>]]
<span style="color: #008000; font-weight: bold">print</span> sparsity_pattern(elements, N_n)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P2 elements, left-to-right numbering&#39;</span>
N_n <span style="color: #666666">=</span> <span style="color: #666666">7</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">2</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">5</span>,<span style="color: #666666">6</span>]]
<span style="color: #008000; font-weight: bold">print</span> sparsity_pattern(elements, N_n)

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">P1 elements, right-to-left numbering&#39;</span>
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], [<span style="color: #666666">4</span>,<span style="color: #666666">3</span>,<span style="color: #666666">2</span>], [<span style="color: #666666">6</span>,<span style="color: #666666">5</span>,<span style="color: #666666">4</span>]]
<span style="color: #008000; font-weight: bold">print</span> sparsity_pattern(elements, N_n)
</pre></div>
<p>
The output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">P1 elements, left-to-right numbering
X X 0 0
X X X 0
0 X X X
0 0 X X

P1 elements, right-to-left numbering
X X 0 0
X X X 0
0 X X X
0 0 X X

P2 elements, left-to-right numbering
X X X 0 0 0 0
X X X 0 0 0 0
X X X X X 0 0
0 0 X X X 0 0
0 0 X X X X X
0 0 0 0 X X X
0 0 0 0 X X X

P1 elements, right-to-left numbering
X X X 0 0 0 0
X X X 0 0 0 0
X X X X X 0 0
0 0 X X X 0 0
0 0 X X X X X
0 0 0 0 X X X
0 0 0 0 X X X
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_sparsity_pattern</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:symbolic">Problem 14: Perform symbolic finite element computations</h2>

<p>
Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating \( f(x) = \sin (x) \) on
\( \Omega=[0, \pi] \) by two P1 elements of size \( \pi/2 \).  Solve the
system and compare \( u(\pi/2) \) with the exact value 1.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_14_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_14_1">

<p>
Here are suitable <code>sympy</code> commands:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #408080; font-style: italic"># Mesh: |--------|-------|</span>
<span style="color: #408080; font-style: italic">#       0      pi/2      pi</span>
<span style="color: #408080; font-style: italic">#</span>
<span style="color: #408080; font-style: italic"># Basis functions:</span>
<span style="color: #408080; font-style: italic">#</span>
<span style="color: #408080; font-style: italic">#   phi_0   phi_1   phi_2</span>
<span style="color: #408080; font-style: italic">#     \      /\      /</span>
<span style="color: #408080; font-style: italic">#      \    /  \    /</span>
<span style="color: #408080; font-style: italic">#       \  /    \  /</span>
<span style="color: #408080; font-style: italic">#        \/      \/</span>
<span style="color: #408080; font-style: italic">#     |-------|-------|</span>
<span style="color: #408080; font-style: italic">#     0      pi/2     pi</span>

x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((<span style="color: #666666">3</span>,<span style="color: #666666">3</span>))
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin

phi_0 <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">2*</span>x)<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi
phi_1l <span style="color: #666666">=</span> <span style="color: #666666">2*</span>x<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi          <span style="color: #408080; font-style: italic"># left part of phi_1</span>
phi_1r <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #666666">-</span> (<span style="color: #666666">2*</span>x)<span style="color: #666666">/</span>sym<span style="color: #666666">.</span>pi    <span style="color: #408080; font-style: italic"># right part of phi_1</span>
phi_2 <span style="color: #666666">=</span> x<span style="color: #666666">/</span>(sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
node_0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
node_1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span>
node_2 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>pi

<span style="color: #408080; font-style: italic"># Diagonal terms</span>
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">**2</span>,  (x, node_0, node_1))
A[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1l<span style="color: #666666">**2</span>, (x, node_0, node_1)) <span style="color: #666666">+</span> \
         sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">**2</span>, (x, node_1, node_2))
A[<span style="color: #666666">2</span>,<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_2<span style="color: #666666">**2</span>,  (x, node_1, node_2))

<span style="color: #408080; font-style: italic"># Off-diagonal terms</span>
A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">*</span>phi_1l, (x, node_0, node_1))
A[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]

A[<span style="color: #666666">1</span>,<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">*</span>phi_2, (x, node_1, node_2))
A[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> A[<span style="color: #666666">1</span>,<span style="color: #666666">2</span>]

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A  <span style="color: #408080; font-style: italic"># Can compare with general matrix, h=pi/2</span>

b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((<span style="color: #666666">3</span>,<span style="color: #666666">1</span>))

b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_0<span style="color: #666666">*</span>f(x),  (x, node_0, node_1))
b[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_1l<span style="color: #666666">*</span>f(x), (x, node_0, node_1)) <span style="color: #666666">+</span> \
       sym<span style="color: #666666">.</span>integrate(phi_1r<span style="color: #666666">*</span>f(x), (x, node_1, node_2))
b[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(phi_2<span style="color: #666666">*</span>f(x),  (x, node_1, node_2))

<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b

c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;c:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, c

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(c)):
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;c[</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">]=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (i, c[i]<span style="color: #666666">.</span>evalf())
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;u(pi/2)=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> c[<span style="color: #666666">1</span>]

<span style="color: #408080; font-style: italic"># For reports</span>
<span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(A)
<span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(b)
<span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(c)
</pre></div>
<p>
Running the program, we get the matrix system

$$
\left[\begin{matrix}\frac{\pi}{6} & \frac{\pi}{12} & 0\\\frac{\pi}{12} & \frac{\pi}{3} & \frac{\pi}{12}\\0 & \frac{\pi}{12} & \frac{\pi}{6}\end{matrix}\right]
\left[\begin{matrix}\frac{1}{\pi} \left(- \frac{24}{\pi} + 8\right)\\\frac{-28 + \frac{168}{\pi}}{7 \pi}\\\frac{1}{\pi} \left(- \frac{24}{\pi} + 8\right)\end{matrix}\right]
=
\left[\begin{matrix}- \frac{2}{\pi} + 1\\\frac{4}{\pi}\\- \frac{2}{\pi} + 1\end{matrix}\right]
$$

The solution at the midpoint is \( 1.15847 \), i.e., 16% error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_sin_P1</code>.

<p>
<!-- Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b), -->
<!-- which is the integral -->
<!-- that arises on the right-hand side. -->

<p>
<!-- solution: -->
<!-- from fe_approx1D_numint import * -->
<!-- c = approximate(sym.sin(x), symbolic=True, d=1, N_e=2, numint=None, -->
<!-- Omega=[0,sym.pi]) -->
<!-- print sym.simplify(c[1,0].subs('h', sym.pi/2)) -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</h2>

<p>
Given

$$
\begin{equation*} f(x) = \tanh(s(x-\half))\end{equation*}
$$

use the Galerkin or least squares method with finite elements to find
an approximate function \( u(x) \). Choose \( s=20 \) and try
\( N_e=4,8,16 \) P1 elements and
\( N_e=2,4,8 \) P2 elements.
Integrate \( f\basphi_i \) numerically.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_15_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_15_1">

<p>
You can automate the computations by calling the <code>approximate</code> method
in the <code>fe_approx1D_numint</code> module.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_15_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_15_2">

<p>
The set of calls to <code>approximate</code> becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> tanh, Symbol
x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

steepness <span style="color: #666666">=</span> <span style="color: #666666">20</span>
arg <span style="color: #666666">=</span> steepness<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=8</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_8e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>,
            d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=16</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p1_tanh_16e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>,
            d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=8</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p2_tanh_8e&#39;</span>)
</pre></div>
<p>
<center><p><img src="fig-approx/fe_p1_tanh.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/fe_p2_tanh.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_tanh_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P3P4">Problem 16: Approximate a steep function by P3 and P4 elements</h2>

<p>
<b>a)</b>
Solve <a href="#fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</a> using \( N_e=1,2,4 \) P3 and P4
elements.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_1">

<p>
We can easily adopt the code from <a href="#fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> tanh, Symbol, lambdify
x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

steepness <span style="color: #666666">=</span> <span style="color: #666666">20</span>
arg <span style="color: #666666">=</span> steepness<span style="color: #666666">*</span>(x<span style="color: #666666">-0.5</span>)

approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=1</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_1e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>,
            d<span style="color: #666666">=3</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p3_tanh_4e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=1</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_1e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=2</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_2e&#39;</span>)
approximate(tanh(arg), symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>,
            d<span style="color: #666666">=4</span>, N_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_p4_tanh_4e&#39;</span>)
</pre></div>
<p>
<center><p><img src="fig-approx/fe_p3_tanh.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/fe_p4_tanh.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
How will an interpolation method work in
this case with the same number of nodes?

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_2">

<p>
The coefficients arising from the interpolation method are trivial to compute
since \( c_i=f(x_i) \), where \( x_i \) are the global nodes. The function
<code>u_glob</code> in the <code>fe_approx1D_numint</code> module can be used to compute
appropriate arrays for plotting the resulting finite element function.
We create plots where the finite element approximation is shown along
with \( f(x) \) and the interpolation points.
Since <code>u_glob</code> requires the <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> data
structures, we must compute these for the values of number of
elements (\( N_e \)) and the polynomial degree (\( d \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Interpolation method</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
f <span style="color: #666666">=</span> lambdify([x], tanh(arg), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)

<span style="color: #408080; font-style: italic"># Compute exact f on a fine mesh</span>
x_fine <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">101</span>)
f_fine <span style="color: #666666">=</span> f(x_fine)

<span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">3</span>, <span style="color: #666666">4</span>:
    <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>:
        h <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>N_e  <span style="color: #408080; font-style: italic"># element length</span>
        vertices <span style="color: #666666">=</span> [i<span style="color: #666666">*</span>h <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e<span style="color: #666666">+1</span>)]
        cells <span style="color: #666666">=</span> [[e, e<span style="color: #666666">+1</span>] <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]
        dof_map <span style="color: #666666">=</span> [[d<span style="color: #666666">*</span>e <span style="color: #666666">+</span> i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)] <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]
        N_n <span style="color: #666666">=</span> d<span style="color: #666666">*</span>N_e <span style="color: #666666">+</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Number of nodes</span>
        x_nodes <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, N_n)  <span style="color: #408080; font-style: italic"># Node coordinates</span>
        U <span style="color: #666666">=</span> f(x_nodes)  <span style="color: #408080; font-style: italic"># Interpolation method samples node values</span>
        x, u, _ <span style="color: #666666">=</span> u_glob(U, vertices, cells, dof_map,
                         resolution_per_element<span style="color: #666666">=51</span>)
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;-&#39;</span>, x_fine, f_fine, <span style="color: #BA2121">&#39;--&#39;</span>,
                 x_nodes, U, <span style="color: #BA2121">&#39;bo&#39;</span>)
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> elements&#39;</span> <span style="color: #666666">%</span> (N_e, d),
                    <span style="color: #BA2121">&#39;exact&#39;</span>, <span style="color: #BA2121">&#39;interpolation points&#39;</span>],
                   loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> (N_e, d))
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (N_e, d))
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center><p><img src="fig-approx/tanh_fe_interpol_P3.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/tanh_fe_interpol_P4.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>fe_tanh_P3P4</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:interpol:error">Exercise 17: Investigate the approximation error in finite elements</h2>

<p>
The theory <a href="._approx-sol007.html#mjx-eqn-101">(101)</a> from the section <a href="._approx-sol007.html#fem:approx:fe:error">Computing the error of the approximation</a> predicts that the error in the Pd
approximation of a function should behave as \( h^{d+1} \), where \( h \) is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough \( h \)).  Choose three examples:
\( f(x)=Ae^{-\omega x} \) on \( [0,3/\omega] \), \( f(x) = A\sin (\omega x) \) on
\( \Omega=[0, 2\pi/\omega] \) for constant \( A \) and \( \omega \), and
\( f(x)=\sqrt{x} \) on \( [0,1] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

<p>
Run a series of experiments: \( (h_i,E_i) \), \( i=0,\ldots,m \), where \( E_i \)
is the \( L^2 \) norm of the error corresponding to element length \( h_i \).
Assume an error model \( E=Ch^r \) and compute \( r \) from two successive
experiments:

$$ r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1\tp$$

Hopefully, the sequence \( r_0,\ldots,r_{m-1} \) converges to the true
\( r \), and \( r_{m-1} \) can be taken as an approximation to \( r \).
Run such experiments for different \( d \) for the different \( f(x) \) functions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_2">

<p>
The <code>approximate</code> function in <code>fe_approx1D_numint.py</code> is handy for
calculating the numerical solution. This function returns the
finite element solution as the coefficients \( \sequencei{c} \).
To compute \( u \), use <code>u_glob</code> from the same module.
Use the Trapezoidal rule to integrate the \( L^2 \) error:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">xc, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map)
e <span style="color: #666666">=</span> f_func(xc) <span style="color: #666666">-</span> u
L2_error <span style="color: #666666">=</span> <span style="color: #666666">0</span>
e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(xc)<span style="color: #666666">-1</span>):
    L2_error <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(e2[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> e2[i])<span style="color: #666666">*</span>(xc[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> xc[i])
L2_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(L2_error)
</pre></div>
<p>
The reason for this Trapezoidal integration is
that <code>u_glob</code> returns coordinates <code>xc</code> and corresponding <code>u</code> values
where some of the coordinates (the cell vertices) coincides, because
the solution is computed in one element at a time, using all local
nodes. Also note that there are many coordinates in \( xc \) per cell
such that we can accurately compute the error inside each cell.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_3">

<p>
Here is an appropriate program:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> approximate, mesh_uniform, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, exp, sin, Symbol, lambdify, simplify
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log

x <span style="color: #666666">=</span> Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
A <span style="color: #666666">=</span> <span style="color: #666666">1</span>
w <span style="color: #666666">=</span> <span style="color: #666666">1</span>

cases <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;sqrt&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: sqrt(x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]},
         <span style="color: #BA2121">&#39;exp&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: A<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>w<span style="color: #666666">*</span>x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>, <span style="color: #666666">3.0/</span>w]},
         <span style="color: #BA2121">&#39;sin&#39;</span>: {<span style="color: #BA2121">&#39;f&#39;</span>: A<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>x), <span style="color: #BA2121">&#39;Omega&#39;</span>: [<span style="color: #666666">0</span>, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">/</span>w]}}

results <span style="color: #666666">=</span> {}
d_values <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]

<span style="color: #008000; font-weight: bold">for</span> case <span style="color: #AA22FF; font-weight: bold">in</span> cases:
    f <span style="color: #666666">=</span> cases[case][<span style="color: #BA2121">&#39;f&#39;</span>]
    f_func <span style="color: #666666">=</span> lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    Omega <span style="color: #666666">=</span> cases[case][<span style="color: #BA2121">&#39;Omega&#39;</span>]
    results[case] <span style="color: #666666">=</span> {}
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> d_values:
        results[case][d] <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;E&#39;</span>: [], <span style="color: #BA2121">&#39;h&#39;</span>: [], <span style="color: #BA2121">&#39;r&#39;</span>: []}
        <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>, <span style="color: #666666">32</span>, <span style="color: #666666">64</span>, <span style="color: #666666">128</span>]:
            <span style="color: #008000; font-weight: bold">try</span>:
                c <span style="color: #666666">=</span> approximate(
                    f, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>,
                    numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d<span style="color: #666666">+1</span>),
                    d<span style="color: #666666">=</span>d, N_e<span style="color: #666666">=</span>N_e, Omega<span style="color: #666666">=</span>Omega,
                    filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_d</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_e</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (case, d, N_e))
            <span style="color: #008000; font-weight: bold">except</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>LinAlgError <span style="color: #008000; font-weight: bold">as</span> e:
                <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">str</span>(e)
                <span style="color: #008000; font-weight: bold">continue</span>
            vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(
                N_e, d, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
            xc, u, _ <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map, <span style="color: #666666">51</span>)
            e <span style="color: #666666">=</span> f_func(xc) <span style="color: #666666">-</span> u
            <span style="color: #408080; font-style: italic"># Trapezoidal integration of the L2 error over the</span>
            <span style="color: #408080; font-style: italic"># xc/u patches</span>
            e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
            L2_error <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(xc)<span style="color: #666666">-1</span>):
                L2_error <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(e2[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> e2[i])<span style="color: #666666">*</span>(xc[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> xc[i])
            L2_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(L2_error)
            h <span style="color: #666666">=</span> (Omega[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega[<span style="color: #666666">0</span>])<span style="color: #666666">/</span><span style="color: #008000">float</span>(N_e)
            results[case][d][<span style="color: #BA2121">&#39;E&#39;</span>]<span style="color: #666666">.</span>append(L2_error)
            results[case][d][<span style="color: #BA2121">&#39;h&#39;</span>]<span style="color: #666666">.</span>append(h)
        <span style="color: #408080; font-style: italic"># Compute rates</span>
        h <span style="color: #666666">=</span> results[case][d][<span style="color: #BA2121">&#39;h&#39;</span>]
        E <span style="color: #666666">=</span> results[case][d][<span style="color: #BA2121">&#39;E&#39;</span>]
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(h)<span style="color: #666666">-1</span>):
            r <span style="color: #666666">=</span> log(E[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>E[i])<span style="color: #666666">/</span>log(h[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>h[i])
            results[case][d][<span style="color: #BA2121">&#39;r&#39;</span>]<span style="color: #666666">.</span>append(<span style="color: #008000">round</span>(r, <span style="color: #666666">2</span>))

<span style="color: #008000; font-weight: bold">print</span> results
<span style="color: #008000; font-weight: bold">for</span> case <span style="color: #AA22FF; font-weight: bold">in</span> results:
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">sorted</span>(results[case]):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;case=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> d=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, r: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
              (case, d, results[case][d][<span style="color: #BA2121">&#39;r&#39;</span>])
</pre></div>
<p>
The output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">case=sqrt d=1, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=2, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=3, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=sqrt d=4, r: [1.0, 1.0, 1.0, 1.0, 1.0]
case=exp d=1, r: [2.01, 2.01, 2.0, 2.0, 2.0]
case=exp d=2, r: [2.81, 2.89, 2.94, 2.97, 2.98]
case=exp d=3, r: [3.98, 4.0, 4.0, 4.0, 4.0]
case=exp d=4, r: [4.87, 4.93, 4.96, 4.98, 4.99]
case=sin d=1, r: [2.15, 2.06, 2.02, 2.0, 2.0]
case=sin d=2, r: [2.68, 2.83, 2.93, 2.97, 2.99]
case=sin d=3, r: [4.06, 4.04, 4.01, 4.0, 4.0]
case=sin d=4, r: [4.79, 4.9, 4.96, 4.98, 4.99]
</pre></div>
<p>
showing that the convergence rate stabilizes quite quickly at \( N_e=128 \)
cells. While the theory predicts the rate as \( d+1 \), this is only
fulfilled for the exponential and sine functions, while the square root
functions gives a rate 1 regardless of \( d \). The reason is that the
estimate <a href="._approx-sol007.html#mjx-eqn-101">(101)</a> contains the integral of
the derivatives of \( f \) over \( [0,1] \). For \( f=\sqrt{x} \), we
have \( f'=\half x^{-1/2} \), \( f''=-\frac{1}{4}x^{-3/2} \), and all integrals
of \( f'' \) and higher derivatives are infinite on \( [0,L] \). Our experiments
show that the method still converges, but \( f \) is not smooth enough that
higher-order elements give superior convergence rates.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>Pd_approx_error</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Heaviside">Problem 18: Approximate a step function by finite elements</h2>

<p>
Approximate the step function

$$
\begin{equation*} f(x) = \left\lbrace\begin{array}{ll}
0 & 0\leq x < \halfi,\\ 
1 & \halfi \leq x \geq \halfi
\end{array}\right.
\end{equation*}
$$

by 2, 4, 8, and 16 P1, P2, P3, and P4. Compare approximations visually.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
This \( f \) can also be expressed in terms of the Heaviside function \( H(x) \):
\( f(x) = H(x-\halfi) \).
Therefore, \( f \) can be defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Heaviside(x <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>))
</pre></div>
<p>
making the <code>approximate</code> function in the
<code>fe_approx1D.py</code> module an obvious candidate to solve the
problem. However, <code>sympy</code> does not handle symbolic integration
with this particular integrand, and the <code>approximate</code> function faces a problem
when converting <code>f</code> to a Python function (for plotting) since
<code>Heaviside</code> is not an available function in <code>numpy</code>.

<p>
An alternative is to perform hand calculations. This is an instructive
task, but in practice only feasible for few elements and P1 and P2 elements.
It is better to copy the functions <code>element_matrix</code>, <code>element_vector</code>,
<code>assemble</code>, and <code>approximate</code> from the <code>fe_approx1D_numint.py</code> file
and edit these functions such that they can compute approximations
with <code>f</code> given as a Python function and not a symbolic expression.
Also assume that <code>phi</code> computed by the <code>basis</code> function is a Python
callable function. Remove all instances of the <code>symbolic</code> variable
and associated code.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_2">

<p>
The modifications of <code>element_matrix</code>, <code>element_vector</code>,
<code>assemble</code>, and <code>approximate</code> from the <code>fe_approx1D_numint.py</code> file
are listed below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> mesh_uniform, u_glob
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> basis
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_matrix</span>(phi, Omega_e, numint):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    A_e <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((n, n))
    h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(r, n):
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(numint[<span style="color: #666666">0</span>])):
                Xj, wj <span style="color: #666666">=</span> numint[<span style="color: #666666">0</span>][j], numint[<span style="color: #666666">1</span>][j]
                A_e[r,s] <span style="color: #666666">+=</span> phi[r](Xj)<span style="color: #666666">*</span>phi[s](Xj)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>wj
            A_e[s,r] <span style="color: #666666">=</span> A_e[r,s]
    <span style="color: #008000; font-weight: bold">return</span> A_e

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, numint):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    b_e <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n)
    h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(numint[<span style="color: #666666">0</span>])):
            Xj, wj <span style="color: #666666">=</span> numint[<span style="color: #666666">0</span>][j], numint[<span style="color: #666666">1</span>][j]
            xj <span style="color: #666666">=</span> (Omega_e[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> Omega_e[<span style="color: #666666">1</span>])<span style="color: #666666">/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>Xj  <span style="color: #408080; font-style: italic"># mapping</span>
            b_e[r] <span style="color: #666666">+=</span> f(xj)<span style="color: #666666">*</span>phi[r](Xj)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>wj
    <span style="color: #008000; font-weight: bold">return</span> b_e


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assemble</span>(vertices, cells, dof_map, phi, f, numint):
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sets</span>
    N_n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(<span style="color: #008000">list</span>(<span style="color: #008000">set</span>(np<span style="color: #666666">.</span>array(dof_map)<span style="color: #666666">.</span>ravel())))
    N_e <span style="color: #666666">=</span> <span style="color: #008000">len</span>(cells)
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N_n, N_n))
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N_n)
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e):
        Omega_e <span style="color: #666666">=</span> [vertices[cells[e][<span style="color: #666666">0</span>]], vertices[cells[e][<span style="color: #666666">1</span>]]]
        A_e <span style="color: #666666">=</span> element_matrix(phi[e], Omega_e, numint)
        b_e <span style="color: #666666">=</span> element_vector(f, phi[e], Omega_e, numint)
        <span style="color: #408080; font-style: italic">#print &#39;element&#39;, e</span>
        <span style="color: #408080; font-style: italic">#print b_e</span>
        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(dof_map[e])):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(dof_map[e])):
                A[dof_map[e][r],dof_map[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
            b[dof_map[e][r]] <span style="color: #666666">+=</span> b_e[r]
    <span style="color: #008000; font-weight: bold">return</span> A, b

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">approximate</span>(f, d, N_e, numint, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute the finite element approximation, using Lagrange</span>
<span style="color: #BA2121; font-style: italic">    elements of degree d, to a Python functionn f on a domain</span>
<span style="color: #BA2121; font-style: italic">    Omega. N_e is the number of elements.</span>
<span style="color: #BA2121; font-style: italic">    numint is the name of the numerical integration rule</span>
<span style="color: #BA2121; font-style: italic">    (Trapezoidal, Simpson, GaussLegendre2, GaussLegendre3,</span>
<span style="color: #BA2121; font-style: italic">    GaussLegendre4, etc.). numint=None implies exact</span>
<span style="color: #BA2121; font-style: italic">    integration.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt
    numint_name <span style="color: #666666">=</span> numint  <span style="color: #408080; font-style: italic"># save name</span>
    <span style="color: #008000; font-weight: bold">if</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Trapezoidal&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Simpson&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1./3</span>, <span style="color: #666666">4./3</span>, <span style="color: #666666">1./3</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Midpoint&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">2</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre2&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-1/</span>sqrt(<span style="color: #666666">3</span>), <span style="color: #666666">1/</span>sqrt(<span style="color: #666666">3</span>)], [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre3&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-</span>sqrt(<span style="color: #666666">3./5</span>), <span style="color: #666666">0</span>, sqrt(<span style="color: #666666">3./5</span>)],
                  [<span style="color: #666666">5./9</span>, <span style="color: #666666">8./9</span>, <span style="color: #666666">5./9</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre4&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-0.86113631</span>, <span style="color: #666666">-0.33998104</span>,  <span style="color: #666666">0.33998104</span>,
                   <span style="color: #666666">0.86113631</span>],
                  [ <span style="color: #666666">0.34785485</span>,  <span style="color: #666666">0.65214515</span>,  <span style="color: #666666">0.65214515</span>,
                    <span style="color: #666666">0.34785485</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;GaussLegendre5&#39;</span>:
        numint <span style="color: #666666">=</span> [[<span style="color: #666666">-0.90617985</span>, <span style="color: #666666">-0.53846931</span>, <span style="color: #666666">-0.</span>        ,
                   <span style="color: #666666">0.53846931</span>,  <span style="color: #666666">0.90617985</span>],
                  [ <span style="color: #666666">0.23692689</span>,  <span style="color: #666666">0.47862867</span>,  <span style="color: #666666">0.56888889</span>,
                    <span style="color: #666666">0.47862867</span>,  <span style="color: #666666">0.23692689</span>]]
    <span style="color: #008000; font-weight: bold">elif</span> numint <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Numerical rule </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> is not supported for numerical computing&#39;</span> <span style="color: #666666">%</span> numint
        sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)


    vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(N_e, d, Omega)

    <span style="color: #408080; font-style: italic"># phi is a list where phi[e] holds the basis in cell no e</span>
    <span style="color: #408080; font-style: italic"># (this is required by assemble, which can work with</span>
    <span style="color: #408080; font-style: italic"># meshes with different types of elements).</span>
    <span style="color: #408080; font-style: italic"># len(dof_map[e]) is the number of nodes in cell e,</span>
    <span style="color: #408080; font-style: italic"># and the degree of the polynomial is len(dof_map[e])-1</span>
    phi <span style="color: #666666">=</span> [basis(<span style="color: #008000">len</span>(dof_map[e])<span style="color: #666666">-1</span>) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]

    A, b <span style="color: #666666">=</span> assemble(vertices, cells, dof_map, phi, f,
                    numint<span style="color: #666666">=</span>numint)

    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;cells:&#39;</span>, cells
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;vertices:&#39;</span>, vertices
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;dof_map:&#39;</span>, dof_map
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;c:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, c

    <span style="color: #008000; font-weight: bold">if</span> filename <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        title <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, N_e=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d, N_e)
        title <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;, integration: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> numint_name
        x_u, u, _ <span style="color: #666666">=</span> u_glob(np<span style="color: #666666">.</span>asarray(c), vertices, cells, dof_map,
                           resolution_per_element<span style="color: #666666">=51</span>)
        x_f <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], <span style="color: #666666">10001</span>) <span style="color: #408080; font-style: italic"># mesh for f</span>
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
        plt<span style="color: #666666">.</span>plot(x_u, u, <span style="color: #BA2121">&#39;-&#39;</span>,
                 x_f, f(x_f), <span style="color: #BA2121">&#39;--&#39;</span>)
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;u&#39;</span>, <span style="color: #BA2121">&#39;f&#39;</span>])
        plt<span style="color: #666666">.</span>title(title)
        plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pdf&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.png&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> c
</pre></div>
<p>
With a purely numerical version of the <code>approximate</code> function, we can
easily investigate the suggested approximations in this exercise:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exercise</span>():
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #008000">isinstance</span>(x, np<span style="color: #666666">.</span>ndarray):
            <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>)

    N_e_values <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>]
    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>:
        <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> N_e_values:
            approximate(f, numint<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (d<span style="color: #666666">+1</span>),
                        d<span style="color: #666666">=</span>d, N_e<span style="color: #666666">=</span>N_e,
                        filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">e&#39;</span> <span style="color: #666666">%</span> (d, N_e))
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;pdf&#39;</span>, <span style="color: #BA2121">&#39;png&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images &#39;</span>
            cmd <span style="color: #666666">+=</span> ext <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; -2 &#39;</span>
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39;fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">e&#39;</span> <span style="color: #666666">%</span> (d, N_e)
                             <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> N_e_values])
            cmd <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39; fe_Heaviside_P</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> d
            <span style="color: #008000; font-weight: bold">print</span> cmd
            os<span style="color: #666666">.</span>system(cmd)
</pre></div>
<p>
Running this function reveals that even finite elements
(and not only sines, as demonstrated in <a href="#fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</a>)
give oscillations around a discontinuity.

<p>
<center><p><img src="fig-approx/fe_Heaviside_P1.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/fe_Heaviside_P2.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/fe_Heaviside_P3.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-approx/fe_Heaviside_P4.png" align="bottom" width=800></p></center>

<p>
<b>Remarks.</b>
It is of extreme importance to use a Gauss-Legendre numerical integration
rule that matches the degree of polynomials in the basis.
Using a rule with fewer points may lead to very strange results.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_Heaviside_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:2Dsines:symbolic">Exercise 19: 2D approximation with orthogonal functions</h2>

<p>
<b>a)</b>
Assume we have basis functions \( \basphi_i(x,y) \) in 2D that are
orthogonal such that \( (\basphi_i,\basphi_j)=0 \) when \( i\neq j \).  The
function <code>least_squares</code> in the file <a href="http://tinyurl.com/nm5587k/approx/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a> will then spend much time on computing
off-diagonal terms in the coefficient matrix that we know are zero.
To speed up the computations, make a version <code>least_squares_orth</code> that
utilizes the orthogonality among the basis functions.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_2">

<p>
We 1) remove the <code>j</code> loop in the <code>least_squares</code> function and set
<code>j = i</code>,
2) make <code>A</code> a vector (i.e., \( (N+1, 1) \) matrix as <code>b</code> and <code>c</code>),
3) solve for <code>c[i,0]</code> as soon as <code>A[i,0]</code> and <code>b[i,0]</code> are computed.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>,
                       print_latex<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Given a function f(x,y) on a rectangular domain</span>
<span style="color: #BA2121; font-style: italic">    Omega=[[xmin,xmax],[ymin,ymax]],</span>
<span style="color: #BA2121; font-style: italic">    return the best approximation to f(x,y) in the space V</span>
<span style="color: #BA2121; font-style: italic">    spanned by the functions in the list psi.</span>
<span style="color: #BA2121; font-style: italic">    This function assumes that psi are orthogonal on Omega.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Modification of least_squares function: drop the j loop,</span>
    <span style="color: #408080; font-style: italic"># set j=i, compute c on the fly in the i loop.</span>

    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    <span style="color: #408080; font-style: italic"># Note that A, b, c becmes (N+1)x(N+1), use 1st column</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    c <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;...evaluating matrix...&#39;</span>, A<span style="color: #666666">.</span>shape, b<span style="color: #666666">.</span>shape, c<span style="color: #666666">.</span>shape
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        j <span style="color: #666666">=</span> i
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> (i, j)

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,
                             (x, Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]),
                             (y, Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #408080; font-style: italic"># Could not integrate symbolically, use numerical int.</span>
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x,y], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand,
                               [Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                               [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]])
        A[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,
                             (x, Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]),
                             (y, Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #408080; font-style: italic"># Could not integrate symbolically, use numerical int.</span>
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x,y], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand,
                               [Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                               [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
        c[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[i,<span style="color: #666666">0</span>]<span style="color: #666666">/</span>A[i,<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">print</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b
    c <span style="color: #666666">=</span> [c[i,<span style="color: #666666">0</span>] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]  <span style="color: #408080; font-style: italic"># make list</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;coeff:&#39;</span>, c

    <span style="color: #408080; font-style: italic"># c is a sympy Matrix object, numbers are in c[i,0]</span>
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;approximation:&#39;</span>, u
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;f:&#39;</span>, sym<span style="color: #666666">.</span>expand(f)
    <span style="color: #008000; font-weight: bold">if</span> print_latex:
        <span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(A, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
        <span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(b, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
        <span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>latex(c, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Apply the function to approximate

$$ f(x,y) = x(1-x)y(1-y)e^{-x-y}$$

on \( \Omega = [0,1]\times [0,1] \) via basis functions

$$ \basphi_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
$$

where \( p=0,\ldots,N_x \) and \( q=0,\ldots,N_y \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_1">

<p>
Get ideas from the function <code>least_squares_orth</code> in
the section <a href="._approx-sol003.html#fem:approx:global:orth">Orthogonal basis functions</a> and
file <a href="http://tinyurl.com/nm5587k/approx/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_3">

<p>
A function for computing the basis functions may look like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_basis</span>(Nx, Ny):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute basis sin((p+1)*pi*x)*sin((q+1)*pi*y),</span>
<span style="color: #BA2121; font-style: italic">    p=0,...,Nx, q=0,...,Ny.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    psi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> q <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
            r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin((p<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin((q<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>y)
            psi<span style="color: #666666">.</span>append(r)
    <span style="color: #008000; font-weight: bold">return</span> psi
</pre></div>
<p>
Application of this basis to approximate the given function is coded in
the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>(N):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Find the approximation of f by the least squares method.</span>
<span style="color: #BA2121; font-style: italic">    The basis is sin((p+1)*pi*x)sin((q+1)*pi*y) where</span>
<span style="color: #BA2121; font-style: italic">    0&lt;p&lt;=N, p&lt;q&lt;=N.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>y<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>y)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x<span style="color: #666666">-</span>y)

    psi <span style="color: #666666">=</span> sine_basis(N, N)

    Omega <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]]
    u, c  <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx2D</span> <span style="color: #008000; font-weight: bold">import</span> comparison_plot
    comparison_plot(f, u, Omega, title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> N)
    <span style="color: #008000; font-weight: bold">print</span> c

<span style="color: #008000; font-weight: bold">if</span> __name__<span style="color: #666666">==</span><span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #408080; font-style: italic">#test_least_squares_orth()</span>
    demo(N<span style="color: #666666">=2</span>)
</pre></div>
<p>
A lesson learned is that <code>symbolic=False</code> is important, otherwise <code>sympy</code>
consumes a lot of CPU time on trying to integrate symbolically.

<p>
The figure below shows the error in the approximation for \( N=0 \) (left)
and \( N=2 \) (right). The coefficients for \( N=2 \) decay rapidly:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[0.025, 0.0047, 0.0014, 0.0047, 0.0009, 0.0003, 0.0014, 0.0003,
 8.2e-5]
</pre></div>
<p>
<center><p><img src="fig-approx/approx2D_ls_orth_sine_c.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Make a unit test for the <code>least_squares_orth</code> function.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_4">

<p>
Let us use the basis in b), fix the coefficients of some function
\( f \), and check that the computed approximation, with the
same basis, has the same coefficients (this test employs the principle
that if \( f\in V \), then \( u=f \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_least_squares_orth</span>():
    <span style="color: #408080; font-style: italic"># Use sine functions</span>
    x, y <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
    N <span style="color: #666666">=</span> <span style="color: #666666">2</span>  <span style="color: #408080; font-style: italic"># (N+1)**2 = 9 basis functions</span>
    psi <span style="color: #666666">=</span> sine_basis(N, N)
    f_coeff <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span><span style="color: #008000">len</span>(psi)
    f_coeff[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    f_coeff[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    f <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(f_coeff[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #408080; font-style: italic"># Check that u exactly reproduces f</span>
    u, c <span style="color: #666666">=</span> least_squares_orth(f, psi, Omega<span style="color: #666666">=</span>[[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]],
                              symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(np<span style="color: #666666">.</span>array(c) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>array(f_coeff))<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;diff:&#39;</span>, diff
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>approx2D_ls_orth</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:trapez">Exercise 20: Use the Trapezoidal rule and P1 elements</h2>

<p>
Consider approximation of some \( f(x) \) on an interval \( \Omega \) using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a href="._approx-sol008.html#mjx-eqn-109">(109)</a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form \( c_i=f(\xno{i}) \) for \( i\in\If \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_20_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_20_1">

<p>
The Trapezoidal rule for integrals on \( [-1,1] \)
is given by <a href="._approx-sol008.html#mjx-eqn-109">(109)</a>.
The expressions for the entries in the element matrix
are given by <a href="._approx-sol004.html#mjx-eqn-74">(74)</a> in
the section <a href="._approx-sol004.html#fem:approx:fe:mapping">Mapping to a reference element</a>:

$$
\begin{align*} \tilde A^{(e)}_{r,s} &=
\int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,\dX\\ 
&\approx \frac{h}{2}(\refphi_r(-1)\refphi_s(-1)
+ \refphi_r(1)\refphi_s(1))\tp
\end{align*}
$$

We know that if \( \refphi_r(\pm 1) \) is 0 or 1, so evaluating
the formula above for \( r,s=0,1 \) gives

$$ \tilde A^{(e)} = \frac{h}{2}\left(\begin{array}{cc}
1 & 0\\ 
0 & 1
\end{array}\right)\tp$$

As usual, \( h \) is the length of the element in physical coordinates.

<p>
The element vector in the reference element is given by
<a href="._approx-sol004.html#mjx-eqn-75">(75)</a>:

$$
\begin{align*}
\tilde b^{(e)}_{r} &=  \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,\dX\\ 
&\approx \frac{h}{2}(f(x(-1))\refphi_r(-1)
+ f(x(1))\refphi_r(1))\tp
\end{align*}
$$

Evaluating the formula for \( r=0,1 \) leads to

$$ \tilde b^{(e)} = \frac{h}{2}\left(\begin{array}{c}
f(x_L)\\ 
f(x_R)
\end{array}\right),$$

where \( x_L \) and \( x_R \) are the \( x \) coordinates of the local points
\( X=-1 \) and \( X=1 \), respectively.

<p>
With a uniform mesh with nodes \( \xno{i}=ih \), the element matrix and
vectors assemble to a coefficient matrix

$$ \frac{h}{2}\hbox{diag}(1, 2, \ldots, 2, 1),$$

and right-hand side vector

$$ \frac{h}{2}(f(\xno{0}), 2f(\xno{1}), \ldots, 2f(\xno{N_n-1}),
f(\xno{N_n}))\tp$$

The factors \( h/2 \) and \( 2 \) cancel, so we are left with the solution of
the system as

$$ c_i = f(\xno{i})\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_P1_trapez</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:P1:vs:interp">Exercise 21: Compare P1 elements and interpolation</h2>

<p>
We shall approximate the function

$$ f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],$$

where \( n\in\Integer \) and \( \epsilon \geq 0 \).

<p>
<b>a)</b>
Plot \( f(x) \) for \( n=1,2,3 \) and find the wave length of the function.

<p>
<b>b)</b>
We want to use \( N_P \) elements per wave length. Show that the number
of elements is then \( nN_P \).

<p>
<b>c)</b>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an \( f \) with just one wave length in \( \Omega = [0,1] \).
Set \( \epsilon = 0.5 \).

<p>
Run the least squares or projection/Galerkin method for
\( N_P=2,4,8,16,32 \). Compute the error \( E=||u-f||_{L^2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_21_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_21_1">

<p>
Use the <code>fe_approx1D_numint</code> module to compute \( u \) and use
the technique from the section <a href="._approx-sol007.html#fem:approx:fe:error">Computing the error of the approximation</a> to
compute the norm of the error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute \( u(x) \) (recall that \( c_i \) is now simply \( f(\xno{i}) \)).
Compute the error \( E=||u-f||_{L^2} \).
Which method seems to be most accurate?

<p>
Filename: <code>fe_P1_vs_interp</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:3D:approx3D">Exercise 22: Implement 3D computations with global basis functions</h2>

<p>
Extend the <a href="http://tinyurl.com/nm5587k/approx/approx2D.py" target="_self"><tt>approx2D.py</tt></a> code to 3D
applying ideas from the section <a href="._approx-sol009.html#fem:approx:3D:global">Extension to 3D</a>.
Construct some 3D problem to make a test function for the
implementation.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_22_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_22_1">

<p>
Drop symbolic integration since it is in general too slow for 3D problems.
Also use <code>scipy.integrate.nquad</code> instead of <code>sympy.mpmath.quad</code>
for numerical integration, since it is much faster.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_22_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_22_2">

<p>
We take a copy of <code>approx2D.py</code> and drop the <code>comparison_plot</code> function since
plotting in 3D is much more complicated (could make a special version with
curves through lines in the 3D domain, for instance).
Furthermore, we remove the lines with symbolic integration and replace
the calls to <code>sym.mpmath.quad</code> by calls to
<code>scipy.integrate.nquad</code>. The resulting function becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.integrate</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Given a function f(x,y,z) on a rectangular domain</span>
<span style="color: #BA2121; font-style: italic">    Omega=[[xmin,xmax],[ymin,ymax],[zmin,zmax]],</span>
<span style="color: #BA2121; font-style: italic">    return the best approximation to f in the space V</span>
<span style="color: #BA2121; font-style: italic">    spanned by the functions in the list psi.</span>
<span style="color: #BA2121; font-style: italic">    f and psi are symbolic (sympy) expressions, but will</span>
<span style="color: #BA2121; font-style: italic">    be converted to numeric functions for faster integration.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x, y, z], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    psi_sym <span style="color: #666666">=</span> psi[:]  <span style="color: #408080; font-style: italic"># take a copy, needed for forming u later</span>
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x, y, z], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi))]

    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;...evaluating matrix...&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> (i, j)

            integrand <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y, z: psi[i](x,y,z)<span style="color: #666666">*</span>psi[j](x,y,z)
            I, err <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>nquad(
                integrand,
                [[Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
                 [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]],
                 [Omega[<span style="color: #666666">2</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">2</span>][<span style="color: #666666">1</span>]]])
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> I
        integrand <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, y, z: psi[i](x,y,z)<span style="color: #666666">*</span>f(x,y,z)
        I, err <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>nquad(
            integrand,
            [[Omega[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">0</span>][<span style="color: #666666">1</span>]],
             [Omega[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>][<span style="color: #666666">1</span>]],
             [Omega[<span style="color: #666666">2</span>][<span style="color: #666666">0</span>], Omega[<span style="color: #666666">2</span>][<span style="color: #666666">1</span>]]])
        b[i] <span style="color: #666666">=</span> I
    <span style="color: #008000; font-weight: bold">print</span>
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
    <span style="color: #008000; font-weight: bold">if</span> N <span style="color: #666666">&lt;=</span> <span style="color: #666666">10</span>:
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;A:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, A, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">b:</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>, b
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;coeff:&#39;</span>, c
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi_sym[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi_sym)))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;approximation:&#39;</span>, u
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
As test example, we can use the basis

$$ \baspsi_{p,q,r} = \sin((p+1)\pi x)\sin((q+1)\pi y)\sin((r+1)\pi z),$$

for \( p=1,\ldots,N_x \), \( q=1,\ldots,N_y \), \( r=1,\ldots,N_z \).
We choose \( f \) as some prescribed combination of these functions and
check that the computed \( u \) is exactly equal to \( f \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_basis</span>(Nx, Ny, Nz):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compute basis sin((p+1)*pi*x)*sin((q+1)*pi*y)*sin((r+1)*pi*z),</span>
<span style="color: #BA2121; font-style: italic">    p=0,...,Nx, q=0,...,Ny, r=0,...,Nz.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    psi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nz<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> q <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>):
            <span style="color: #008000; font-weight: bold">for</span> p <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
                s <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin((p<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>\ 
                    sym<span style="color: #666666">.</span>sin((q<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>y)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin((r<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>z)
                psi<span style="color: #666666">.</span>append(s)
    <span style="color: #008000; font-weight: bold">return</span> psi

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_least_squares</span>():
    <span style="color: #408080; font-style: italic"># Use sine functions</span>
    x, y, z <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    N <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># (N+1)**3 = 8 basis functions</span>
    psi <span style="color: #666666">=</span> sine_basis(N, N, N)
    f_coeff <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span><span style="color: #008000">len</span>(psi)
    f_coeff[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    f_coeff[<span style="color: #666666">4</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    f <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(f_coeff[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #408080; font-style: italic"># Check that u exactly reproduces f</span>
    u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega<span style="color: #666666">=</span>[[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], [<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]])
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(np<span style="color: #666666">.</span>array(c) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>array(f_coeff))<span style="color: #666666">.</span>max()
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;diff:&#39;</span>, diff
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>approx3D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:simpson">Exercise 23: Use Simpson's rule and P2 elements</h2>

<p>
Redo <a href="#fem:approx:fe:exer:1D:trapez">Exercise 20: Use the Trapezoidal rule and P1 elements</a>, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_23_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_23_1">

<p>
Simpson's rule for integrals on \( [-1,1] \)
is given by <a href="._approx-sol008.html#mjx-eqn-110">(110)</a>.
The expressions for the entries in the element matrix
are given by <a href="._approx-sol004.html#mjx-eqn-74">(74)</a>:

$$
\begin{align*} \tilde A^{(e)}_{r,s} &=
\int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,\dX\\ 
&\approx \frac{1}{3}\frac{h}{2}(\refphi_r(-1)\refphi_s(-1)
+ 4\refphi_r(0)\refphi_s(0)
+ \refphi_r(1)\refphi_s(1))\tp
\end{align*}
$$

The expressions for \( \refphi_r(X) \) are given by
<a href="._approx-sol004.html#mjx-eqn-76">(76)</a>-\eqref{fem:approx:fe:mapping:P1:phi2}.
Evaluating the formula for \( r,s=0,1,2 \) gives the element matrix

$$ \tilde A^{(e)} = \frac{h}{6}\left(\begin{array}{ccc}
1 & 0 & 0\\ 
0 & 4 & 0\\ 
0 & 0 & 1
\end{array}\right)\tp$$

As usual, \( h \) is the length of the element in physical coordinates.

<p>
The element vector in the reference element is given by
<a href="._approx-sol004.html#mjx-eqn-75">(75)</a>:

$$
\begin{align*}
\tilde b^{(e)}_{r} &=  \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,\dX\\ 
&\approx \frac{1}{3}\frac{h}{2}(f(x(-1))\refphi_r(-1)
+ 4f(x(0))\refphi_r(0)
+ f(x(1))\refphi_r(1))\tp
\end{align*}
$$

Evaluating the formula for \( r=0,1,2 \) leads to

$$ \tilde b^{(e)} = \frac{h}{2}\left(\begin{array}{c}
f(x_L)\\ 
4f(x_c)
f(x_R)
\end{array}\right),$$

where \( x_L \), \( x_c \), and \( x_R \) are the \( x \) coordinates of the local points
\( X=-1 \), \( X=0 \), and \( X=1 \), respectively. These correspond to the nodes
in the element.

<p>
With a uniform mesh with nodes \( \xno{i}=ih \), the element matrix and
vectors assemble to a coefficient matrix

$$ \frac{h}{6}\hbox{diag}(1, 4, 2, 4, 2, 4, \ldots, 2, 4, 1),$$

and right-hand side vector

$$ \frac{h}{6}(f(\xno{0}), 4f(\xno{1}), 2f(\xno{2}),
4f(\xno{3}), 2f(\xno{4}), \ldots, 2f(\xno{N_n-2}),
4f(\xno{N_n-1}), f(\xno{N_n}))\tp$$

The factors \( h/6 \), \( 2 \) and \( 4 \) all cancel, so we are left with the solution of
the system as

$$ c_i = f(\xno{i})\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>fe_P2_simpson</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._approx-sol010.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._approx-sol012.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

