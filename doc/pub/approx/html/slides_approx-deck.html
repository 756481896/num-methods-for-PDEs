<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Approximation of functions">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,mass matrix,mass lumping,lumped mass matrix,finite element, definition,dof map,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,Midpoint rule,Trapezoidal rule,Simpson's rule,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Study guide: Approximation of functions</title>







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.cbc.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!--
Transition theme. More available in /themes/transition/ or create your own. -->
<!--
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */

hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
     padding:8px 35px 8px 14px; margin-bottom:18px;
     text-shadow:0 1px 0 rgba(255,255,255,0.5);
     border:5px solid #bababa;
       -webkit-border-radius:14px; -moz-border-radius:14px;
     border-radius:14px
     background-position: 10px 10px;
     background-repeat: no-repeat;
     background-size: 38px;
     padding-left: 30px; /* 55px; if icon */
 }
 .slide .alert-block {padding-top:14px; padding-bottom:14px}
 .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
 /*.slide .alert li {margin-top: 1em}*/
 .deck .alert-block p+p {margin-top:5px}
 /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
 .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
 .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
 .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">

<header>
<!-- Here goes a potential header -->
</header>

<!-- do not use the article tag - it gives strange sizings -->





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->

<h2 style="text-align: center;">Study guide: Approximation of functions</h2>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><b style="font-weight: bold">Sep 13, 2015</b></center> <!-- date -->
<br>
<p>
<!-- 2DO: -->
<!-- Less 7= headings (or: ok when approx and varform are split?) -->
</section>


<section class="slide">

<h1 id="___sec0">Finite elements can handle complex geometry, adaptive meshes, higher-order approximations and has a firm theory </h1>

<ul>
 <p><li class="slide"> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li class="slide"> Can with ease create varying spatial resolution to get
   accuracy where it is needed</li>
 <p><li class="slide"> Can with ease provide higher-order approximations</li>
 <p><li class="slide"> Has a rigorous mathematical analysis framework</li>
</ul>
<p>
<!-- The theoretical framework is not powerful enough to uncover the -->
<!-- serious limitations of the method in time-dependent problems -->
<!-- and the necessary adjustments) -->

<p>
<center><p><img src="fig-approx/dolfin_mesh.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec1">A dolphin and its flow </h2>
</section>


<section class="slide">

<h2 id="___sec2">Solving PDEs by the finite element method </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Stationary PDEs:</b>
<ol>
<p><li> Transform the PDE problem to a <em>variational form</em></li>
<p><li> Define function approximation over <em>finite elements</em></li>
<p><li> Use a computational machinery to derive <em>linear systems</em></li>
<p><li> Solve linear systems</li>
</ol>
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Time-dependent PDEs:</b>
<ul>
 <p><li> Finite elements <em>in space</em></li>
 <p><li> Finite difference (or ODE solver) in time</li>
</ul>
</div>

<p>
<!-- Give a brief example here, 1D or 2D -->
</section>


<section class="slide">

<h2 id="___sec3">We start with function approximation, then we treat PDEs </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Learning strategy.</b>
<ul>
 <p><li> Start with approximation of functions, not PDEs</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See later how this machinery is applied to PDEs</li>
</ul>
</div>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Reason:</b>
<p>
The finite element method has many concepts and a jungle of details.
This learning
strategy minimizes the mixing of ideas, concepts, and technical details.
</div>
</section>


<section class="slide">

<h1 id="___sec4">Find a vector in some space that approximates a given vector in a space of higher dimension </h1>

<p>
<center><p><img src="fig-approx/vecapprox_plane.png" align="bottom" width=300></p></center>
</section>


<section class="slide">

<h2 id="___sec5">The approximation is a linear combination of prescribed basis functions </h2>

<p>
General idea of finding an approximation \( u(x) \) to some given \( f(x) \):

<p>&nbsp;<br>
$$  u(x) = \sum_{i=0}^N c_i\baspsi_i(x) $$
<p>&nbsp;<br>

<p>
where

<ul>
 <p><li> \( \baspsi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec6">We have three methods to determine the coefficients </h2>

<p>
We shall address three approaches:

<ul>
 <p><li> The least squares method</li>
 <p><li> The projection (or Galerkin) method</li>
 <p><li> The interpolation (or collocation) method</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Underlying motivation for our notation.</b>
<p>
Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org" target="_self">FEniCS</a> software package for finite element computing.
</div>
</section>


<section class="slide">

<h2 id="fem:approx:vec:plane">Approximation of planar vectors; problem</h2>

<p>
Given a vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center><p><img src="fig-approx/vecapprox_plane.png" align="bottom" width=300></p></center>
</section>


<section class="slide">

<h2 id="___sec8">Approximation of planar vectors; vector space terminology </h2>

<p>&nbsp;<br>
$$ V = \mbox{span}\,\{ \psib_0\} $$
<p>&nbsp;<br>


<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
</ul>
<p>

Define

<ul>
 <p><li> the error \( \e = \f - \u \)</li>
 <p><li> the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec9">The least squares method; principle </h2>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Mathematical convenience: minimize \( E=||\e||^2 \)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\end{equation*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec10">The least squares method; calculations </h2>

<p>&nbsp;<br>
$$
\begin{align*}
E(c_0) &= (\e,\e) = (\f - \u, (\f - \u) = (\f - c_0\psib_0, \f - c_0\psib_0)\\ 
       &= (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{align*}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)} = \frac{3a + 5b}{a^2 + b^2}
$$
<p>&nbsp;<br>

<p>
Observation to be used later: the vanishing derivative <a href="#mjx-eqn-1">(1)</a>
can be alternatively written as

<p>&nbsp;<br>
$$ (\e, \psib_0) = 0 $$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec11">The projection (or Galerkin) method </h2>

<ul>
 <p><li class="slide"> Last slide: \( \min E \) is equivalent with \( (\e, \psib_0)=0 \)</li>
 <p><li class="slide"> \( (\e, \psib_0)=0 \) implies \( (\e, \v)=0 \) for <em>any</em> \( \v\in V \)</li>
 <p><li class="slide"> That is: instead of using the least-squares principle, we can
   require that \( \e \) is orthogonal to <em>any</em> \( \v\in V \)<br />
   (visually clear, but can easily be computed too)</li>
 <p><li class="slide"> Precise math: find \( c_0 \) such that \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li class="slide"> Equivalent (see notes): find \( c_0 \) such that \( (\e, \psib_0)=0 \)</li>
 <p><li class="slide"> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li class="slide"> Same equation for \( c_0 \) and hence same solution as in the least squares
   method</li>
</ul>
</section>


<section class="slide">

<h2 id="fem:approx:vec:Np1dim">Approximation of general vectors</h2>

<p>
Given a vector \( \f \), find an approximation \( \u\in V \):

<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\end{equation*}
$$
<p>&nbsp;<br>

<p>
We have a set of linearly independent basis vectors
\( \psib_0,\ldots,\psib_N \).
Any \( \u\in V \) can then be written as

<p>&nbsp;<br>
$$ \u = \sum_{j=0}^Nc_j\psib_j$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec13">The least squares method </h2>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
\end{align*}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\end{equation*}
$$
<p>&nbsp;<br>

<p>
After some work we end up with a <em>linear system</em>

<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N\\ 
A_{i,j} &= (\psib_i,\psib_j)\\ 
b_i &= (\psib_i, \f)
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec14">The projection (or Galerkin) method </h2>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>&nbsp;<br>
$$
(\e,\v)=0,\quad \forall\v\in V
$$
<p>&nbsp;<br>

which implies that \( \e \) most be orthogonal to each basis vector:

<p>&nbsp;<br>
$$ (\e,\psib_i)=0,\quad i=0,\ldots,N $$
<p>&nbsp;<br>

<p>
This orthogonality condition is the principle of the projection
(or Galerkin) method. Leads to
the same linear system as in the least squares method.
</section>


<section class="slide">

<h1 id="fem:approx:global">Approximation of a function in a function space</h1>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\}
\end{equation*}
$$
<p>&nbsp;<br>

<p>
Find \( u\in V \) as a linear
combination of the basis functions:

<p>&nbsp;<br>
$$ u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\} $$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="fem:approx:LS">The least squares method can be extended from vectors to functions</h2>

<p>
As in the vector case, minimize the (square) norm
of the error, \( E \), with respect to the coefficients \( c_j \), \( j\in\If \):

<p>&nbsp;<br>
$$
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$ \frac{\partial E}{\partial c_i} = 0,\quad i=\in\If $$
<p>&nbsp;<br>

<p>
But what is the scalar product when \( \baspsi_i \) is a function?

<p>&nbsp;<br>
$$(f,g) = \int_\Omega f(x)g(x)\, dx$$
<p>&nbsp;<br>

(natural extension from Eucledian product \( (\u, \v) = \sum_j u_jv_j \))
</section>


<section class="slide">

<h2 id="___sec17">The least squares method; details </h2>

<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (e,e) = (f-u,f-u) \\ 
 &= (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{align*}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$ \frac{\partial E}{\partial c_i} = 0,\quad i=\in\If $$
<p>&nbsp;<br>

<p>
The computations are <em>identical to the vector case</em>, and consequently
we get a linear system

<p>&nbsp;<br>
$$
\sum_{j\in\If}^N A_{i,j}c_j = b_i,\ i\in\If,\quad
A_{i,j} = (\baspsi_i,\baspsi_j),\ 
b_i = (f,\baspsi_i)
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec18">The projection (or Galerkin) method </h2>

<p>
As before, minimizing \( (e,e) \) is equivalent to

<p>&nbsp;<br>
$$
(e,\baspsi_i)=0,\quad i\in\If
\tag{2}
$$
<p>&nbsp;<br>

<p>
which is equivalent to

<p>&nbsp;<br>
$$
(e,v)=0,\quad\forall v\in V
\tag{3}
$$
<p>&nbsp;<br>

which is the projection (or Galerkin) method.

<p>
The algebra is the same as in the multi-dimensional vector case,
and we get the same linear system as arose from the least squares method.
</section>


<section class="slide">

<h2 id="fem:approx:global:linear">Example: fit a parabola by a straight line; problem</h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Problem.</b>
<p>
Approximate a parabola \( f(x) = 10(x-1)^2 - 1 \) by a straight line.
</div>

<p>&nbsp;<br>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}  \end{equation*}
$$
<p>&nbsp;<br>

That is, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

<p>&nbsp;<br>
$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x
\end{equation*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec20">Example: fit a parabola by a straight line; solution </h2>

<p>&nbsp;<br>
$$
\begin{align*}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3\\ 
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align*}
$$
<p>&nbsp;<br>

Solution of 2x2 linear system:

<p>&nbsp;<br>
$$ c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3} $$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec21">Example: fit a parabola by a straight line; plot </h2>

<p>
<center><p><img src="fig-approx/parabola_ls_linear.png" align="bottom" width=700></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:global:LS:code">Ideas for implementing the least squares method via symbolic computations</h2>

<p>
Consider <em>symbolic computation</em> of the linear system,
where

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>psi</code> is a list of \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>
<p>

Carry out the integrations, solve the linear system, and
return \( u(x)=\sum_jc_j\baspsi_j(x) \)
</section>


<section class="slide">

<h2 id="___sec23">Basic symbolic (SymPy) code for least squares </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares</span>(f, psi, Omega):
    N = <span style="color: #658b00">len</span>(psi) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            A[i,j] = sym.integrate(psi[i]*psi[j],
                                  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            A[j,i] = A[i,j]
        b[i,<span style="color: #B452CD">0</span>] = sym.integrate(psi[i]*f, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi)):
        u += c[i,<span style="color: #B452CD">0</span>]*psi[i]
    <span style="color: #8B008B; font-weight: bold">return</span> u, c
</pre></div>
<p>
Observe: symmetric coefficient matrix so we can halve the integrations.
</section>


<section class="slide">

<h2 id="___sec24">Improved code if symbolic integration fails </h2>

<ul>
 <p><li> If <code>sym.integrate</code> fails, it returns an <code>sym.Integral</code> object.
   We can test on this object and fall back on numerical integration.</li>
 <p><li> We can include a boolean argument <code>symbolic</code> to explicitly choose
   between symbolic and numerical computing.</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares</span>(f, psi, Omega, symbolic=<span style="color: #658b00">True</span>):
    ...
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            integrand = psi[i]*psi[j]
            <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
                I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic <span style="color: #8B008B">or</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
                <span style="color: #228B22"># Could not integrate symbolically,</span>
                <span style="color: #228B22"># fall back on numerical integration</span>
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
            A[i,j] = A[j,i] = I

        integrand = psi[i]*f
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic <span style="color: #8B008B">or</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
        b[i,<span style="color: #B452CD">0</span>] = I
    ...
</pre></div>
</section>


<section class="slide">

<h2 id="___sec25">Plotting of the solution </h2>

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">comparison_plot</span>(f, u, Omega, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn f and u to ordinary Python functions</span>
    f = sym.lambdify([x], f, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    u = sym.lambdify([x], u, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    resolution = <span style="color: #B452CD">401</span>  <span style="color: #228B22"># no of points in plot</span>
    xcoor  = linspace(Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>], resolution)
    exact  = f(xcoor)
    approx = u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #CD5555">&#39;approximation&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    savefig(filename)
</pre></div>
<p>
All code in module <a href="http://tinyurl.com/nm5587k/approx/approx1D.py" target="_self"><tt>approx1D.py</tt></a>
</section>


<section class="slide">

<h2 id="___sec26">Application of the software: fit a parabola by a straight line </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u, c = least_squares(f=f, psi=[<span style="color: #B452CD">1</span>, x], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; comparison_plot(f, u, Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
</pre></div>
<p>
<center><p><img src="fig-approx/parabola_ls_linear.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:global:exact">The approximation is exact if \( f\in V \)</h2>

<ul>
 <p><li> What if we add \( \baspsi_2=x^2 \) to the space \( V \)?</li>
 <p><li> That is, approximating a parabola by any parabola?<br /></li>
 <p><li> (Hopefully we get the exact parabola!)</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u, c = least_squares(f=f, psi=[<span style="color: #B452CD">1</span>, x, x**<span style="color: #B452CD">2</span>], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sym.expand(f)
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
</pre></div>
</section>


<section class="slide">

<h2 id="___sec28">The general result: perfect approximation if \( f\in V \) </h2>

<ul>
 <p><li> What if we use \( \psi_i(x)=x^i \) for \( i=0,\ldots,N=40 \)?</li>
 <p><li> The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">General result.</b>
<p>
If \( f\in V \), least squares and projection/Galerkin give \( u=f \).
</div>
</section>


<section class="slide">

<h2 id="___sec29">Proof of why \( f\in V \) gives exact \( u \) </h2>

<p>
If \( f\in V \), \( f=\sum_{j\in\If}d_j\baspsi_j \), for
some  \( \sequencei{d} \). Then

<p>&nbsp;<br>
$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}
\end{equation*}
$$
<p>&nbsp;<br>

The linear system \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>&nbsp;<br>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>

which implies that \( c_i=d_i \) for \( i\in\If \) and \( u \) is identical to \( f \).
</section>


<section class="slide">

<h2 id="fem:approx:global:illconditioning">Finite-precision in numerical computations; question</h2>

<p>
The previous computations were symbolic. What if we solve the
linear system numerically with standard arrays?

<p>
That is, \( f \) is parabola, but we approximate with

<p>&nbsp;<br>
$$ u(x) = c_0 + c_1x + c_2x^2 + c_3x^3 +\cdots + c_Nx^N $$
<p>&nbsp;<br>

<p>
We expect \( c_2=c_3=\cdots=c_N=0 \) since \( f\in V \) implies \( u=f \).

<p>
Will we get this result with finite precision computer arithmetic?
</section>


<section class="slide">

<h2 id="___sec31">Finite-precision in numerical computations; results </h2>

<p>
<table border="1">
<thead>
<tr><th align="center">exact</th> <td align="center"><code>sympy</code></td> <td align="center"><code>numpy32</code></td> <td align="center"><code>numpy64</code></td> </tr>
</thead>
<tbody>
<tr><td align="right">   9        </td> <td align="right">   9.62                  </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20      </td> <td align="right">   -23.39                </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10       </td> <td align="right">   17.74                 </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -9.19                 </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   5.25                  </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   0.18                  </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -2.48                 </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   1.81                  </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -0.66                 </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   0.12                  </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -0.001                </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</tbody>
</table>
<ul>

<p><li> Column 2: <code>matrix</code> and <code>lu_solve</code> from <code>sympy.mpmath.fp</code></li>

<p><li> Column 3: <code>numpy</code> matrix with 4-byte floats</li>

<p><li> Column 4: <code>numpy</code> matrix with 8-byte floats</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec32">The ill-conditioning is due to almost linearly dependent basis functions for large \( N \) </h2>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But if we plot the approximations they look good (!)</li>
</ul>
<p>

Source or problem: the \( x^i \) functions become almost linearly dependent
as \( i \) grows:

<p>
<center><p><img src="fig-approx/ill_conditioning.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec33">Ill-conditioning: general conclusions </h2>

<ul>

<p><li> Almost linearly dependent basis functions give almost singular matrices</li>

<p><li> Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
    is severely affected by round-off errors</li>

<p><li> The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis</li>

<p><li> Polynomials are fine as basis, but the more orthogonal they are,
    \( (\baspsi_i,\baspsi_j)\approx 0 \), the better</li>
</ul>
</section>


<section class="slide">

<h2 id="fem:approx:global:Fourier">Fourier series approximation; problem and code</h2>

<p>
Let's approximate \( f \) by a typical Fourier series expansion

<p>&nbsp;<br>
$$ u(x) = \sum_i a_i\sin i\pi x = \sum_{j=0}^Nc_j\sin((j+1)\pi x) $$
<p>&nbsp;<br>

<p>
which means that

<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\end{equation*}
$$
<p>&nbsp;<br>

<p>
Computations using the <code>least_squares</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N = <span style="color: #B452CD">3</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> sin, pi
psi = [sin(pi*(i+<span style="color: #B452CD">1</span>)*x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>
Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]
u, c = least_squares(f, psi, Omega)
comparison_plot(f, u, Omega)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec35">Fourier series approximation; plot </h2>

<p>
Left: \( N=3 \), right: \( N=11 \):
<br />

<p>
<center><p><img src="fig-approx/parabola_ls_sines4_12.png" align="bottom" width=900></p></center>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Problem:</b>
<p>
All \( \baspsi_i(0)=0 \) and hence \( u(0)=0 \neq f(0)=9 \). Similar problem at \( x=1 \).
The boundary values of \( u \) are always wrong!
</div>
</section>


<section class="slide">

<h2 id="___sec36">Fourier series approximation; improvements </h2>

<ul>
 <p><li> Considerably improvement with \( N=11 \), but still undesired
   discrepancy at \( x=0 \) and \( x=1 \)</li>
 <p><li> Possible remedy: add a term that leads to correct boundary values</li>
</ul>
<p>&nbsp;<br>
$$ u(x) = {\color{red}f(0)(1-x) + xf(1)} + \sum_{j\in\If} c_j\baspsi_j(x) $$
<p>&nbsp;<br>

The extra terms ensure \( u(0)=f(0) \) and \( u(1)=f(1) \) and
is a strikingly good help to get a good
approximation!
</section>


<section class="slide">

<h2 id="___sec37">Fourier series approximation; final results </h2>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-approx/parabola_ls_sines4_12_wfterm.png" align="bottom" width=900></p></center>
</section>


<section class="slide">

<h2 id="___sec38">Orthogonal basis functions </h2>

<p>
This choice of sine functions as basis functions is popular because

<ul>
 <p><li> the basis functions are orthogonal: \( (\baspsi_i,\baspsi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that we can solve for \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
 <p><li> and what we get is the standard Fourier sine series of \( f \)</li>
</ul>
<p>

<em>In general</em>, for an orthogonal basis, \( A_{i,j} \) is diagonal and we can
easily solve for \( c_i \):

<p>&nbsp;<br>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec39">Function for the least squares method with orthogonal basis functions </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares_orth</span>(f, psi, Omega):
    N = <span style="color: #658b00">len</span>(psi) - <span style="color: #B452CD">1</span>
    A = [<span style="color: #B452CD">0</span>]*(N+<span style="color: #B452CD">1</span>)
    b = [<span style="color: #B452CD">0</span>]*(N+<span style="color: #B452CD">1</span>)
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        A[i] = sym.integrate(psi[i]**<span style="color: #B452CD">2</span>, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
        b[i] = sym.integrate(psi[i]*f,  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
    c = [b[i]/A[i] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(b))]
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi)):
        u += c[i]*psi[i]
    <span style="color: #8B008B; font-weight: bold">return</span> u, c
</pre></div>
</section>


<section class="slide">

<h2 id="___sec40">Function for the least squares method with orthogonal basis functions; symbolic and numerical integration </h2>

<p>
Extensions:

<ul>
 <p><li> We can choose between symbolic or numerical integration (<code>symbolic</code> argument).</li>
 <p><li> If symbolic, we fall back on numerical integration after failure
   (<code>sym.Integral</code> is returned from <code>sym.integrate</code>).</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares_orth</span>(f, psi, Omega, symbolic=<span style="color: #658b00">True</span>):
    ...
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #228B22"># Diagonal matrix term</span>
        A[i] = sym.integrate(psi[i]**<span style="color: #B452CD">2</span>, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))

        <span style="color: #228B22"># Right-hand side term</span>
        integrand = psi[i]*f
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sym.integrate(integrand,  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic <span style="color: #8B008B">or</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;numerical integration of&#39;</span>, integrand
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
        b[i] = I
    ...
</pre></div>
<p>
Assumption above: \( \int_\Omega\basphi_i^2dx \) works symbolically (but there
is no guarantee!)
</section>


<section class="slide">

<h2 id="fem:approx:global:interp">The collocation or interpolation method; ideas and math</h2>

<p>
Here is another idea for approximating \( f(x) \) by \( u(x)=\sum_jc_j\baspsi_j \):

<ul>
 <p><li> Force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \sequencei{x} \)</li>
 <p><li> Then \( u \) is said to <em>interpolate</em> \( f \)</li>
 <p><li> The method is known as <em>interpolation</em> or <em>collocation</em></li>
</ul>
<p>&nbsp;<br>
$$ u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i})
\quad i\in\If,N
$$
<p>&nbsp;<br>

<p>
This is a linear system with no need for integration:

<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= \baspsi_j(\xno{i})\\ 
b_i &= f(\xno{i})
\end{align}
$$
<p>&nbsp;<br>

<p>
No symmetric matrix: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general
</section>


<section class="slide">

<h2 id="___sec42">The collocation or interpolation method; implementation </h2>

<p>
<code>points</code> holds the interpolation/collocation points

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">interpolation</span>(f, psi, points):
    N = <span style="color: #658b00">len</span>(psi) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn psi and f into Python functions</span>
    psi = [sym.lambdify([x], psi[i]) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
    f = sym.lambdify([x], f)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
            A[i,j] = psi[j](points[i])
        b[i,<span style="color: #B452CD">0</span>] = f(points[i])
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi)):
        u += c[i,<span style="color: #B452CD">0</span>]*psi[i](x)
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
</section>


<section class="slide">

<h2 id="___sec43">The collocation or interpolation method; approximating a parabola by linear functions </h2>

<ul>
 <p><li> Potential difficulty: how to choose \( \xno{i} \)?</li>
 <p><li> The results are sensitive to the points!</li>
</ul>
<p>

\( (4/3,5/3) \) vs \( (1,2) \):

<p>
<center><p><img src="fig-approx/parabola_inter.png" align="bottom" width=700></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:global:Lagrange">Lagrange polynomials; motivation and ideas</h2>

<p>
Motivation:

<ul>
 <p><li> The interpolation/collocation method avoids integration</li>
 <p><li> With a diagonal matrix \( A_{i,j} = \baspsi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>
<p>

The <em>Lagrange interpolating polynomials</em> \( \baspsi_j \) have the property that

<p>&nbsp;<br>
$$ \baspsi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j\\ 
0, & i\neq j
\end{array}\right.
$$
<p>&nbsp;<br>

<p>
Hence, \( c_i = f(x_i) \) and

<p>&nbsp;<br>
$$
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
$$
<p>&nbsp;<br>


<ul>
 <p><li> Lagrange polynomials and interpolation/collocation look convenient</li>
 <p><li> Lagrange polynomials are very much used in the finite element method</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec45">Lagrange polynomials; formula and code </h2>

<p>&nbsp;<br>
$$
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N}
$$
<p>&nbsp;<br>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</pre></div>
</section>


<section class="slide">

<h2 id="___sec46">Lagrange polynomials; successful example </h2>

<p>
<center><p><img src="fig-approx/Lagrange_ls_interp_sin_4.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec47">Lagrange polynomials; a less successful example </h2>

<p>
<center><p><img src="fig-approx/Lagrange_interp_abs_8_15.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec48">Lagrange polynomials; oscillatory behavior </h2>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-approx/Lagrange_basis_12.png" align="bottom" width=500></p></center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.
</section>


<section class="slide">

<h2 id="___sec49">Lagrange polynomials; remedy for strong oscillations </h2>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>&nbsp;<br>
$$
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N
$$
<p>&nbsp;<br>

on an interval \( [a,b] \).
</section>


<section class="slide">

<h2 id="___sec50">Lagrange polynomials; recalculation with Chebyshev nodes </h2>

<p>
<center><p><img src="fig-approx/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec51">Lagrange polynomials; less oscillations with Chebyshev nodes </h2>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-approx/Lagrange_basis_Cheb_12.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h1 id="fem:approx:fe">Finite element basis functions</h1>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec53">The basis functions have so far been global: \( \baspsi_i(x) \neq 0 \) almost everywhere </h2>

<p>
<center><p><img src="fig-approx/u_example_sin.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec54">In the finite element method we use basis functions with local support </h2>

<ul>
 <p><li> <em>Local support</em>: \( \baspsi_i(x) \neq 0 \) for \( x \) in a
   small subdomain of \( \Omega \)</li>
 <p><li> Typically hat-shaped</li>
 <p><li> \( u(x) \) based on these \( \baspsi_i \) is a piecewise polynomial
   defined over many (small) subdomains</li>
 <p><li> We introduce \( \basphi_i \) as the name of these finite element hat
   functions (and for now choose \( \baspsi_i=\basphi_i \))</li>
</ul>
<p>

<center><p><img src="fig-approx/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec55">The linear combination of hat functions is a piecewise linear function </h2>

<p>
<center><p><img src="fig-approx/u_example_fe2.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:fe:def:elements:nodes">Elements and nodes</h2>

<p>
Split \( \Omega \) into \( N_e \) non-overlapping subdomains called <em>elements</em>:

<p>&nbsp;<br>
$$
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}
$$
<p>&nbsp;<br>

<p>
On each element, introduce \( N_n \)
points called <em>nodes</em>: \( \xno{0},\ldots,\xno{N_n-1} \)

<ul>
 <p><li> The finite element basis functions are named \( \basphi_i(x) \)</li>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial over each element</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec57">Example on elements with two nodes (P1 elements) </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_P1.png" align="bottom" width=500></p></center>

<p>
Data structure: <code>nodes</code> holds coordinates or nodes, <code>elements</code> holds the
node numbers in each element

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1.2</span>, <span style="color: #B452CD">2.4</span>, <span style="color: #B452CD">3.6</span>, <span style="color: #B452CD">4.8</span>, <span style="color: #B452CD">5</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>]]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec58">Illustration of two basis functions on the mesh </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_2_3.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec59">Example on elements with three nodes (P2 elements) </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.125</span>, <span style="color: #B452CD">0.25</span>, <span style="color: #B452CD">0.375</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.625</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.875</span>, <span style="color: #B452CD">1.0</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">6</span>], [<span style="color: #B452CD">6</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">8</span>]]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec60">Some corresponding basis functions (P2 elements) </h2>

<p>
<center><p><img src="fig-approx/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec61">Examples on elements with four nodes (P3 elements) </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_d4_stretched.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># d+1 nodes per element</span>
num_elements = <span style="color: #B452CD">4</span>
num_nodes = num_elements*d + <span style="color: #B452CD">1</span>
nodes = [i*<span style="color: #B452CD">0.5</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_nodes)]
elements = [[i*d+j <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_elements)]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec62">Some corresponding basis functions (P3 elements) </h2>

<p>
<center><p><img src="fig-approx/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec63">The numbering does not need to be regular from left to right </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_random_numbering.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">1.5</span>, <span style="color: #B452CD">5.5</span>, <span style="color: #B452CD">4.2</span>, <span style="color: #B452CD">0.3</span>, <span style="color: #B452CD">2.2</span>, <span style="color: #B452CD">3.1</span>]
elements = [[<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">0</span>], [<span style="color: #B452CD">5</span>, <span style="color: #B452CD">2</span>]]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec64">Interpretation of the coefficients \( c_i \) </h2>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>&nbsp;<br>
$$
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
$$
<p>&nbsp;<br>

<p>
because \( \basphi_j(\xno{i}) =0 \) if \( i\neq j \) and \( \basphi_i(\xno{i}) =1 \)
</section>


<section class="slide">

<h2 id="___sec65">Properties of the basis functions </h2>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \)</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element</li>
</ul>
<p>

Since \( A_{i,j}=\int\basphi_i\basphi_j\dx \),
<em>most of the elements in the coefficient matrix will be zero</em>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec66">How to construct quadratic \( \basphi_i \) (P2 elements) </h2>

<p>
<center><p><img src="fig-approx/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=500></p></center>

<ol>
<p><li> Associate Lagrange polynomials with the nodes in an element</li>
<p><li> When the polynomial is 1 on the element boundary, combine it
   with the polynomial in the neighboring element that is also 1
   at the same point</li>
</ol>
</section>


<section class="slide">

<h2 id="___sec67">Example on linear \( \basphi_i \) (P1 elements) </h2>

<p>
<center><p><img src="fig-approx/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=500></p></center>

<p>&nbsp;<br>
$$
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1}\\ 
(x - \xno{i-1})/h
& \xno{i-1} \leq x < \xno{i}\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1}\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec68">Example on cubic \( \basphi_i \) (P3 elements) </h2>

<p>
<center><p><img src="fig-approx/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h1 id="fem:approx:global:linearsystem">Calculating the linear system for \( c_i \)</h1>

<p>
<center><p><img src="fig-approx/sparsity_pattern_1D_30unif.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec70">Computing a specific matrix entry (1) </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_2_3.png" align="bottom" width=300></p></center>

<p>
\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
only over element 2. There,

<p>&nbsp;<br>
$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec71">Computing a specific matrix entry (2) </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>&nbsp;<br>
$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{2h}{3}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec72">Calculating a general row in the matrix; figure </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>

<p>&nbsp;<br>
$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec73">Calculating a general row in the matrix; details </h2>

<p>&nbsp;<br>
$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i-1}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\left(\frac{x - x_{i}}{h}\right)}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\end{align*}
$$
<p>&nbsp;<br>


<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) due to symmetry</li>
 <p><li> \( A_{i,i}=2h/3 \) (same calculation as for \( A_{2,2} \))</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (only one element)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec74">Calculation of the right-hand side </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p></center>

<p>&nbsp;<br>
$$
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx
$$
<p>&nbsp;<br>

<p>
Need a specific \( f(x) \) to do more...
</section>


<section class="slide">

<h2 id="___sec75">Specific example with two elements; linear system and solution </h2>

<ul>
 <p><li> \( f(x)=x(1-x) \) on \( \Omega=[0,1] \)</li>
 <p><li> Two equal-sized elements \( [0,0.5] \) and \( [0.5,1] \)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2
\end{equation*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec76">Specific example with two elements; plot </h2>

<p>&nbsp;<br>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$
<p>&nbsp;<br>

<p>
<center><p><img src="fig-approx/fe_p1_x2_2e.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec77">Specific example with four elements; plot </h2>

<p>
<center><p><img src="fig-approx/fe_p1_x2_2e_4e.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec78">Specific example: what about P2 elements? </h2>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Recall: if \( f\in V \), \( u \) becomes exact. When \( f \) is a parabola,
any choice of P2 elements (1 or many) will give \( u=f \) exactly.
The same is true for P3, P4, ... elements since all of them
can represent a 2nd-degree polynomial exactly.
</div>
<!-- end box -->
</section>


<section class="slide">

<h1 id="fem:approx:fe:elementwise">Assembly of elementwise computations</h1>

<p>
<center><p><img src="mov-approx/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=300></p></center>
</section>


<section class="slide">

<h2 id="___sec80">Split the integrals into elementwise integrals </h2>

<p>&nbsp;<br>
$$
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx =
\sum_{e} \int_{\Omega^{(e)}} \basphi_i\basphi_jdx,\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx
$$
<p>&nbsp;<br>

<p>
Important observations:

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> All the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
 <p><li> The element matrix has contributions from the \( \basphi_i \) functions
   associated with the nodes in element</li>
 <p><li> It is convenient to introduce a <em>local numbering</em> of the nodes
   in an element: \( 0,1,\ldots,d \)</li>
</ul>
<p>

<center><p><img src="fig-approx/fe_mesh1D_phi_i_im1.png" align="bottom" width=300></p></center>
</section>


<section class="slide">

<h2 id="___sec81">The element matrix and local vs global node numbers </h2>

<p>&nbsp;<br>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,
\quad r,s\in\Ifd=\{0,\ldots,d\}
$$
<p>&nbsp;<br>

<p>
Now,

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> in an element: \( 0, 1,\ldots, d \)</li>
 <p><li> \( i,j \) run over <em>global node numbers</em> \( i,j\in\If = \{0,1,\ldots,N\} \)</li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \) (math equivalent to <code>i=elements[e][r]</code>)</li>
 <p><li> Add \( \tilde A^{(e)}_{r,s} \) into the global \( A_{i,j} \)
   (<em>assembly</em>)</li>
</ul>
<p>&nbsp;<br>
$$
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec82">Illustration of the matrix assembly: regularly numbered P1 elements </h2>

<p>
<center><p><img src="mov-approx/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=400></p></center>

<p>
<a href="mov-approx/fe_assembly.html" target="_self">Animation</a>
</section>


<section class="slide">

<h2 id="___sec83">Illustration of the matrix assembly: regularly numbered P3 elements </h2>

<p>
<center><p><img src="mov-approx/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=400></p></center>

<p>
<a href="mov-approx/fe_assembly.html" target="_self">Animation</a>
</section>


<section class="slide">

<h2 id="___sec84">Illustration of the matrix assembly: irregularly numbered P1 elements </h2>

<p>
<center><p><img src="mov-approx/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=400></p></center>

<p>
<a href="mov-approx/fe_assembly.html" target="_self">Animation</a>
</section>


<section class="slide">

<h2 id="___sec85">Assembly of the right-hand side </h2>

<p>&nbsp;<br>
$$
b_i = \int_\Omega f(x)\basphi_i(x)dx =
\sum_{e} \int_{\Omega^{(e)}} f(x)\basphi_i(x)dx,\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx
$$
<p>&nbsp;<br>

<p>
<center><p><img src="fig-approx/fe_mesh1D_phi_i_f.png" align="bottom" width=300></p></center>

<p>
Important observations:

<ul>

<p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>

<p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em>
    \( \tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\} \), \( r\in\Ifd \)</li>
</ul>
<p>

Assembly:

<p>&nbsp;<br>
$$
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h1 id="fem:approx:fe:mapping">Mapping to a reference element</h1>

<p>
Instead of computing

<p>&nbsp;<br>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{x_L}^{x_R}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
\end{equation*}
$$
<p>&nbsp;<br>

we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \)
</section>


<section class="slide">

<h2 id="___sec87">We use affine mapping: linear stretch of \( X\in [-1,1] \) to \( x\in [x_L,x_R] \) </h2>

<p>&nbsp;<br>
$$
x = \half (x_L + x_R) + \half (x_R - x_L)X
$$
<p>&nbsp;<br>

or rewritten as
<p>&nbsp;<br>
$$
x = x_m + {\half}hX, \qquad x_m=(x_L+x_R)/2,\quad h=x_R-x_L
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec88">Integral transformation </h2>

<p>
Reference element integration: just change integration variable
from \( x \) to \( X \). Introduce local basis function

<p>&nbsp;<br>
$$
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\underbrace{\frac{dx}{dX}}_{\det J = h/2}dX
= \int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int\limits_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec89">Advantages of the reference element </h2>

<ul>

<p><li> Always the same domain for integration: \( [-1,1] \)</li>

<p><li> We only need formulas for \( \refphi_r(X) \) over one element
    (no <em>piecewise</em> polynomial definition)</li>

<p><li> \( \refphi_r(X) \) is the same for all elements: no dependence on
    element length and location, which is &quot;factored out&quot;
    in the mapping and \( \det J \)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec90">Standardized basis functions for P1 elements </h2>

<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{4}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{5}
\end{align}
$$
<p>&nbsp;<br>

<p>
Note: simple polynomial expressions (no need to consider piecewisely
defined functions)
</section>


<section class="slide">

<h2 id="___sec91">Standardized basis functions for P2 elements </h2>

<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$
<p>&nbsp;<br>

<p>
Easy to generalize to arbitrary order!
</section>


<section class="slide">

<h2 id="___sec92">How to find the polynomial expressions? </h2>

<p>
Three alternatives:

<ol>
<p><li> Map the global basis function \( \basphi_i(x) \) over an element
   to \( X \) coordinates</li>
<p><li> Compute \( \refphi_r(X) \) from scratch using</li>

<ol>

<p><li> a given polynomial order \( d \)</li>

<p><li> \( \refphi_r(X)=1 \) at local node 1</li>

<p><li> \( \refphi_r(X)=1 \) at all other local nodes</li>
</ol>
<p><li> Use formulas for Lagrange interpolating polynomials on the element</li>
</ol>
</section>


<section class="slide">

<h2 id="fem:approx:fe:intg:ref">Integration over a reference element; element matrix</h2>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>&nbsp;<br>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1-X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3}
\tag{6}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6}\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0}
\tag{7}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\tag{8}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec94">Integration over a reference element; element vector </h2>

<p>&nbsp;<br>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \half h x_{m}^{2} + \half h x_{m}
\tag{9}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\half h x_{m}^{2} + \half h x_{m}
\end{align}
$$
<p>&nbsp;<br>

<p>
\( x_m \): element midpoint.
</section>


<section class="slide">

<h2 id="___sec95">Tedious calculations! Let's use symbolic software </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
&gt;&gt;&gt; x, x_m, h, X = sym.symbols(<span style="color: #CD5555">&#39;x x_m h X&#39;</span>)
&gt;&gt;&gt; sym.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>-X)**<span style="color: #B452CD">2</span>, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">3</span>
&gt;&gt;&gt; sym.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>+X)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">6</span>
&gt;&gt;&gt; x = x_m + h/<span style="color: #B452CD">2</span>*X
&gt;&gt;&gt; b_0 = sym.integrate(h/<span style="color: #B452CD">4</span>*x*(<span style="color: #B452CD">1</span>-x)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> b_0
-h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span> + h**<span style="color: #B452CD">2</span>*x_m/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - h*x_m**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + h*x_m/<span style="color: #B452CD">2</span>
</pre></div>
<p>
Can print out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sym.latex(b_0, mode=<span style="color: #CD5555">&#39;plain&#39;</span>)
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">24</span>} h^{<span style="color: #B452CD">3</span>} + \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">6</span>} h^{<span style="color: #B452CD">2</span>} x_{m}
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">12</span>} h^{<span style="color: #B452CD">2</span>} - \half h x_{m}^{<span style="color: #B452CD">2</span>}
+ \half h x_{m}
</pre></div>
</section>


<section class="slide">

<h1 id="___sec96">Implementation </h1>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/nm5587k/approx/fe_approx1D.py" target="_self"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations!</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec97">Compute finite element basis functions in the reference element </h2>

<p>
Let \( \refphi_r(X) \) be a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">phi_r</span>(r, X, d):
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(X, sym.Symbol):
        h = sym.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
        nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #228B22"># assume X is numeric: use floats for nodes</span>
        nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d=<span style="color: #B452CD">1</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    X = sym.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    phi = [phi_r(r, X, d) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi
</pre></div>
</section>


<section class="slide">

<h2 id="___sec98">Compute the element matrix </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sym.zeros((n, n))
    X = sym.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sym.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sym.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</pre></div>
</section>


<section class="slide">

<h2 id="___sec99">Example on symbolic vs numeric element matrix </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; phi
[<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> - X/<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> + X/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec100">Compute the element vector </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sym.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sym.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sym.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sym.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</pre></div>
<p>
Note <code>f.subs('x', x)</code>: replace <code>x</code> by \( x(X) \) such that <code>f</code> contains <code>X</code>
</section>


<section class="slide">

<h2 id="___sec101">Fallback on numerical integration if symbolic integration of \( \int f\refphi_r dx \) fails </h2>

<ul>

<p><li> Element matrix: only polynomials and <code>sympy</code> always succeeds</li>

<p><li> Element vector: \( \int f\refphi \dx \) can fail
    (<code>sympy</code> then returns an <code>Integral</code> object instead of a number)</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        I = sym.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))  <span style="color: #228B22"># try...</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sym.lambdify([X], f*phi[r]*detJ)
            I = sym.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</pre></div>
</section>


<section class="slide">

<h2 id="___sec102">Linear system assembly and solution </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    N_n, N_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    zeros = sym.zeros <span style="color: #8B008B; font-weight: bold">if</span> symbolic <span style="color: #8B008B; font-weight: bold">else</span> np.zeros
    A = zeros((N_n, N_n))
    b = zeros((N_n, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</pre></div>
</section>


<section class="slide">

<h2 id="___sec103">Linear system solution </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)           <span style="color: #228B22"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)  <span style="color: #228B22"># numpy arrays, numerical solve</span>
</pre></div>
<p>
Note: the symbolic computation of <code>A</code>, <code>b</code> and <code>A.LUsolve(b)</code>
can be very tedious.
</section>


<section class="slide">

<h2 id="___sec104">Example on computing symbolic approximations </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sym.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec105">Example on computing numerical approximations </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</pre></div>
</section>


<section class="slide">

<h2 id="fem:approx:fe:A:structure">The structure of the coefficient matrix</h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; N_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(N_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</pre></div>
<p>
Note: do this by hand to understand what is going on!
</section>


<section class="slide">

<h2 id="___sec107">General result: the coefficient matrix is sparse </h2>

<ul>
 <p><li> Sparse = most of the entries are zeros</li>
 <p><li> Below: P1 elements</li>
</ul>
<p>&nbsp;<br>
$$
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec108">Exemplifying the sparsity for P2 elements </h2>

<p>&nbsp;<br>
$$
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 & 0\\ 
  0 & 0 & 2 & 16 & 2 & 0 & 0 & 0 & 0\\ 
  0 & 0 & - 1 & 2 & 8 & 2 & - 1 & 0 & 0\\ 
  0 & 0 & 0 & 0 & 2 & 16 & 2 & 0 & 0\\ 
  0 & 0 & 0 & 0 & - 1 & 2 & 8 & 2 & - 1
  \\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec109">Matrix sparsity pattern for regular/random numbering of P1 elements </h2>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-approx/sparsity_pattern_1D_30.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec110">Matrix sparsity pattern for regular/random numbering of P3 elements </h2>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-approx/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:fe:impl:sparse">Sparse matrix storage and solution</h2>

<p>
The minimum storage requirements for the coefficient matrix \( A_{i,j} \):

<ul>
 <p><li> P1 elements: only 3 nonzero entries per row</li>
 <p><li> P2 elements: only 5 nonzero entries per row</li>
 <p><li> P3 elements: only 7 nonzero entries per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec112">Approximate \( f\sim x^9 \) by various elements; code </h2>

<p>
Compute a mesh with \( N_e \) elements, basis functions of
degree \( d \), and approximate a given symbolic expression
\( f(x) \) by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">4</span>)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec113">Approximate \( f\sim x^9 \) by various elements; plot </h2>

<p>
<center><p><img src="fig-approx/fe_p1_p2_x9_248e.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h1 id="fem:approx:fe:fd">Comparison of finite element and finite difference approximation</h1>

<ul>
 <p><li> Finite difference approximation \( u_i \) of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \)</li>
 <p><li> This is the same as \( u\approx\sum_i c_i\basphi_i \) + interpolation<br />
   (see next slide)</li>
 <p><li> \( u\approx\sum_i c_i\basphi_i \) + Galerkin/projection or least squares method:
   must derive and solve a linear system</li>
 <p><li> What is <em>really</em> the difference in the approximation \( u \)?</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec115">Interpolation/collocation with finite elements </h2>

<p>
Let \( \{\xno{i}\}_{i\in\If} \) be the nodes in the mesh.
Collocation/interpolation means

<p>&nbsp;<br>
$$
u(\xno{i})=f(\xno{i}),\quad i\in\If,
$$
<p>&nbsp;<br>

which translates to

<p>&nbsp;<br>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
<p>&nbsp;<br>

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>&nbsp;<br>
$$
c_i = f(\xno{i})
$$
<p>&nbsp;<br>

<p>
Same result as the standard finite difference approach, but finite elements
define \( u \) also <em>between</em> the \( \xno{i} \) points
</section>


<section class="slide">

<h2 id="___sec116">Galerkin/project and least squares vs collocation/interpolation or finite differences </h2>

<ul>
 <p><li> Scope: work with P1 elements</li>
 <p><li> Use projection/Galerkin or least squares (equivalent)</li>
 <p><li> Interpret the resulting linear system as finite difference equations</li>
</ul>
<p>

The P1 finite element machinery results in a linear system where
equation no \( i \) is

<p>&nbsp;<br>
$$
\frac{h}{6}(u_{i-1} + 4u_i + u_{i+1}) = (f,\basphi_i)
$$
<p>&nbsp;<br>

<p>
Note:

<ul>

<p><li> We have used \( u_i \) for \( c_i \) to make notation similar to
    finite differences</li>

<p><li> The finite difference counterpart is just \( u_i=f_i \)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec117">Expressing the left-hand side in finite difference operator notation </h2>

<p>
Rewrite the left-hand side of finite element equation no \( i \):

<p>&nbsp;<br>
$$
h(u_i + \frac{1}{6}(u_{i-1} - 2u_i + u_{i+1})) = [h(u + \frac{h^2}{6}D_x D_x u)]_i
$$
<p>&nbsp;<br>

This is the standard finite difference approximation of

<p>&nbsp;<br>
$$ h(u + \frac{h^2}{6}u'')$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec118">Treating the right-hand side; Trapezoidal rule </h2>

<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_{\xno{i-1}}^{\xno{i}} f(x)\frac{1}{h} (x - \xno{i-1}) dx
+ \int_{\xno{i}}^{\xno{i+1}} f(x)\frac{1}{h}(1 - (x - x_{i})) dx
$$
<p>&nbsp;<br>

Cannot do much unless we specialize \( f \) or use <em>numerical integration</em>.

<p>
Trapezoidal rule using the nodes:

<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_\Omega f\basphi_i dx\approx h\half(
f(\xno{0})\basphi_i(\xno{0}) + f(\xno{N})\basphi_i(\xno{N}))
+ h\sum_{j=1}^{N-1} f(\xno{j})\basphi_i(\xno{j})
$$
<p>&nbsp;<br>

\( \basphi_i(\xno{j})=\delta_{ij} \), so this formula collapses to one term:

<p>&nbsp;<br>
$$
(f,\basphi_i) \approx hf(\xno{i}),\quad i=1,\ldots,N-1\thinspace.
$$
<p>&nbsp;<br>

<p>
Same result as in collocation (interpolation)
and the finite difference method!
</section>


<section class="slide">

<h2 id="___sec119">Treating the right-hand side; Simpson's rule </h2>

<p>&nbsp;<br>
$$ \int_\Omega g(x)dx \approx \frac{h}{6}\left( g(\xno{0}) +
2\sum_{j=1}^{N-1} g(\xno{j})
+ 4\sum_{j=0}^{N-1} g(\xno{j+\half}) + f(\xno{2N})\right),
$$
<p>&nbsp;<br>

Our case: \( g=f\basphi_i \). The sums collapse because \( \basphi_i=0 \) at most of
the points.

<p>&nbsp;<br>
$$
(f,\basphi_i) \approx \frac{h}{3}(f_{i-\half} + f_i + f_{i+\half})
$$
<p>&nbsp;<br>

<p>
Conclusions:

<ul>

<p><li> While the finite difference method just samples \( f \) at \( x_i \),
    the finite element method applies an average (smoothing) of \( f \) around \( x_i \)</li>

<p><li> On the left-hand side we have a term \( \sim hu'' \), and \( u'' \)
    also contribute to smoothing</li>

<p><li> There is some inherent smoothing in the finite element
    method</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec120">Finite element approximation vs finite differences </h2>

<p>
With Trapezoidal integration of \( (f,\basphi_i) \), the finite element
method essentially solve

<p>&nbsp;<br>
$$
u + \frac{h^2}{6} u'' = f,\quad u'(0)=u'(L)=0,
$$
<p>&nbsp;<br>

by the finite difference method

<p>&nbsp;<br>
$$
[u + \frac{h^2}{6} D_x D_x u = f]_i
$$
<p>&nbsp;<br>

<p>
With Simpson integration of \( (f,\basphi_i) \) we essentially solve

<p>&nbsp;<br>
$$
[u + \frac{h^2}{6} D_x D_x u = \bar f]_i,
$$
<p>&nbsp;<br>

where
<p>&nbsp;<br>
$$ \bar f_i = \frac{1}{3}(f_{i-1/2} + f_i + f_{i+1/2}) $$
<p>&nbsp;<br>

<p>
Note: as \( h\rightarrow 0 \), \( hu''\rightarrow 0 \) and \( \bar f_i\rightarrow f_i \).
</section>


<section class="slide">

<h2 id="___sec121">Making finite elements behave as finite differences </h2>

<ul>
 <p><li> Can we adjust the finite element method so that we do not
   get the extra \( hu'' \) smoothing term and averaging of \( f \)?</li>
 <p><li> This allows finite elements to inherit
   (desired) properties of finite differences</li>
</ul>
<p>

Result:

<ul>
 <p><li> Compute all integrals by the Trapezoidal method and P1 elements</li>
 <p><li> Specifically, the coefficient matrix becomes diagonal (&quot;lumped&quot;) -
   no linear system (!)</li>
 <p><li> Loss of accuracy? The Trapezoidal rule has error \( \Oof{h^2} \),
   the same as the approximation error in P1 elements</li>
</ul>
</section>


<section class="slide">

<h1 id="fem:approx:fe:limitations">Limitations of the nodes and element concepts</h1>

<p>
So far,

<ul>
 <p><li> <em>Nodes</em>: points for defining \( \basphi_i \) and computing \( u \) values</li>
 <p><li> <em>Elements</em>: subdomain (containing a few nodes)</li>
 <p><li> This is a common notion of nodes and elements</li>
</ul>
<p>

One problem:

<ul>
 <p><li> Our algorithms need nodes at the element boundaries</li>
 <p><li> This is often not desirable, so we need to throw the <code>nodes</code> and
   <code>elements</code> arrays away and find a more generalized element concept</li>
</ul>
</section>


<section class="slide">

<h2 id="fem:approx:fe:element">The generalized element concept has cells, vertices, nodes, and degrees of freedom</h2>

<ul>
 <p><li> We introduce <em>cell</em> for the subdomain that we up to now called element</li>
 <p><li> A cell has <em>vertices</em> (interval end points)</li>
 <p><li> <em>Nodes</em> are, almost as before,
   points where we want to compute unknown functions</li>
 <p><li> <em>Degrees of freedom</em> is what the \( c_j \) represent (usually function values
   at nodes)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec124">The concept of a finite element </h2>

<ol>
 <p><li> a <em>reference cell</em> in a local reference coordinate system</li>
 <p><li> a set of <em>basis functions</em> \( \refphi_r \) defined on the cell</li>
 <p><li> a set of <em>degrees of freedom</em> (e.g., function values)
    that uniquely determine
    the basis functions such that \( \refphi_r=1 \) for degree of freedom
    number \( r \) and \( \refphi_r=0 \) for all other degrees of freedom</li>
 <p><li> a mapping between local and global degree of freedom numbers (<em>dof map</em>)</li>
 <p><li> a geometric <em>mapping</em> of the reference cell onto to cell in the physical
    domain: \( [-1,1]\ \Rightarrow\ [x_L,x_R] \)</li>
</ol>
</section>


<section class="slide">

<h2 id="fem:approx:fe:element:impl">Basic data structures: <code>vertices</code>, <code>cells</code>, <code>dof_map</code></h2>

<ul>

<p><li> Cell vertex coordinates: <code>vertices</code> (equals <code>nodes</code> for P1 elements)</li>

<p><li> Element vertices: <code>cells[e][r]</code> holds global vertex number of
    local vertex no <code>r</code> in element <code>e</code> (same as <code>elements</code> for P1 elements)</li>

<p><li> <code>dof_map[e,r]</code> maps local dof <code>r</code> in element <code>e</code> to global dof
    number (same as <code>elements</code> for Pd elements)</li>
</ul>
<p>

The assembly process now applies <code>dof_map</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">A[dof_map[e][r], dof_map[e][s]] += A_e[r,s]
b[dof_map[e][r]] += b_e[r]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec126">Example: data structures for P2 elements </h2>

<p>
<center><p><img src="fig-approx/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">vertices = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.4</span>, <span style="color: #B452CD">1</span>]
cells = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
dof_map = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>]]
</pre></div>
</section>


<section class="slide">

<h2 id="___sec127">Example: P0 elements </h2>

<p>
Example: Same mesh, but \( u \) is piecewise constant in each cell (P0 element).
Same <code>vertices</code> and <code>cells</code>, but

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">dof_map = [[<span style="color: #B452CD">0</span>], [<span style="color: #B452CD">1</span>]]
</pre></div>
<p>
May think of one node in the middle of each element.

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Note:</b>
<p>
We will hereafter work with <code>cells</code>, <code>vertices</code>, and <code>dof_map</code>.
</div>
</section>


<section class="slide">

<h2 id="___sec128">A program with the fundamental algorithmic steps </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Use modified fe_approx1D module</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D_numint</span> <span style="color: #8B008B; font-weight: bold">import</span> *

x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
f = x*(<span style="color: #B452CD">1</span> - x)

N_e = <span style="color: #B452CD">10</span>
<span style="color: #228B22"># Create mesh with P3 (cubic) elements</span>
vertices, cells, dof_map = mesh_uniform(N_e, d=<span style="color: #B452CD">3</span>, Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>])

<span style="color: #228B22"># Create basis functions on the mesh</span>
phi = [basis(<span style="color: #658b00">len</span>(dof_map[e])-<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e)]

<span style="color: #228B22"># Create linear system and solve it</span>
A, b = assemble(vertices, cells, dof_map, phi, f)
c = np.linalg.solve(A, b)

<span style="color: #228B22"># Make very fine mesh and sample u(x) on this mesh for plotting</span>
x_u, u = u_glob(c, vertices, cells, dof_map,
                resolution_per_element=<span style="color: #B452CD">51</span>)
plot(x_u, u)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec129">Approximating a parabola by P0 elements </h2>

<p>
<center><p><img src="fig-approx/fe_p0_x2_4e_8e.png" align="bottom" width=800></p></center>

<p>
The <code>approximate</code> function automates the steps in the previous slide:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D_numint</span> <span style="color: #8B008B; font-weight: bold">import</span> *
x=sym.Symbol(<span style="color: #CD5555">&quot;x&quot;</span>)
<span style="color: #8B008B; font-weight: bold">for</span> N_e <span style="color: #8B008B">in</span> <span style="color: #B452CD">4</span>, <span style="color: #B452CD">8</span>:
    approximate(x*(<span style="color: #B452CD">1</span>-x), d=<span style="color: #B452CD">0</span>, N_e=N_e, Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>])
</pre></div>
</section>


<section class="slide">

<h2 id="fem:approx:fe:element:impl:error">Computing the error of the approximation; principles</h2>

<p>&nbsp;<br>
$$ L^2 \hbox{ error: }\quad ||e||_{L^2} =
\left(\int_{\Omega} e^2 dx\right)^{1/2}$$
<p>&nbsp;<br>

<p>
Accurate approximation of the integral:

<ul>
 <p><li> Sample \( u(x) \) at many points in each element (call <code>u_glob</code>, returns <code>x</code> and <code>u</code>)</li>
 <p><li> Use the Trapezoidal rule based on the samples</li>
 <p><li> It is important to integrate \( u \) accurately <em>over the elements</em></li>
 <p><li> (In a finite difference method we would just sample the mesh point values)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec131">Computing the error of the approximation; details </h2>

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b style="font-weight: bold">Note.</b>
<p>
We need a version of the Trapezoidal rule valid
for non-uniformly spaced points:

<p>&nbsp;<br>
$$ \int_\Omega g(x) dx \approx \sum_{j=0}^{n-1} \half(g(x_j) +
g(x_{j+1}))(x_{j+1}-x_j)$$
<p>&nbsp;<br>
</div>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Given c, compute x and u values on a very fine mesh</span>
x, u = u_glob(c, vertices, cells, dof_map,
              resolution_per_element=<span style="color: #B452CD">101</span>)
<span style="color: #228B22"># Compute the error on the very fine mesh</span>
e = f(x) - u
e2 = e**<span style="color: #B452CD">2</span>
<span style="color: #228B22"># Vectorized Trapezoidal rule</span>
E = np.sqrt(<span style="color: #B452CD">0.5</span>*np.sum((e2[:-<span style="color: #B452CD">1</span>] + e2[<span style="color: #B452CD">1</span>:])*(x[<span style="color: #B452CD">1</span>:] - x[:-<span style="color: #B452CD">1</span>]))
</pre></div>
</section>


<section class="slide">

<h2 id="___sec132">How does the error depend on \( h \) and \( d \)? </h2>

<p>
Theory and experiments show that the least squares or projection/Galerkin
method in combination with Pd elements of equal length \( h \) has an error

<p>&nbsp;<br>
$$
||e||_{L^2} = Ch^{d+1}
$$
<p>&nbsp;<br>

where \( C \) depends on \( f \), but not on \( h \) or \( d \).
</section>


<section class="slide">

<h2 id="___sec133">Cubic Hermite polynomials; definition </h2>

<ul>
 <p><li> Can we construct \( \basphi_i(x) \) with continuous derivatives? Yes!</li>
</ul>
<p>

Consider a reference cell \( [-1,1] \). We introduce two nodes, \( X=-1 \) and \( X=1 \).
The degrees of freedom are

<ul>

<p><li> 0: value of function at \( X=-1 \)</li>

<p><li> 1: value of first derivative at \( X=-1 \)</li>

<p><li> 2: value of function at \( X=1 \)</li>

<p><li> 3: value of first derivative at \( X=1 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Derivatives as unknowns ensure the same \( \basphi_i'(x) \) value at nodes
and thereby continuous derivatives.
</div>
</section>


<section class="slide">

<h2 id="___sec134">Cubic Hermite polynomials; derivation </h2>

<p>
4 constraints on \( \refphi_r \) (1 for dof \( r \), 0 for all others):

<ul>

<p><li> \( \refphi_0(\Xno{0}) = 1 \), \( \refphi_0(\Xno{1}) = 0 \),
    \( \refphi_0'(\Xno{0}) = 0 \), \( \refphi_0'(\Xno{1}) = 0 \)</li>

<p><li> \( \refphi_1'(\Xno{0}) = 1 \), \( \refphi_1'(\Xno{1}) = 0 \),
    \( \refphi_1(\Xno{0}) = 0 \), \( \refphi_1(\Xno{1}) = 0 \)</li>

<p><li> \( \refphi_2(\Xno{1}) = 1 \), \( \refphi_2(\Xno{0}) = 0 \),
    \( \refphi_2'(\Xno{0}) = 0 \), \( \refphi_2'(\Xno{1}) = 0 \)</li>

<p><li> \( \refphi_3'(\Xno{1}) = 1 \), \( \refphi_3'(\Xno{0}) = 0 \),
    \( \refphi_3(\Xno{0}) = 0 \), \( \refphi_3(\Xno{1}) = 0 \)</li>
</ul>
<p>

This gives 4 linear, coupled
equations <em>for each</em> \( \refphi_r \) to determine the 4
coefficients in the cubic polynomial
</section>


<section class="slide">

<h2 id="___sec135">Cubic Hermite polynomials; result </h2>

<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3\\ 
\refphi_1(X) &= -(X+1)(1 - \half(X+1))^2\\ 
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \half(X+1)^3\\ 
\refphi_3(X) &= -\half(X+1)(\half(X+1)^2 - (X+1))\\ 
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h1 id="___sec136">Numerical integration </h1>

<ul>
 <p><li> \( \int_\Omega f\basphi_idx \) must in general be computed by numerical integration</li>
 <p><li> Numerical integration is often used for the matrix too</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec137">Common form of a numerical integration rule </h2>

<p>&nbsp;<br>
$$
\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_jg(\bar X_j),
$$
<p>&nbsp;<br>

where

<ul>
 <p><li> \( \bar X_j \) are <em>integration points</em></li>
 <p><li> \( w_j \) are <em>integration weights</em></li>
</ul>
<p>

Different rules correspond to different choices of points and weights
</section>


<section class="slide">

<h2 id="___sec138">The Midpoint rule </h2>

<p>
Simplest possibility: the Midpoint rule,

<p>&nbsp;<br>
$$
\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,
$$
<p>&nbsp;<br>

<p>
Exact for linear integrands
</section>


<section class="slide">

<h2 id="fem:approx:fe:numint1">Newton-Cotes rules apply the nodes</h2>

<ul>
 <p><li> Idea: use a fixed, uniformly distributed set of points in \( [-1,1] \)</li>
 <p><li> The points often coincides with nodes</li>
 <p><li> Very useful for making \( \basphi_i\basphi_j=0 \) and get diagonal
   (&quot;mass&quot;) matrices (&quot;lumping&quot;)</li>
</ul>
<p>

The Trapezoidal rule:

<p>&nbsp;<br>
$$
\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,
$$
<p>&nbsp;<br>

<p>
Simpson's rule:

<p>&nbsp;<br>
$$
\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),
$$
<p>&nbsp;<br>

where

<p>&nbsp;<br>
$$
\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec140">Gauss-Legendre rules apply optimized points </h2>

<ul>
 <p><li> Optimize the location of points to get higher accuracy</li>
 <p><li> Gauss-Legendre rules (quadrature) adjust points and weights to
   integrate polynomials exactly</li>
</ul>
<p>&nbsp;<br>
$$
\begin{align}
M=1&:\quad \bar X_0=-\frac{1}{\sqrt{3}},\ 
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1\\ 
M=2&:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\ 
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}
\end{align}
$$
<p>&nbsp;<br>


<ul>
 <p><li> \( M=1 \): integrates 3rd degree polynomials exactly</li>
 <p><li> \( M=2 \): integrates 5th degree polynomials exactly</li>
 <p><li> In general, \( M \)-point rule integrates a polynomial
   of degree \( 2M+1 \) exactly.</li>
</ul>
<p>

See <a href="http://tinyurl.com/nm5587k/approx/numint.py" target="_self"><tt>numint.py</tt></a> for a large collection of Gauss-Legendre rules.
</section>


<section class="slide">

<h1 id="fem:approx:2D">Approximation of functions in 2D</h1>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Extensibility of 1D ideas.</b>
<p>
All the concepts and algorithms developed for approximation of 1D functions
\( f(x) \) can readily be extended to 2D functions \( f(x,y) \) and 3D functions
\( f(x,y,z) \). Key formulas stay the same.
</div>
</section>


<section class="slide">

<h2 id="___sec142">Quick overview of the 2D case </h2>

<p>
Inner product in 2D:

<p>&nbsp;<br>
$$
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
$$
<p>&nbsp;<br>

<p>
Least squares and project/Galerkin lead to a linear system

<p>&nbsp;<br>
$$
\begin{align*}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)\\ 
b_i &= (f,\baspsi_i)
\end{align*}
$$
<p>&nbsp;<br>

<p>
Challenge: How to construct 2D basis functions \( \baspsi_i(x,y) \)?
</section>


<section class="slide">

<h2 id="fem:approx:2D:global">2D basis functions as tensor products of 1D functions</h2>

<p>
Use a 1D basis for \( x \) variation and a similar for \( y \) variation:

<p>&nbsp;<br>
$$
\begin{align}
V_x &= \mbox{span}\{ \hat\baspsi_0(x),\ldots,\hat\baspsi_{N_x}(x)\}
\tag{10}\\ 
V_y &= \mbox{span}\{ \hat\baspsi_0(y),\ldots,\hat\baspsi_{N_y}(y)\}
\tag{11}
\end{align}
$$
<p>&nbsp;<br>

<p>
The 2D vector space can be defined as a <em>tensor product</em> \( V = V_x\otimes V_y \)
with basis functions

<p>&nbsp;<br>
$$
\baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y)
\quad p\in\Ix,q\in\Iy\tp
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec144">Tensor products </h2>

<p>
Given two vectors \( a=(a_0,\ldots,a_M) \) and \( b=(b_0,\ldots,b_N) \)
their <em>outer tensor product</em>, also called the <em>dyadic product</em>,
is \( p=a\otimes b \), defined through

<p>&nbsp;<br>
$$ p_{i,j}=a_ib_j,\quad i=0,\ldots,M,\ j=0,\ldots,N\tp$$
<p>&nbsp;<br>

Note: \( p \) has two indices (as a matrix or two-dimensional array)

<p>
Example: 2D basis as tensor product of 1D spaces,

<p>&nbsp;<br>
$$ \baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad p\in\Ix,q\in\Iy$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec145">Double or single index? </h2>

<p>
The 2D basis can employ a double index and double sum:

<p>&nbsp;<br>
$$ u = \sum_{p\in\Ix}\sum_{q\in\Iy} c_{p,q}\baspsi_{p,q}(x,y)
$$
<p>&nbsp;<br>

<p>
Or just a single index:

<p>&nbsp;<br>
$$ u = \sum_{j\in\If} c_j\baspsi_j(x,y)$$
<p>&nbsp;<br>

<p>
with an index mapping \( (p,q)\rightarrow i \):

<p>&nbsp;<br>
$$
\baspsi_i(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad i=p (N_y+1) + q\hbox{ or } i=q (N_x+1) + p
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec146">Example on 2D (bilinear) basis functions; formulas </h2>

<p>
In 1D we use the basis

<p>&nbsp;<br>
$$ \{ 1, x \} $$
<p>&nbsp;<br>

<p>
2D tensor product (all combinations):

<p>&nbsp;<br>
$$ \baspsi_{0,0}=1,\quad \baspsi_{1,0}=x, \quad \baspsi_{0,1}=y,
\quad \baspsi_{1,1}=xy
$$
<p>&nbsp;<br>

or with a single index:

<p>&nbsp;<br>
$$ \baspsi_0=1,\quad \baspsi_1=x, \quad \baspsi_2=y,\quad\baspsi_3 =xy
$$
<p>&nbsp;<br>

<p>
See notes for details of a hand-calculation.
</section>


<section class="slide">

<h2 id="___sec147">Example on 2D (bilinear) basis functions; plot </h2>

<p>
Quadratic \( f(x,y) = (1+x^2)(1+2y^2) \) (left), bilinear \( u \) (right):

<p>
<center><p><img src="fig-approx/approx2D_bilinear.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="fem:approx:2D:global:code">Implementation; principal changes to the 1D code</h2>

<p>
Very small modification of <code>approx1D.py</code>:

<ul>
 <p><li> <code>Omega = [[0, L_x], [0, L_y]]</code></li>
 <p><li> Symbolic integration in 2D</li>
 <p><li> Construction of 2D (tensor product) basis functions</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec149">Implementation; 2D integration </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

integrand = psi[i]*psi[j]
I = sym.integrate(integrand,
                 (x, Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">1</span>]),
                 (y, Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">1</span>]))

<span style="color: #228B22"># Fall back on numerical integration if symbolic integration</span>
<span style="color: #228B22"># was unsuccessful</span>
<span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
    integrand = sym.lambdify([x,y], integrand)
    I = sym.mpmath.quad(integrand,
                       [Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">1</span>]],
                       [Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">1</span>]])
</pre></div>
</section>


<section class="slide">

<h2 id="___sec150">Implementation; 2D basis functions </h2>

<p>
Tensor product of 1D &quot;Taylor-style&quot; polynomials \( x^i \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">taylor</span>(x, y, Nx, Ny):
    <span style="color: #8B008B; font-weight: bold">return</span> [x**i*y**j <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nx+<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ny+<span style="color: #B452CD">1</span>)]
</pre></div>
<p>
Tensor product of 1D sine functions \( \sin((i+1)\pi x) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">sines</span>(x, y, Nx, Ny):
    <span style="color: #8B008B; font-weight: bold">return</span> [sym.sin(sym.pi*(i+<span style="color: #B452CD">1</span>)*x)*sym.sin(sym.pi*(j+<span style="color: #B452CD">1</span>)*y)
            <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nx+<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ny+<span style="color: #B452CD">1</span>)]
</pre></div>
<p>
Complete code in
<a href="http://tinyurl.com/nm5587k/approx/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a>
</section>


<section class="slide">

<h2 id="___sec151">Implementation; application </h2>

<p>
\( f(x,y) = (1+x^2)(1+2y^2) \)

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx2D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; f = (<span style="color: #B452CD">1</span>+x**<span style="color: #B452CD">2</span>)*(<span style="color: #B452CD">1</span>+<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span>)
&gt;&gt;&gt; psi = taylor(x, y, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
&gt;&gt;&gt; Omega = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">8</span>*x*y - <span style="color: #B452CD">2</span>*x/<span style="color: #B452CD">3</span> + <span style="color: #B452CD">4</span>*y/<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sym.expand(f)
<span style="color: #B452CD">2</span>*x**<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>
</pre></div>
</section>


<section class="slide">

<h2 id="___sec152">Implementation; trying a perfect expansion </h2>

<p>
Add higher powers to the basis such that \( f\in V \):

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; psi = taylor(x, y, <span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>)
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">2</span>*x**<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u-f
<span style="color: #B452CD">0</span>
</pre></div>
<p>
Expected: \( u=f \) when \( f\in V \)
</section>


<section class="slide">

<h2 id="fem:approx:3D:global">Generalization to 3D</h2>

<p>
Key idea:

<p>&nbsp;<br>
$$ V = V_x\otimes V_y\otimes V_z$$
<p>&nbsp;<br>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Repeated outer tensor product of multiple vectors.</b>
<p>&nbsp;<br>
$$
\begin{align*}
a^{(q)} &= (a^{(q)}_0,\ldots,a^{(q)}_{N_q}),\quad q=0,\ldots,m\\ 
p &= a^{(0)}\otimes\cdots\otimes a^{(m)}\\ 
p_{i_0,i_1,\ldots,i_m} &= a^{(0)}_{i_1}a^{(1)}_{i_1}\cdots a^{(m)}_{i_m}
\end{align*}
$$
<p>&nbsp;<br>


</div>

<p>&nbsp;<br>
$$
\begin{align*}
\baspsi_{p,q,r}(x,y,z) &= \hat\baspsi_p(x)\hat\baspsi_q(y)\hat\baspsi_r(z)\\ 
u(x,y,z) &= \sum_{p\in\Ix}\sum_{q\in\Iy}\sum_{r\in\Iz} c_{p,q,r}
\baspsi_{p,q,r}(x,y,z)
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h1 id="___sec154">Finite elements in 2D and 3D </h1>

<p>
The two great advantages of the finite element method:

<ul>

<p><li> Can handle complex-shaped domains in 2D and 3D</li>

<p><li> Can easily provide higher-order polynomials in the approximation</li>
</ul>
<p>

Finite elements in 1D: mostly for learning, insight, debugging
</section>


<section class="slide">

<h2 id="___sec155">Examples on cell types </h2>

<p>
2D:

<ul>
 <p><li> triangles</li>
 <p><li> quadrilaterals</li>
</ul>
<p>

3D:

<ul>
 <p><li> tetrahedra</li>
 <p><li> hexahedra</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec156">Rectangular domain with 2D P1 elements </h2>

<p>
<center><p><img src="fig-approx/mesh2D_rect_P1.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="___sec157">Deformed geometry with 2D P1 elements </h2>

<p>
<center><p><img src="fig-approx/mesh2D_quarter_circle.png" align="bottom" width=600></p></center>
</section>


<section class="slide">

<h2 id="___sec158">Rectangular domain with 2D Q1 elements </h2>

<p>
<center><p><img src="fig-approx/mesh2D_rect_Q1.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec159">Basis functions over triangles in the physical domain </h2>

<p>
The P1 triangular 2D element: \( u \) is linear \( ax + by + c \) over each
triangular cell

<p>
<center><p><img src="fig-approx/demo2D_4x3r.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec160">Basic features of 2D elements </h2>

<ul>
 <p><li> Cells = triangles</li>
 <p><li> Vertices = corners of the cells</li>
 <p><li> Nodes = vertices</li>
 <p><li> Degrees of freedom = function values at the nodes</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec161">Linear mapping of reference element onto general triangular cell </h2>

<p>
<center><p><img src="fig-approx/ElmT3n2D_map.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec162">\( \basphi_i \): pyramid shape, composed of planes </h2>

<ul>
 <p><li> \( \basphi_i(x,y) \) varies linearly over each cell</li>
 <p><li> \( \basphi_i=1 \) at vertex (node) \( i \), 0 at all other vertices (nodes)</li>
</ul>
<p>

<center><p><img src="fig-approx/demo2D_basisfunc.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec163">Element matrices and vectors </h2>

<ul>
 <p><li> As in 1D, the contribution from one cell to the matrix involves
   just a few entries, collected in the element matrix and vector</li>
 <p><li> \( \basphi_i\basphi_j\neq 0 \) only if \( i \) and \( j \) are
   degrees of freedom (vertices/nodes) in the same element</li>
 <p><li> The 2D P1 element has a \( 3\times 3 \) element matrix</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec164">Basis functions over triangles in the reference cell </h2>

<p>
<center><p><img src="fig-approx/fenics-book/elements/P1_2d.png" align="bottom" width=100></p></center>

<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y\\ 
\refphi_1(X,Y) &= X\\ 
\refphi_2(X,Y) &= Y
\end{align}
$$
<p>&nbsp;<br>

<p>
Higher-degree \( \refphi_r \) introduce more nodes (dof = node values)
</section>


<section class="slide">

<h2 id="___sec165">2D P1, P2, P3, P4, P5, and P6 elements </h2>

<p>
<center><p><img src="fig-approx/fenics-book/elements/P1-6_2d.png" align="bottom" width=320></p></center>
</section>


<section class="slide">

<h2 id="___sec166">P1 elements in 1D, 2D, and 3D </h2>

<p>
<center><p><img src="fig-approx/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=320></p></center>
</section>


<section class="slide">

<h2 id="___sec167">P2 elements in 1D, 2D, and 3D </h2>

<p>
<center><p><img src="fig-approx/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=320></p></center>

<ul>
 <p><li> Interval, triangle, tetrahedron: <em>simplex</em> element
   (plural quick-form: <em>simplices</em>)</li>
 <p><li> Side of the cell is called <em>face</em></li>
 <p><li> Thetrahedron has also <em>edges</em></li>
</ul>
</section>


<section class="slide">

<h2 id="___sec168">Affine mapping of the reference cell; formula </h2>

<p>
Mapping of local \( \X = (X,Y) \) coordinates in the reference cell to
global, physical \( \x = (x,y) \) coordinates:

<p>&nbsp;<br>
$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)}
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>

<p>
where

<ul>

<p><li> \( r \) runs over the local vertex numbers in the cell</li>

<p><li> \( \xdno{i} \) are the \( (x,y) \) coordinates of vertex \( i \)</li>

<p><li> \( \refphi_r^{(1)} \) are P1 basis functions</li>
</ul>
<p>

This mapping preserves the straight/planar faces and edges.
</section>


<section class="slide">

<h2 id="___sec169">Affine mapping of the reference cell; figure </h2>

<p>
<center><p><img src="fig-approx/ElmT3n2D_map.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec170">Isoparametric mapping of the reference cell </h2>

<p>
Idea: Use the basis functions
of the element (not only the P1 functions)
to map the element

<p>&nbsp;<br>
$$
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)}
$$
<p>&nbsp;<br>

<p>
Advantage: higher-order polynomial basis functions now map the
reference cell to a <em>curved</em> triangle or tetrahedron.

<p>
<center><p><img src="fig-approx/ElmT6n2D_map.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec171">Computing integrals </h2>

<p>
Integrals must be transformed from \( \Omega^{(e)} \) (physical cell)
to \( \tilde\Omega^r \) (reference cell):

<p>&nbsp;<br>
$$
\begin{align}
\int_{\Omega^{(e)}}\basphi_i (\x) \basphi_j (\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) \refphi_j (\X)
\det J\, \dX\\ 
\int_{\Omega^{(e)}}\basphi_i (\x) f(\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) f(\x(\X)) \det J\, \dX
\end{align}
$$
<p>&nbsp;<br>

where \( \dx = dx dy \) or \( \dx = dxdydz \) and \( \det J \) is the determinant of the
Jacobian of the mapping \( \x(\X) \).

<p>&nbsp;<br>
$$
J = \left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
\frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
\end{array}\right], \quad
\det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
- \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
$$
<p>&nbsp;<br>

<p>
Affine mapping
<a href="#mjx-eqn-12">(12)</a>: \( \det J=2\Delta \), \( \Delta = \hbox{cell volume} \)
</section>


<section class="slide">

<h2 id="___sec172">Remark on going from 1D to 2D/3D </h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Finite elements in 2D and 3D builds on the same
<em>ideas</em> and <em>concepts</em> as in 1D, but there is simply much
more to compute because the
specific mathematical formulas in 2D and 3D are more complicated
and the book keeping with dof maps also gets more complicated.
The manual work is tedious, lengthy, and error-prone
so automation by the computer is a must.
</div>
</section>




<footer>
<!-- Here goes a footer -->
</footer>

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script> -->

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
