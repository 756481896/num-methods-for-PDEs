<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,normal equations,$A^TA=A^Tb$ (normal equations),Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec23'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec24'),
              ('Implementation', 3, None, '___sec25'),
              ('Example', 3, None, '___sec26'),
              ('Remark', 3, None, '___sec27'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec29'),
              ('Successful example', 3, None, '___sec30'),
              ('Less successful example', 3, None, '___sec31'),
              ('Remedy for strong oscillations', 3, None, '___sec32'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec35'),
              ('The basis functions', 2, None, '___sec36'),
              ('Construction principles', 3, None, '___sec37'),
              ('Properties of $\\basphi_i$', 3, None, '___sec38'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec39'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec40'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec41'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec43'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec44'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec46'),
              ('Assembly of element matrices', 3, None, '___sec47'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec48'),
              ('The element vector', 3, None, '___sec49'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec51'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec52'),
              ('Formulas for local basis functions', 3, None, '___sec53'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fem',
               'fem:deq:1D:approx:fem_vs_fem'),
              ('Computations in physical space', 3, None, '___sec68'),
              ('Elementwise computations', 3, None, '___sec69'),
              ('Terminology', 3, None, '___sec70'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec77'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec79'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec82'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec85'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec86'),
              ('Element matrices and vectors', 3, None, '___sec87'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec88'),
              ('Affine mapping of the reference cell', 2, None, '___sec89'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec90'),
              ('Computing integrals', 2, None, '___sec91'),
              ('Exercises', 1, None, '___sec92'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec99'),
              ('Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec101'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec118')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0005"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:approx:fe:impl">Implementation</h1>

<p>
Based on the experience from the previous example, it makes
sense to write some code to automate the analytical integration process
for any choice of finite element basis functions. In addition,
we can automate the assembly process and the solution of the linear system.
Another advantage is that the
code for these purposes document all details of all
steps in the finite element computational machinery.
The complete code can be found in the module file
<a href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py" target="_self"><tt>fe_approx1D.py</tt></a>.

<h2 id="fem:approx:fe:impl:intg">Integration</h2>

<p>
First we need a Python function for
defining \( \refphi_r(X) \) in terms of a Lagrange polynomial
of degree <code>d</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d, point_distribution=<span style="color: #CD5555">&#39;uniform&#39;</span>, symbolic=<span style="color: #658b00">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return all local basis function phi as functions of the</span>
<span style="color: #CD5555">    local point X in a 1D element with d+1 nodes.</span>
<span style="color: #CD5555">    If symbolic=True, return symbolic expressions, else</span>
<span style="color: #CD5555">    return Python functions of X.</span>
<span style="color: #CD5555">    point_distribution can be &#39;uniform&#39; or &#39;Chebyshev&#39;.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    X = sym.symbols(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> d == <span style="color: #B452CD">0</span>:
        phi_sym = [<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">if</span> point_distribution == <span style="color: #CD5555">&#39;uniform&#39;</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
	        <span style="color: #228B22"># Compute symbolic nodes</span>
                h = sym.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
                nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
            <span style="color: #8B008B; font-weight: bold">else</span>:
                nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
        <span style="color: #8B008B; font-weight: bold">elif</span> point_distribution == <span style="color: #CD5555">&#39;Chebyshev&#39;</span>:
            <span style="color: #228B22"># Just numeric nodes</span>
            nodes = Chebyshev_nodes(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d)

        phi_sym = [Lagrange_polynomial(X, r, nodes)
                   <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #228B22"># Transform to Python functions</span>
    phi_num = [sym.lambdify([X], phi_sym[r]) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi_sym <span style="color: #8B008B; font-weight: bold">if</span> symbolic <span style="color: #8B008B; font-weight: bold">else</span> phi_num

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</pre></div>
<p>
Observe how we construct the <code>phi_sym</code> list to be
symbolic expressions for \( \refphi_r(X) \) with <code>X</code> as a
<code>Symbol</code> object from <code>sympy</code>. Also note that the
<code>Lagrange_polynomial</code> function (here simply copied
from the section <a href="._approx-solarized003.html#fem:approx:global:Fourier">Fourier series</a>)
works with both symbolic and numeric variables.

<p>
Now we can write the function that computes the element matrix
with a list of symbolic expressions for \( \basphi_r \)
(<code>phi = basis(d, symbolic=True)</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sym.zeros((n, n))
    X = sym.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sym.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sym.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</pre></div>
<p>
In the symbolic case (<code>symbolic</code> is <code>True</code>),
we introduce the element length as a symbol
<code>h</code> in the computations. Otherwise, the real numerical value
of the element interval <code>Omega_e</code>
is used and the final matrix elements are numbers,
not symbols.
This functionality can be demonstrated:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; phi
[-X/<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>, X/<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</pre></div>
<p>
The computation of the element vector is done by a similar
procedure:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sym.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sym.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sym.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sym.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</pre></div>
<p>
Here we need to replace the symbol <code>x</code> in the expression for <code>f</code>
by the mapping formula such that <code>f</code> can be integrated
in terms of \( X \), cf. the formula
\( \tilde b^{(e)}_{r} = \int_{-1}^1 f(x(X))\refphi_r(X)\frac{h}{2}\dX \).

<p>
The integration in the element matrix function involves only products
of polynomials, which <code>sympy</code> can easily deal with, but for the
right-hand side <code>sympy</code> may face difficulties with certain types of
expressions <code>f</code>. The result of the integral is then an <code>Integral</code>
object and not a number or expression
as when symbolic integration is successful.
It may therefore be wise to introduce a fall back on numerical
integration. The symbolic integration can also spend considerable time
before reaching an unsuccessful conclusion, so we may also introduce a parameter
<code>symbolic</code> to turn symbolic integration on and off:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sym.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic <span style="color: #8B008B">or</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sym.lambdify([X], f*phi[r]*detJ)
            I = sym.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</pre></div>
<p>
Numerical integration requires that the symbolic
integrand is converted
to a plain Python function (<code>integrand</code>) and that
the element length <code>h</code> is a real number.

<h2 id="fem:approx:fe:impl:linsys">Linear system assembly and solution</h2>

<p>
The complete algorithm
for computing and assembling the elementwise contributions
takes the following form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    N_n, N_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        A = sym.zeros((N_n, N_n))
        b = sym.zeros((N_n, <span style="color: #B452CD">1</span>))    <span style="color: #228B22"># note: (N_n, 1) matrix</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        A = np.zeros((N_n, N_n))
        b = np.zeros(N_n)
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</pre></div>
<p>
The <code>nodes</code> and <code>elements</code> variables represent the finite
element mesh as explained earlier.

<p>
Given the coefficient matrix <code>A</code> and the right-hand side <code>b</code>,
we can compute the coefficients \( \sequencej{c} \) in the expansion
\( u(x)=\sum_jc_j\basphi_j \) as the solution vector <code>c</code> of the linear
system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)
</pre></div>
<p>
When <code>A</code> and <code>b</code> are <code>sympy</code> arrays,
the solution procedure implied by <code>A.LUsolve</code> is symbolic.
Otherwise, <code>A</code> and <code>b</code> are <code>numpy</code> arrays and a standard
numerical solver is called.
The symbolic version is suited for small problems only
(small \( N \) values) since the calculation time becomes prohibitively large
otherwise. Normally, the symbolic <em>integration</em> will be more time
consuming in small problems than the symbolic <em>solution</em> of the linear system.

<h2 id="fem:approx:fe:impl:ex1:symbolic">Example on computing symbolic approximations</h2>

<p>
We can exemplify the use of <code>assemble</code> on the computational
case from the section <a href="._approx-solarized004.html#fem:approx:global:linearsystem">Calculating the linear system</a> with
two P1 elements (linear basis functions) on the domain \( \Omega=[0,1] \).
Let us first work with a symbolic element length:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sym.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</pre></div>

<h2 id="fem:approx:fe:impl:ex1:collocation">Using interpolation instead of least squares</h2>

<p>
As an alternative to the least squares formulation,
we may compute the <code>c</code> vector based on
the interpolation method from the section <a href="._approx-solarized003.html#fem:approx:global:interp">The interpolation (or collocation) method</a>,
using finite element basis functions.
Choosing the nodes as interpolation points, the method can be written as

$$ u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) = f(\xno{i}),\quad
i\in\If\tp$$

The coefficient matrix \( A_{i,j}=\basphi_j(\xno{i}) \) becomes
the identity matrix because basis function number \( j \) vanishes
at all nodes, except node \( i \): \( \basphi_j(\xno{i})=\delta_{ij} \).
Therefore, \( c_i = f(\xno{i}) \).

<p>
The associated <code>sympy</code> calculations are

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; fn = sym.lambdify([x], f)
&gt;&gt;&gt; c = [fn(xc) <span style="color: #8B008B; font-weight: bold">for</span> xc <span style="color: #8B008B">in</span> nodes]
&gt;&gt;&gt; c
[<span style="color: #B452CD">0</span>, h*(<span style="color: #B452CD">1</span> - h), <span style="color: #B452CD">2</span>*h*(<span style="color: #B452CD">1</span> - <span style="color: #B452CD">2</span>*h)]
</pre></div>
<p>
These expressions are much simpler than those based on least squares
or projection in combination with finite element basis functions.
However, which of the two methods that is most appropriate for a given
task is problem-dependent, so we need both methods in our toolbox.

<h2 id="fem:approx:fe:impl:ex1:numeric">Example on computing numerical approximations</h2>

<p>
The numerical computations corresponding to the
symbolic ones in the section <a href="#fem:approx:fe:impl:ex1:symbolic">Example on computing symbolic approximations</a>
(still done by <code>sympy</code> and the <code>assemble</code> function) go as follows:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</pre></div>
<p>
The <code>fe_approx1D</code> module contains functions for generating the
<code>nodes</code> and <code>elements</code> lists for equal-sized elements with
any number of nodes per element. The coordinates in <code>nodes</code>
can be expressed either through the element length symbol <code>h</code>
(<code>symbolic=True</code>) or by real numbers (<code>symbolic=False</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes, elements = mesh_uniform(N_e=<span style="color: #B452CD">10</span>, d=<span style="color: #B452CD">3</span>, Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>],
                               symbolic=<span style="color: #658b00">True</span>)
</pre></div>
<p>
There is also a function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">approximate</span>(f, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
</pre></div>
<p>
which computes a mesh with <code>N_e</code> elements, basis functions of
degree <code>d</code>, and approximates a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \).
When <code>symbolic</code> is <code>False</code>, \( u(x) = \sum_jc_j\basphi_j(x) \)
can be computed at a (large)
number of points and plotted together with \( f(x) \). The construction
of \( u \) points from the solution vector <code>c</code> is done
elementwise by evaluating \( \sum_rc_r\refphi_r(X) \) at a (large)
number of points in each element in the local coordinate system,
and the discrete \( (x,u) \) values on
each element are stored in separate arrays that are finally
concatenated to form a global array for \( x \) and for \( u \).
The details are found in the <code>u_glob</code> function in
<code>fe_approx1D.py</code>.

<h2 id="fem:approx:fe:A:structure">The structure of the coefficient matrix</h2>

<p>
Let us first see how the global matrix looks like if we assemble
symbolic element matrices, expressed in terms of <code>h</code>, from
several elements:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; N_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(N_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</pre></div>
<p>
The reader is encouraged to assemble the element matrices by hand and verify
this result, as this exercise will give a hands-on understanding of
what the assembly is about. In general we have a coefficient matrix that is
tridiagonal:

$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\tag{45}
\end{equation}
$$

<p>
The structure of the right-hand side is more difficult to reveal since
it involves an assembly of elementwise integrals of
\( f(x(X))\refphi_r(X)h/2 \), which obviously depend on the
particular choice of \( f(x) \).
Numerical integration can give some insight into the nature of
the right-hand side. For this purpose it
is easier to look at the integration in \( x \) coordinates, which
gives the general formula <a href="._approx-solarized004.html#mjx-eqn-33">(33)</a>.
For equal-sized elements of length \( h \), we can apply the
Trapezoidal rule at the global node points to arrive at

$$
\begin{align}
b_i &= h\left( \half \basphi_i(\xno{0})f(\xno{0}) +
\half \basphi_i(\xno{N})f(\xno{N}) + \sum_{j=1}^{N-1}
\basphi_i(\xno{j})f(\xno{j})\right)\\ 
& =
\left\lbrace\begin{array}{ll}
\half hf(x_i),& i=0\hbox{ or }i=N,\\ 
h f(x_i), & 1 \leq i \leq N-1
\end{array}\right.
\end{align}
$$

The reason for this simple formula is just that \( \basphi_i \) is either
0 or 1 at the nodes and 0 at all but one of them.

<p>
Going to P2 elements (<code>d=2</code>) leads
to the element matrix

$$
\begin{equation}
A^{(e)} = \frac{h}{30}
\left(\begin{array}{ccc}
4 & 2 & -1\\ 
2 & 16 & 2\\ 
-1 & 2 & 4
\end{array}\right)
\end{equation}
$$

and the following global matrix, assembled here from four elements:

$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$

In general, for \( i \) odd we have the nonzeroes

$$
\begin{equation*} A_{i,i-2} = -1,\quad A_{i-1,i}=2,\quad A_{i,i} = 8,\quad A_{i+1,i}=2,
\quad A_{i+2,i}=-1,\end{equation*}
$$

multiplied by \( h/30 \), and for \( i \) even we have the nonzeros

$$
\begin{equation*} A_{i-1,i}=2,\quad A_{i,i} = 16,\quad A_{i+1,i}=2,\end{equation*}
$$

multiplied by \( h/30 \). The rows with odd numbers correspond to
nodes at the element boundaries and get contributions from two
neighboring elements in the assembly process,
while the even numbered rows correspond to
internal nodes in the elements where only one element contributes
to the values in the global matrix.

<h2 id="fem:approx:fe:impl:ex2">Applications</h2>

<p>
With the aid of the <code>approximate</code> function in the <code>fe_approx1D</code>
module we can easily investigate the quality of various finite element
approximations to some given functions. Figure <a href="#fem:approx:fe:x9:sin">31</a>
shows how linear and quadratic elements approximate the polynomial
\( f(x)=x(1-x)^8 \) on \( \Omega =[0,1] \), using equal-sized elements.
The results arise from the program

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">4</span>)
</pre></div>
<p>
The quadratic functions are seen to be better than the linear ones for the same
value of \( N \), as we increase \( N \). This observation has some generality:
higher degree is not necessarily better on a coarse mesh, but it is as
we refine the mesh.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 31:  Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right).  <div id="fem:approx:fe:x9:sin"></div> </p></center>
<p><img src="fig-approx/fe_p1_p2_x9_248e.png" align="bottom" width=800></p>
</center>

<h2 id="fem:approx:fe:impl:sparse">Sparse matrix storage and solution</h2>

<p>
Some of the examples in the preceding section took several minutes to
compute, even on small meshes consisting of up to eight elements.
The main explanation for slow computations is unsuccessful
symbolic integration: <code>sympy</code> may use a lot of energy on
integrals like \( \int f(x(X))\refphi_r(X)h/2 \dx \) before
giving up, and the program then resorts to numerical integration.
Codes that can deal with a large number of basis functions and
accept flexible choices of \( f(x) \) should compute all integrals
numerically and replace the matrix objects from <code>sympy</code> by
the far more efficient array objects from <code>numpy</code>.

<p>
There is also another (potential)
reason for slow code: the solution algorithm for
the linear system performs much more work than necessary. Most of the
matrix entries \( A_{i,j} \) are zero, because \( (\basphi_i,\basphi_j)=0 \)
unless \( i \) and \( j \) are nodes in the same element. In 1D problems,
we do not need to store or compute with these zeros when solving the
linear system, but that requires solution methods adapted to the kind
of matrices produced by the finite element approximations.

<p>
A matrix whose majority of entries are zeros, is known as a <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_self">sparse</a> matrix.
Utilizing sparsity in software dramatically decreases
the storage demands and the CPU-time needed to compute the solution of
the linear system. This optimization is not very critical in 1D problems
where modern computers can afford computing with all the zeros in the
complete square matrix, but in 2D and especially in 3D, sparse
matrices are fundamental for feasible finite element computations.
One of the advantageous features of the finite element method is that it
produces very sparse matrices. The reason is that the basis functions
have local support such that the product of two basis functions, as
typically met in integrals, is mostly zero.

<p>
Using a numbering of nodes and elements from left to right over a 1D
domain, the assembled coefficient matrix has only a few diagonals
different from zero. More precisely, \( 2d+1 \) diagonals around the main
diagonal are different from zero. With a different numbering of global
nodes, say a random ordering, the diagonal structure is lost, but the
number of nonzero elements is unaltered. Figures
<a href="#fem:approx:fe:sparsity:P1">32</a> and <a href="#fem:approx:fe:sparsity:P3">33</a>
exemplify sparsity patterns.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 32:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements. <div id="fem:approx:fe:sparsity:P1"></div> </p></center>
<p><img src="fig-approx/sparsity_pattern_1D_30.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 33:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements. <div id="fem:approx:fe:sparsity:P3"></div> </p></center>
<p><img src="fig-approx/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p>
</center>

<p>
The <code>scipy.sparse</code> library supports creation of sparse matrices
and linear system solution.

<ul>
 <li> <code>scipy.sparse.diags</code> for matrix defined via diagonals</li>
 <li> <code>scipy.sparse.dok_matrix</code> for matrix incrementally defined via index pairs \( (i,j) \)</li>
</ul>

The <code>dok_matrix</code> object is most convenient for finite element computations.
This sparse matrix format is called DOK, which stands for Dictionary Of Keys:
the implementation is basically a dictionary (hash) with the
entry indices <code>(i,j)</code> as keys.

<p>
Rather than declaring <code>A = np.zeros((N_n, N_n))</code>, a DOK sparse
matrix is created by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse</span>
A = scipy.sparse.dok_matrix((N_n, N_n))
</pre></div>
<p>
When there is any need to add or set some matrix entry <code>i,j</code>, just do

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">A[i,j]  = entry
<span style="color: #228B22"># or</span>
A[i,j] += entry
</pre></div>
<p>
The indexing creates the matrix entry on the fly, and
only the nonzero entries in the matrix will be stored.

<p>
To solve a system with right-hand side <code>b</code> (one-dimensional <code>numpy</code>
array) with a sparse coefficient matrix <code>A</code>, we must use some kind of
a sparse linear system solver. The safest choice is a method based on
sparse Gaussian elimination:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse.linalg</span>
c = scipy.sparse.linalg.spsolve(A.tocsr(), b, use_umfpack=<span style="color: #658b00">True</span>)
</pre></div>
<p>
The call <code>A.tocsr()</code> is not strictly needed (a warning is issued
otherwise), but ensures that the solution algorithm can efficiently
work with a copy of the sparse matrix in <em>Compressed Sparse Row</em>  (CSR) format.

<p>
An advantage of the <code>scipy.sparse.diags</code> matrix over the DOK format is
that the former allows vectorized assignment to the matrix.
Vectorization is possible for approximation problems when all elements
are of the same type. However, when solving differential equations,
vectorization is much more difficult. It also appears that the DOK
sparse matrix format available in the <code>scipy.sparse</code> package is fast
enough even for big 1D problems on today's laptops, so the need for
improving efficiency occurs in 2D and 3D problems, but then the
complexity of the mesh favors the DOK format.

<p>
<!-- 2DO -->

<p>
<!-- Examples to come.... -->

<p>
<!-- Exercise: introduce a random numbering of global nodes; need arbitrary, sparse matrix. -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

