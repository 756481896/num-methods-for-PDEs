<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,normal equations,$A^TA=A^Tb$ (normal equations),Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec23'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec24'),
              ('Implementation', 3, None, '___sec25'),
              ('Example', 3, None, '___sec26'),
              ('Remark', 3, None, '___sec27'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec29'),
              ('Successful example', 3, None, '___sec30'),
              ('Less successful example', 3, None, '___sec31'),
              ('Remedy for strong oscillations', 3, None, '___sec32'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec35'),
              ('The basis functions', 2, None, '___sec36'),
              ('Construction principles', 3, None, '___sec37'),
              ('Properties of $\\basphi_i$', 3, None, '___sec38'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec39'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec40'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec41'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec43'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec44'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec46'),
              ('Assembly of element matrices', 3, None, '___sec47'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec48'),
              ('The element vector', 3, None, '___sec49'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec51'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec52'),
              ('Formulas for local basis functions', 3, None, '___sec53'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fem',
               'fem:deq:1D:approx:fem_vs_fem'),
              ('Computations in physical space', 3, None, '___sec68'),
              ('Elementwise computations', 3, None, '___sec69'),
              ('Terminology', 3, None, '___sec70'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec77'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec79'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec82'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec85'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec86'),
              ('Element matrices and vectors', 3, None, '___sec87'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec88'),
              ('Affine mapping of the reference cell', 2, None, '___sec89'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec90'),
              ('Computing integrals', 2, None, '___sec91'),
              ('Exercises', 1, None, '___sec92'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec99'),
              ('Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec101'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec118')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="approx.html">Approximation of functions</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._approx002.html#fem:approx:vec" style="font-size: 80%;">Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx003.html#fem:approx:global" style="font-size: 80%;">Approximation of functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx004.html#fem:approx:fe" style="font-size: 80%;">Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx005.html#fem:approx:fe:impl" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx006.html#fem:approx:fe:fd" style="font-size: 80%;">Comparison of finite element and finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._approx007.html#fem:approx:fe:element" style="font-size: 80%;">A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._approx008.html#___sec77" style="font-size: 80%;">Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx009.html#fem:approx:2D" style="font-size: 80%;">Approximation of functions in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._approx010.html#___sec85" style="font-size: 80%;">Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._approx012.html#___sec118" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0011"></a>
<!-- !split -->

<h1 id="___sec92">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg1">Problem 1: Linear algebra refresher</h2>

<p>
Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.

<p>
<b>a)</b>
Prove that vectors in the plane \( (a,b) \) form a vector space
by showing that all the axioms of a vector space are satisfied.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Prove that all linear functions of the form \( ax+b \) constitute a vector space,
\( a,b\in\Real \).

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>c)</b>
Show that all quadratic functions of the form \( 1 + ax^2 + bx \) <em>do not</em>
constitute a vector space.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>d)</b>
Check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form \( ax+b \), \( a,b\in\Real \),
defined on some interval \( \Omega=[A,B] \).
Show that this particular inner product satisfies the
general requirements of an inner product in a vector space.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>linalg1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:vec:3Dby2D">Problem 2: Approximate a three-dimensional vector in a plane</h2>

<p>
Given \( \f = (1,1,1) \) in \( \Real^3 \), find the best approximation vector
\( \u \) in the plane spanned by the unit vectors \( (1,0) \) and \( (0,1) \).
Repeat the calculations using the vectors \( (2,1) \) and \( (1,2) \).

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>vec111_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:parabola_sine">Problem 3: Approximate a parabola by a sine</h2>

<p>
Given the function \( f(x)=1 + 2x(1-x) \) on \( \Omega=[0,1] \), we want to
find an approximation in the function space

$$ V = \hbox{span}\{1, \sin(\pi x)\}\tp$$

<p>
<b>a)</b>
Sketch or plot \( f(x) \). Think intuitively how an expansion in terms
of the basis functions of \( V \), \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=\sin(\pi x) \),
can be construction to yield a best approximation to \( f \). Or
phrased differently, see if you can guess the coefficients \( c_0 \) and \( c_1 \)
in the expansion

$$ u(x) = c_0\baspsi_0 + c_1\baspsi_1 = c_0 + c_1\sin (\pi x)\tp$$

Compute the \( L^2 \) error \( ||f-u||_{L^2}=(\int_0^1(f-u)^2\dx)^{1/2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_1">

<p>
If you make a mesh function <code>e</code> of the error
on some mesh with uniformly spaced coordinates in
the array <code>xc</code>, the integral can be approximated as <code>np.sqrt(dx*np.sum(e**2))</code>,
where <code>dx=xc[0]-xc[1]</code> is the mesh spacing and <code>np</code> is an alias for the
<code>numpy</code> module in Python.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Perform the hand calculations for a least squares approximation.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>parabola_sin</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:exp:powers">Problem 4: Approximate the exponential function by power functions</h2>

<p>
Let \( V \) be a function space with basis functions \( x^i \),
\( i=0,1,\ldots,N \).  Find the best approximation to \( f(x)=\exp(-x) \) on
\( \Omega =[0,8] \) among all functions in \( V \) for \( N=2,4,6 \). Illustrate
the three approximations in three separate plots.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
Apply the <code>lest_squares</code> and
<code>comparison_plot</code> functions in the <code>approx1D.py</code> module as these
make the exercise easier to solve.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>exp_powers</code>.

<p>
<!-- Taylor: these polynomials go so far off on [0,8] that it is not a -->
<!-- good idea to add them. -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:sin:powers">Problem 5: Approximate the sine function by power functions</h2>

<p>
In this exercise we want to approximate the sine function by polynomials
of order \( N+1 \). Consider two bases:

$$
\begin{align*}
V_1 &= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\ 
V_2 &= \{1,x,x^2,x^3,\ldots, x^N\}\tp
\end{align*}
$$

The basis \( V_1 \) is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while \( V_2 \)
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.

<p>
Compute the best approximation to \( f(x)=\sin(x) \) among all functions
in \( V_1 \) and \( V_2 \) on two domains of increasing sizes: \( \Omega_{1,k} =
[0, k\pi] \), \( k=2,3\ldots,6 \) and \( \Omega_{2,k} = [-k\pi /2, k\pi/2] \),
\( k=2,3,4,5 \).  Make plots for all combinations of \( V_1 \), \( V_2 \),
\( \Omega_1 \), \( \Omega_2 \), \( k=2,3,\ldots,6 \).

<p>
Add a plot of the \( N \)-th degree Taylor polynomial approximation of
\( \sin(x) \) around \( x=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
You can make a loop over \( V_1 \) and \( V_2 \), a loop over
\( \Omega_1 \) and \( \Omega_2 \), and a loop over \( k \). Inside the loops,
call the functions <code>least_squares</code> and
<code>comparison_plot</code> from the <code>approx1D</code> module.
\( N=7 \) is a suggested value.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>sin_powers</code>.

<p>
<!-- Solveig explanations based on f-B approx -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</h2>

<p>
Find the best approximation of \( f(x) = \tanh (s(x-\pi)) \) on
\( [0, 2\pi] \) in the space \( V \) with basis
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
Make a movie showing how \( u=\sum_{j\in\If}c_j\baspsi_j(x) \)
approximates \( f(x) \) as \( N \) grows. Choose \( s \) such that \( f \) is
steep (\( s=20 \) is appropriate).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_1">

<p>
One may naively call the <code>least_squares_orth</code> and <code>comparison_plot</code>
from the <code>approx1D</code> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <code>least_squares_orth</code>
compute with only one basis function at a time and accumulate
the corresponding <code>u</code> in the total solution.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_2">

<p>
<code>ffmpeg</code> or <code>avconv</code> may skip frames when plot files are combined to
a movie. Since there are few files and we want to see each of them,
use <code>convert</code> to make an animated GIF file (<code>-delay 200</code> is
suitable).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_sines</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec99">Remarks </h3>

<p>
Approximation of a discontinuous (or steep) \( f(x) \) by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in \( f \).
This is known as the <a href="http://en.wikipedia.org/wiki/Gibbs_phenomenon" target="_self">Gibb's phenomenon</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine3">Problem 7: Approximate a steep function by sines with boundary adjustment</h2>

<p>
We study the same approximation problem as in
<a href="#fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</a>. Since \( \baspsi_i(0)=\baspsi_i(2\pi)=0 \)
for all \( i \), \( u=0 \) at the boundary points \( x=0 \) and \( x=2\pi \), while
\( f(0)=-1 \) and \( f(2\pi)=1 \). This discrepancy at the boundary can be
removed by adding a boundary function \( B(x) \):

$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
$$

where \( B(x) \) has the right boundary values: \( B(x_L)=f(x_L) \) and
\( B(x_R)=f(x_R) \), with \( x_L=0 \) and \( x_R=2\pi \) as the boundary points.
A linear choice of \( B(x) \) is

$$ B(x) = \frac{(x_R-x)f(x_L) + (x-x_L)f(x_R)}{x_R-x_L}\tp$$

<p>
<b>a)</b>
Use the basis
\( \baspsi_i(x) = \sin((i+1)x) \), \( i\in\If = \{0,\ldots,N\} \)
and plot \( u \) and \( f \) for \( N=16 \). (It suffices to make plots for even \( i \).)

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Use the basis from <a href="#fem:approx:exer:tanh:sine1">Problem 6: Approximate a steep function by sines</a>,
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
(It suffices to make plots for even \( i \).)
Observe that the approximation converges to a piecewise
linear function!

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>c)</b>
Use the basis
\( \baspsi_i(x) = \sin(2(i+1)x) \), \( i\in\If = \{0,\ldots,N\} \),
and observe that the approximation converges to a piecewise
constant function.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>tanh_sines_boundary_term</code>.

<p>
<!-- Closing remarks for this Problem -->

<h3 id="___sec101">Remarks </h3>

<p>
The strange results in b) and c) are due to the choice of
basis. In b), \( \basphi_i(x) \) is an odd function around
\( x=\pi/2 \) and \( x=3\pi/2 \). No combination of basis functions
is able to approximate the flat regions of \( f \).
All basis functions in c) are even around \( x=\pi/2 \) and \( x=3\pi/2 \),
but odd at \( x=0,\pi,2\pi \). With all the sines represented, as in a),
the approximation is not constrained with a particular symmetry
behavior.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</h2>

<p>
<b>a)</b>
Given a function \( f(x) \) on an interval \( [0,L] \), look up the formula
for the coefficients \( a_j \) and \( b_j \) in the Fourier series of \( f \):

$$
\begin{equation*}
f(x) = \frac{1}{2}a_0 +
\sum_{j=1}^\infty a_j\cos \left(j\frac{2\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{2\pi x}{L}\right)\tp
\end{equation*}
$$

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Let an infinite-dimensional vector space \( V \) have the basis functions
\( \cos j\frac{2\pi x}{L} \) for \( j=0,1,\dots,\infty \) and
\( \sin j\frac{2\pi x}{L} \) for \( j=1,\dots,\infty \).  Show that the least squares
approximation method from the section <a href="._approx003.html#fem:approx:global">Approximation of functions</a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of \( f(x) \) (see also
the section <a href="._approx003.html#fem:approx:global:Fourier">Fourier series</a>).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_1">

<p>
You may choose

$$
\begin{equation}
\baspsi_{2i} = \cos\left( i\frac{2\pi}{L}x\right),\quad
\baspsi_{2i+1} = \sin\left( i\frac{2\pi}{L}x\right),
\tag{125}
\end{equation}
$$

for \( i=0,1,\ldots,N\rightarrow\infty \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>c)</b>
Choose \( f(x) = H(x-\half) \) on \( \Omega=[0,1] \), where \( H \) is the
Heaviside function: \( H(x)=0 \) for \( x < 0 \), \( H(x)=1 \) for \( x>0 \) and
\( H(0)=\half \). Find the coefficients \( a_j \) and \( b_j \) in the
Fourier series for \( f(x) \). Plot the sum for \( j=2N+1 \), where \( N=5 \) and
\( N=100 \).

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>Fourier_ls</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</h2>

<p>
Use interpolation with uniformly distributed
points and Chebychev nodes to approximate

$$
\begin{equation*} f(x) = -\tanh(s(x-\half)),\quad x\in [0,1],\end{equation*}
$$

by Lagrange polynomials for \( s=5 \) and \( s=20 \), and \( N=3,7,11,15 \).
Combine \( 2\times 2 \) plots of the approximation for the four
\( N \) values, and create such figures for the four combinations of
\( s \) values and point types.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_Lagrange</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange:regression">Problem 10: Approximate a steep function by Lagrange polynomials and regression</h2>

<p>
Redo <a href="#fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</a>, but apply a regression
method with \( N \)-degree Lagrange polynomials and \( 2N+1 \)
data points. Recall that
<a href="#fem:approx:exer:tanh:Lagrange">Problem 9: Approximate a steep function by Lagrange polynomials</a> applies \( N+1 \) points and
the resulting approximation interpolates \( f \) at these points, while
a regression method with more points does not interpolate \( f \) at the
data points.
Do more points and a regression method help reduce
the oscillatory behavior of Lagrange polynomial approximations?

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_Lagrange_regression</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</h2>

<p>
Consider a domain \( \Omega =[0,2] \) divided into the three elements
\( [0,1] \), \( [1,1.2] \), and \( [1.2,2] \).

<p>
For P1 and P2 elements, set up the list of coordinates and nodes
(<code>nodes</code>) and the numbers of the nodes that belong to each element
(<code>elements</code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_numberings1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh2">Problem 12: Define vertices, cells, and dof maps</h2>

<p>
Repeat <a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a>, but define the
data structures <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> instead of
<code>nodes</code> and <code>elements</code>.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_numberings2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:defmesh:sparsity">Problem 13: Construct matrix sparsity patterns</h2>

<p>
<a href="#fem:approx:fe:exer:mesh1">Problem 11: Define nodes and elements</a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a \( 5\times 5 \) matrix and fill in the entries that will be nonzero.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_13_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_13_1">

<p>
A matrix entry \( (i,j) \) is nonzero if \( i \) and \( j \) are nodes in the
same element.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_sparsity_pattern</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:symbolic">Problem 14: Perform symbolic finite element computations</h2>

<p>
Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating \( f(x) = \sin (x) \) on
\( \Omega=[0, \pi] \) by two P1 elements of size \( \pi/2 \).  Solve the
system and compare \( u(\pi/2) \) with the exact value 1.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_sin_P1</code>.

<p>
<!-- Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b), -->
<!-- which is the integral -->
<!-- that arises on the right-hand side. -->

<p>
<!-- solution: -->
<!-- from fe_approx1D_numint import * -->
<!-- c = approximate(sym.sin(x), symbolic=True, d=1, N_e=2, numint=None, -->
<!-- Omega=[0,sym.pi]) -->
<!-- print sym.simplify(c[1,0].subs('h', sym.pi/2)) -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</h2>

<p>
Given

$$
\begin{equation*} f(x) = \tanh(s(x-\half))\end{equation*}
$$

use the Galerkin or least squares method with finite elements to find
an approximate function \( u(x) \). Choose \( s=20 \) and try
\( N_e=4,8,16 \) P1 elements and
\( N_e=2,4,8 \) P2 elements.
Integrate \( f\basphi_i \) numerically.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_15_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_15_1">

<p>
You can automate the computations by calling the <code>approximate</code> method
in the <code>fe_approx1D_numint</code> module.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_tanh_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P3P4">Problem 16: Approximate a steep function by P3 and P4 elements</h2>

<p>
<b>a)</b>
Solve <a href="#fem:approx:exer:tanh:P1P2">Problem 15: Approximate a steep function by P1 and P2 elements</a> using \( N_e=1,2,4 \) P3 and P4
elements.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
How will an interpolation method work in
this case with the same number of nodes?

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>fe_tanh_P3P4</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:interpol:error">Exercise 17: Investigate the approximation error in finite elements</h2>

<p>
The theory <a href="._approx007.html#mjx-eqn-101">(101)</a> from the section <a href="._approx007.html#fem:approx:fe:error">Computing the error of the approximation</a> predicts that the error in the Pd
approximation of a function should behave as \( h^{d+1} \), where \( h \) is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough \( h \)).  Choose three examples:
\( f(x)=Ae^{-\omega x} \) on \( [0,3/\omega] \), \( f(x) = A\sin (\omega x) \) on
\( \Omega=[0, 2\pi/\omega] \) for constant \( A \) and \( \omega \), and
\( f(x)=\sqrt{x} \) on \( [0,1] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

<p>
Run a series of experiments: \( (h_i,E_i) \), \( i=0,\ldots,m \), where \( E_i \)
is the \( L^2 \) norm of the error corresponding to element length \( h_i \).
Assume an error model \( E=Ch^r \) and compute \( r \) from two successive
experiments:

$$ r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1\tp$$

Hopefully, the sequence \( r_0,\ldots,r_{m-1} \) converges to the true
\( r \), and \( r_{m-1} \) can be taken as an approximation to \( r \).
Run such experiments for different \( d \) for the different \( f(x) \) functions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_2">

<p>
The <code>approximate</code> function in <code>fe_approx1D_numint.py</code> is handy for
calculating the numerical solution. This function returns the
finite element solution as the coefficients \( \sequencei{c} \).
To compute \( u \), use <code>u_glob</code> from the same module.
Use the Trapezoidal rule to integrate the \( L^2 \) error:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">xc, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map)
e <span style="color: #666666">=</span> f_func(xc) <span style="color: #666666">-</span> u
L2_error <span style="color: #666666">=</span> <span style="color: #666666">0</span>
e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(xc)<span style="color: #666666">-1</span>):
    L2_error <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(e2[i<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> e2[i])<span style="color: #666666">*</span>(xc[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> xc[i])
L2_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(L2_error)
</pre></div>
<p>
The reason for this Trapezoidal integration is
that <code>u_glob</code> returns coordinates <code>xc</code> and corresponding <code>u</code> values
where some of the coordinates (the cell vertices) coincides, because
the solution is computed in one element at a time, using all local
nodes. Also note that there are many coordinates in \( xc \) per cell
such that we can accurately compute the error inside each cell.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>Pd_approx_error</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Heaviside">Problem 18: Approximate a step function by finite elements</h2>

<p>
Approximate the step function

$$
\begin{equation*} f(x) = \left\lbrace\begin{array}{ll}
0 & 0\leq x < \halfi,\\ 
1 & \halfi \leq x \geq \halfi
\end{array}\right.
\end{equation*}
$$

by 2, 4, 8, and 16 P1, P2, P3, and P4. Compare approximations visually.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
This \( f \) can also be expressed in terms of the Heaviside function \( H(x) \):
\( f(x) = H(x-\halfi) \).
Therefore, \( f \) can be defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Heaviside(x <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>))
</pre></div>
<p>
making the <code>approximate</code> function in the
<code>fe_approx1D.py</code> module an obvious candidate to solve the
problem. However, <code>sympy</code> does not handle symbolic integration
with this particular integrand, and the <code>approximate</code> function faces a problem
when converting <code>f</code> to a Python function (for plotting) since
<code>Heaviside</code> is not an available function in <code>numpy</code>.

<p>
An alternative is to perform hand calculations. This is an instructive
task, but in practice only feasible for few elements and P1 and P2 elements.
It is better to copy the functions <code>element_matrix</code>, <code>element_vector</code>,
<code>assemble</code>, and <code>approximate</code> from the <code>fe_approx1D_numint.py</code> file
and edit these functions such that they can compute approximations
with <code>f</code> given as a Python function and not a symbolic expression.
Also assume that <code>phi</code> computed by the <code>basis</code> function is a Python
callable function. Remove all instances of the <code>symbolic</code> variable
and associated code.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_Heaviside_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:2Dsines:symbolic">Exercise 19: 2D approximation with orthogonal functions</h2>

<p>
Assume we have basis functions \( \basphi_i(x,y) \) in 2D that are
orthogonal
such that \( (\basphi_i,\basphi_j)=0 \) when \( i\neq j \).
The function <code>least_squares</code> in the
file <a href="http://tinyurl.com/nm5587k/approx/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a> will then spend much time on computing off-diagonal terms
in the coefficient matrix that we know are zero.
To speed up the computations, make a
version <code>least_squares_orth</code> that utilizes the orthogonality among the
basis functions. Apply the function to approximate

$$ f(x,y) = x(1-x)y(1-y)e^{-x-y}$$

on \( \Omega = [0,1]\times [0,1] \) via basis functions

$$ \basphi_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
$$

where \( p=0,\ldots,N_x \) and \( q=0,\ldots,N_y \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_1">

<p>
Get ideas from the function <code>least_squares_orth</code> in
the section <a href="._approx003.html#fem:approx:global:orth">Orthogonal basis functions</a> and
file <a href="http://tinyurl.com/nm5587k/approx/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>approx2D_ls_orth</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:trapez">Exercise 20: Use the Trapezoidal rule and P1 elements</h2>

<p>
Consider approximation of some \( f(x) \) on an interval \( \Omega \) using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a href="._approx008.html#mjx-eqn-109">(109)</a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form \( c_i=f(\xno{i}) \) for \( i\in\If \).
Filename: <code>fe_P1_trapez</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:P1:vs:interp">Exercise 21: Compare P1 elements and interpolation</h2>

<p>
We shall approximate the function

$$ f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],$$

where \( n\in\Integer \) and \( \epsilon \geq 0 \).

<p>
<b>a)</b>
Plot \( f(x) \) for \( n=1,2,3 \) and find the wave length of the function.

<p>
<b>b)</b>
We want to use \( N_P \) elements per wave length. Show that the number
of elements is then \( nN_P \).

<p>
<b>c)</b>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an \( f \) with just one wave length in \( \Omega = [0,1] \).
Set \( \epsilon = 0.5 \).

<p>
Run the least squares or projection/Galerkin method for
\( N_P=2,4,8,16,32 \). Compute the error \( E=||u-f||_{L^2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_21_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_21_1">

<p>
Use the <code>fe_approx1D_numint</code> module to compute \( u \) and use
the technique from the section <a href="._approx007.html#fem:approx:fe:error">Computing the error of the approximation</a> to
compute the norm of the error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute \( u(x) \) (recall that \( c_i \) is now simply \( f(\xno{i}) \)).
Compute the error \( E=||u-f||_{L^2} \).
Which method seems to be most accurate?

<p>
Filename: <code>fe_P1_vs_interp</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:3D:approx3D">Exercise 22: Implement 3D computations with global basis functions</h2>

<p>
Extend the <a href="http://tinyurl.com/nm5587k/approx/approx2D.py" target="_self"><tt>approx2D.py</tt></a> code to 3D
applying ideas from the section <a href="._approx009.html#fem:approx:3D:global">Extension to 3D</a>.
Use a 3D generalization of the test problem in the section <a href="._approx009.html#fem:approx:2D:global:code">Implementation</a> to test the implementation.
Filename: <code>approx3D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:simpson">Exercise 23: Use Simpson's rule and P2 elements</h2>

<p>
Redo <a href="#fem:approx:fe:exer:1D:trapez">Exercise 20: Use the Trapezoidal rule and P1 elements</a>, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.
Filename: <code>fe_P2_simpson</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._approx010.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._approx012.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

