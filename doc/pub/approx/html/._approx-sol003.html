<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,normal equations,$A^TA=A^Tb$ (normal equations),Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec23'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec24'),
              ('Implementation', 3, None, '___sec25'),
              ('Example', 3, None, '___sec26'),
              ('Remark', 3, None, '___sec27'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec29'),
              ('Successful example', 3, None, '___sec30'),
              ('Less successful example', 3, None, '___sec31'),
              ('Remedy for strong oscillations', 3, None, '___sec32'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec35'),
              ('The basis functions', 2, None, '___sec36'),
              ('Construction principles', 3, None, '___sec37'),
              ('Properties of $\\basphi_i$', 3, None, '___sec38'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec39'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec40'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec41'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec43'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec44'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec46'),
              ('Assembly of element matrices', 3, None, '___sec47'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec48'),
              ('The element vector', 3, None, '___sec49'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec51'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec52'),
              ('Formulas for local basis functions', 3, None, '___sec53'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fem',
               'fem:deq:1D:approx:fem_vs_fem'),
              ('Computations in physical space', 3, None, '___sec68'),
              ('Elementwise computations', 3, None, '___sec69'),
              ('Terminology', 3, None, '___sec70'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec77'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec79'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec82'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec85'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec86'),
              ('Element matrices and vectors', 3, None, '___sec87'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec88'),
              ('Affine mapping of the reference cell', 2, None, '___sec89'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec90'),
              ('Computing integrals', 2, None, '___sec91'),
              ('Exercises', 1, None, '___sec92'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec99'),
              ('Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec101'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec118')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="approx-sol.html">Approximation of functions</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#fem:approx:vec" style="font-size: 80%;">Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:global" style="font-size: 80%;">Approximation of functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe" style="font-size: 80%;">Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:approx:fe:fd" style="font-size: 80%;">Comparison of finite element and finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol007.html#fem:approx:fe:element" style="font-size: 80%;">A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol008.html#___sec77" style="font-size: 80%;">Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:2D" style="font-size: 80%;">Approximation of functions in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec85" style="font-size: 80%;">Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#___sec92" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol012.html#___sec118" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0003"></a>
<!-- !split -->

<h1 id="fem:approx:global">Approximation of functions</h1>

<p>
Let \( V \) be a function space spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

$$
\begin{equation*} V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\},\end{equation*}
$$

such that any function \( u\in V \) can be written as a linear
combination of the basis functions:

$$
\begin{equation}
u = \sum_{j\in\If} c_j\baspsi_j\tp
\tag{14}
\end{equation}
$$

The index set \( \If \) is defined as \( \If =\{0,\ldots,N\} \) and is
from now on used
both for compact notation and for flexibility in the numbering of
elements in sequences.

<p>
For now, in this introduction, we shall look at functions of a
single variable \( x \):
\( u=u(x) \), \( \baspsi_j=\baspsi_j(x) \), \( j\in\If \). Later, we will almost
trivially extend the mathematical details
to functions of two- or three-dimensional physical spaces.
The approximation <a href="#mjx-eqn-14">(14)</a> is typically used
to discretize a problem in space. Other methods, most notably
finite differences, are common for time discretization, although the
form <a href="#mjx-eqn-14">(14)</a> can be used in time as well.

<h2 id="fem:approx:LS">The least squares method</h2>

<p>
Given a function \( f(x) \), how can we determine its best approximation
\( u(x)\in V \)? A natural starting point is to apply the same reasoning
as we did for vectors in the section <a href="._approx-sol002.html#fem:approx:vec:Np1dim">Approximation of general vectors</a>. That is,
we minimize the distance between \( u \) and \( f \). However, this requires
a norm for measuring distances, and a norm is most conveniently
defined through an
inner product. Viewing a function as a vector of infinitely
many point values, one for each value of \( x \), the inner product of
two arbitrary functions \( f(x) \) and \( g(x) \) could
intuitively be defined as the usual summation of
pairwise &quot;components&quot; (values), with summation replaced by integration:

$$
\begin{equation*}
(f,g) = \int f(x)g(x)\, \dx
\tp
\end{equation*}
$$

To fix the integration domain, we let \( f(x) \) and \( \baspsi_i(x) \)
be defined for a domain \( \Omega\subset\Real \).
The inner product of two functions \( f(x) \) and \( g(x) \) is then

$$
\begin{equation}
(f,g) = \int_\Omega f(x)g(x)\, \dx
\tag{15}
\tp
\end{equation}
$$

<p>
The distance between \( f \) and any function \( u\in V \) is simply
\( f-u \), and the squared norm of this distance is

$$
\begin{equation}
E = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))\tp
\tag{16}
\end{equation}
$$

Note the analogy with <a href="._approx-sol002.html#mjx-eqn-10">(10)</a>: the given function
\( f \) plays the role of the given vector \( \f \), and the basis function
\( \baspsi_i \) plays the role of the basis vector \( \psib_i \).
We can rewrite <a href="#mjx-eqn-16">(16)</a>,
through similar steps as used for the result
<a href="._approx-sol002.html#mjx-eqn-10">(10)</a>, leading to

$$
\begin{equation}
E(c_i, \ldots, c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)\tp  \end{equation}
$$

Minimizing this function of \( N+1 \) scalar variables
\( \sequencei{c} \), requires differentiation
with respect to \( c_i \), for all \( i\in\If \). The resulting
equations are very similar to those we had in the vector case,
and we hence end up with a
linear system of the form <a href="._approx-sol002.html#mjx-eqn-11">(11)</a>, with
basically the same expressions:

$$
\begin{align}
A_{i,j} &= (\baspsi_i,\baspsi_j),
\tag{17}\\ 
b_i &= (f,\baspsi_i)\tp
\tag{18}
\end{align}
$$

<h2 id="___sec9">The projection (or Galerkin) method </h2>

<p>
As in the section <a href="._approx-sol002.html#fem:approx:vec:Np1dim">Approximation of general vectors</a>, the minimization of \( (e,e) \)
is equivalent to

$$
\begin{equation}
(e,v)=0,\quad\forall v\in V\tp
\tag{19}
\end{equation}
$$

This is known as a projection of a function \( f \) onto the subspace \( V \).
We may also call it a Galerkin method for approximating functions.
Using the same reasoning as
in
<a href="._approx-sol002.html#mjx-eqn-12">(12)</a>-<a href="._approx-sol002.html#mjx-eqn-13">(13)</a>,
it follows that <a href="#mjx-eqn-19">(19)</a> is equivalent to

$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If\tp
\tag{20}
\end{equation}
$$

Inserting \( e=f-u \) in this equation and ordering terms, as in the
multi-dimensional vector case, we end up with a linear
system with a coefficient matrix <a href="#mjx-eqn-17">(17)</a> and
right-hand side vector <a href="#mjx-eqn-18">(18)</a>.

<p>
Whether we work with vectors in the plane, general vectors, or
functions in function spaces, the least squares principle and
the projection or Galerkin method are equivalent.

<h2 id="fem:approx:global:linear">Example: linear approximation</h2>

<p>
Let us apply the theory in the previous section to a simple problem:
given a parabola \( f(x)=10(x-1)^2-1 \) for \( x\in\Omega=[1,2] \), find
the best approximation \( u(x) \) in the space of all linear functions:

$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\tp  \end{equation*}
$$

With our notation, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

$$
\begin{equation*} u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x,\end{equation*}
$$

where
\( c_0 \) and \( c_1 \) are found by solving a \( 2\times 2 \) the linear system.
The coefficient matrix has elements

$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, \dx = 1,\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, \dx = 3/2,\\ 
A_{1,0} &= A_{0,1} = 3/2,\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,\dx = 7/3\tp  \end{align}
$$

The corresponding right-hand side is

$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, \dx = 7/3,\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, \dx = 13/3\tp  \end{align}
$$

Solving the linear system results in

$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,
\end{equation}
$$

and consequently

$$
\begin{equation}
u(x) = 10x - \frac{38}{3}\tp  \end{equation}
$$

Figure <a href="#fem:approx:global:fig:parabola:linear">2</a> displays the
parabola and its best approximation in the space of all linear functions.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Best approximation of a parabola by a straight line.  <div id="fem:approx:global:fig:parabola:linear"></div> </p></center>
<p><img src="fig-approx/parabola_ls_linear.png" align="bottom" width=400></p>
</center>

<h2 id="fem:approx:global:LS:code">Implementation of the least squares method</h2>

<h3 id="___sec12">Symbolic integration </h3>

<p>
The linear system can be computed either symbolically or
numerically (a numerical integration rule is needed in the latter case).
Let us first compute the system and its solution symbolically, i.e.,
using classical &quot;pen and paper&quot; mathematics with symbols.
The Python package <code>sympy</code> can greatly help with this type of
mathematics, and will therefore be frequently used in this text.
Some basic familiarity with <code>sympy</code> is assumed, typically
<code>symbols</code>, <code>integrate</code>, <code>diff</code>, <code>expand</code>, and <code>simplify</code>. Much can be learned
by studying the many applications of <code>sympy</code> that will be presented.

<p>
Below is a function for symbolic computation of the linear system,
where \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> involving
the symbol <code>x</code>, <code>psi</code> is a list of expressions for \( \sequencei{\baspsi} \),
and <code>Omega</code> is a 2-tuple/list holding the limits of the domain \( \Omega \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>psi[j],
                                  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            A[j,i] <span style="color: #666666">=</span> A[i,j]
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>f, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    <span style="color: #408080; font-style: italic"># Note: c is a sympy Matrix object, solution is in c[:,0]</span>
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi[i]
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
Observe that we exploit the symmetry of the coefficient matrix:
only the upper triangular part is computed. Symbolic integration, also in
<code>sympy</code>, is often time consuming, and (roughly) halving the
work has noticeable effect on the waiting time for the computations to
finish.

<h3 id="___sec13">Fall back on numerical integration </h3>

<p>
Obviously, <code>sympy</code> may fail to successfully integrate
\( \int_\Omega\baspsi_i\baspsi_j\dx \), and
especially \( \int_\Omega f\baspsi_i\dx \), symbolically.
Therefore, we should extend
the <code>least_squares</code> function such that it falls back on
numerical integration if the symbolic integration is unsuccessful.
In the latter case, the returned value from <code>sympy</code>'s
<code>integrate</code> function is an object of type <code>Integral</code>.
We can test on this type and utilize the <code>mpmath</code> module in
<code>sympy</code> to perform numerical integration of high precision.
Even when <code>sympy</code> manages to integrate symbolically, it can
take an undesirable long time. We therefore include an
argument <code>symbolic</code> that governs whether or not to try
symbolic integration. Here is a complete and
improved version of the previous function <code>least_squares</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
            <span style="color: #008000; font-weight: bold">if</span> symbolic:
                I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
                <span style="color: #408080; font-style: italic"># Could not integrate symbolically,</span>
                <span style="color: #408080; font-style: italic"># fall back on numerical integration</span>
                integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
                I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> I

        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)  <span style="color: #408080; font-style: italic"># symbolic solve</span>
    <span style="color: #408080; font-style: italic"># c is a sympy Matrix object, numbers are in c[i,0]</span>
    c <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(c[i,<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
The function is found in the file <code>approx1D.py</code>.

<h3 id="___sec14">Plotting the approximation </h3>

<p>
Comparing the given \( f(x) \) and the approximate \( u(x) \) visually is done
by the following function, which utilizes <code>sympy</code>'s <code>lambdify</code> tool to
convert a <code>sympy</code> expression to a Python function for numerical
computations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">comparison_plot</span>(f, u, Omega, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp.pdf&#39;</span>):
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], u, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    resolution <span style="color: #666666">=</span> <span style="color: #666666">401</span>  <span style="color: #408080; font-style: italic"># no of points in plot</span>
    xcoor  <span style="color: #666666">=</span> linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], resolution)
    exact  <span style="color: #666666">=</span> f(xcoor)
    approx <span style="color: #666666">=</span> u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #BA2121">&#39;approximation&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
    savefig(filename)
</pre></div>
<p>
The <code>modules='numpy'</code> argument to <code>lambdify</code> is important
if there are mathematical functions, such as <code>sin</code> or <code>exp</code>
in the symbolic expressions in <code>f</code> or <code>u</code>, and these
mathematical functions are to be used with vector arguments, like
<code>xcoor</code> above.

<p>
Both the <code>least_squares</code> and <code>comparison_plot</code> functions are found in
the file <a href="http://tinyurl.com/nm5587k/fem/approx1D.py" target="_self"><tt>approx1D.py</tt></a>.  The
<code>comparison_plot</code> function in this file is more advanced and flexible
than the simplistic version shown above.  The file <code>ex_approx1D.py</code>
applies the <code>approx1D</code> module to accomplish the forthcoming examples.

<h2 id="fem:approx:global:exact">Perfect approximation</h2>

<p>
Let us use the code above to recompute the problem from
the section <a href="#fem:approx:global:linear">Example: linear approximation</a> where we want to approximate
a parabola. What happens if we add an element \( x^2 \) to the basis and test what
the best approximation is if \( V \) is the space of all parabolic functions?
The answer is quickly found by running

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u, c <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, psi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x, x<span style="color: #666666">**2</span>], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sym<span style="color: #666666">.</span>expand(f)
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
</pre></div>
<p>
Now, what if we use \( \baspsi_i(x)=x^i \) for \( i=0,1,\ldots,N=40 \)?
The output from <code>least_squares</code> gives \( c_i=0 \) for \( i>2 \), which
means that the method finds the perfect approximation.

<p>
In fact, we have a general result that
if \( f\in V \), the least squares and projection/Galerkin methods compute
the exact solution \( u=f \).
The proof is straightforward: if \( f\in V \), \( f \) can be expanded in
terms of the basis functions, \( f=\sum_{j\in\If} d_j\baspsi_j \), for
some coefficients \( \sequencej{d} \),
and the right-hand side then has entries

$$
\begin{equation*} b_i = (f,\baspsi_i) = \sum_{j\in\If} d_j(\baspsi_j, \baspsi_i) = \sum_{j\in\If} d_jA_{i,j}
\tp  \end{equation*}
$$

The linear system \( \sum_jA_{i,j}c_j = b_i \), \( i\in\If \), is then

$$
\begin{equation*} \sum_{j\in\If} c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},
\quad i\in\If,\end{equation*}
$$

which implies that \( c_i=d_i \) for \( i\in\If \).

<h2 id="fem:approx:global:illconditioning">Ill-conditioning</h2>

<p>
The computational example in the section <a href="#fem:approx:global:exact">Perfect approximation</a>
applies the <code>least_squares</code> function which invokes symbolic
methods to calculate and solve the linear system. The correct
solution \( c_0=9, c_1=-20, c_2=10, c_i=0 \) for \( i\geq 3 \) is perfectly
recovered.

<p>
Suppose we
convert the matrix and right-hand side to floating-point arrays
and then solve the system using finite-precision arithmetics, which
is what one will (almost) always do in real life. This time we
get astonishing results! Up to about \( N=7 \) we get a solution that
is reasonably close to the exact one. Increasing \( N \) shows that
seriously wrong coefficients are computed.
Below is a table showing the solution of the linear system arising from
approximating a parabola
by functions on the form \( u(x)=c_0 + c_1x + c_2x^2 + \cdots + c_{10}x^{10} \).
Analytically, we know that \( c_j=0 \) for \( j>2 \), but numerically we may get
\( c_j\neq 0 \) for \( j>2 \).

<p>

<div class="row">
  <div class="col-xs-7">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>exact</b></td> <td align="center"><code>sympy</code></td> <td align="center"><code>numpy32</code></td> <td align="center"><code>numpy64</code></td> </tr>
</thead>
<tbody>
<tr><td align="right">   9        </td> <td align="right">   9.62                  </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20      </td> <td align="right">   -23.39                </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10       </td> <td align="right">   17.74                 </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -9.19                 </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   5.25                  </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   0.18                  </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -2.48                 </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   1.81                  </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -0.66                 </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   0.12                  </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0        </td> <td align="right">   -0.001                </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-7 -->
<p>
The exact value of \( c_j \), \( j=0,1,\ldots,10 \), appears in the first
column while the other columns correspond to results obtained
by three different methods:

<ul>
  <li> Column 2: The matrix and vector are converted to
    the data structure  <code>sympy.mpmath.fp.matrix</code> and the
    <code>sympy.mpmath.fp.lu_solve</code> function is used to solve the system.</li>
  <li> Column 3: The matrix and vector are converted to
    <code>numpy</code> arrays with data type <code>numpy.float32</code>
    (single precision floating-point number) and solved by
    the <code>numpy.linalg.solve</code> function.</li>
  <li> Column 4: As column 3, but the data type is
    <code>numpy.float64</code> (double
    precision floating-point number).</li>
</ul>

We see from the numbers in the table that
double precision performs much better than single precision.
Nevertheless, when plotting all these solutions the curves cannot be
visually distinguished (!). This means that the approximations look
perfect, despite the partially very wrong values of the coefficients.

<p>
Increasing \( N \) to 12 makes the numerical solver in <code>numpy</code>
abort with the message: "matrix is numerically singular".
A matrix has to be non-singular to be invertible, which is a requirement
when solving a linear system. Already when the matrix is close to
singular, it is <em>ill-conditioned</em>, which here implies that
the numerical solution algorithms are sensitive to round-off
errors and may produce (very) inaccurate results.

<p>
The reason why the coefficient matrix is nearly singular and
ill-conditioned is that our basis functions \( \baspsi_i(x)=x^i \) are
nearly linearly dependent for large \( i \).  That is, \( x^i \) and \( x^{i+1} \)
are very close for \( i \) not very small. This phenomenon is
illustrated in Figure <a href="#fem:approx:global:fig:illconditioning">3</a>.
There are 15 lines in this figure, but only half of them are
visually distinguishable.
Almost linearly dependent basis functions give rise to an
ill-conditioned and almost singular matrix.  This fact can be
illustrated by computing the determinant, which is indeed very close
to zero (recall that a zero determinant implies a singular and
non-invertible matrix): \( 10^{-65} \) for \( N=10 \) and \( 10^{-92} \) for
\( N=12 \). Already for \( N=28 \) the numerical determinant computation
returns a plain zero.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  The 15 first basis functions \( x^i \), \( i=0,\ldots,14 \). <div id="fem:approx:global:fig:illconditioning"></div> </p></center>
<p><img src="fig-approx/ill_conditioning.png" align="bottom" width=600></p>
</center>

<p>
On the other hand, the double precision <code>numpy</code> solver does run for
\( N=100 \), resulting in answers that are not significantly worse than
those in the table above, and large powers are
associated with small coefficients (e.g., \( c_j < 10^{-2} \) for \( 10\leq
j\leq 20 \) and \( c < 10^{-5} \) for \( j>20 \)). Even for \( N=100 \) the
approximation still lies on top of the exact curve in a plot (!).

<p>
The conclusion is that visual inspection of the quality of the approximation
may not uncover fundamental numerical problems with the computations.
However, numerical analysts have studied approximations and ill-conditioning
for decades, and it is well known that the basis \( \{1,x,x^2,x^3,\ldots,\} \)
is a bad basis. The best basis from a matrix conditioning point of view
is to have orthogonal functions such that \( (\psi_i,\psi_j)=0 \) for
\( i\neq j \). There are many known sets of orthogonal polynomials and
other functions.
The functions used in the finite element methods are almost orthogonal,
and this property helps to avoid problems with solving matrix systems.
Almost orthogonal is helpful, but not enough when it comes to
partial differential equations, and ill-conditioning
of the coefficient matrix is a theme when solving large-scale matrix
systems arising from finite element discretizations.

<h2 id="fem:approx:global:Fourier">Fourier series</h2>

<p>
A set of sine functions is widely used for approximating functions
(the sines are also orthogonal as explained more in the section <a href="#fem:approx:global:illconditioning">Ill-conditioning</a>).  Let us take

$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\tp  \end{equation*}
$$

That is,

$$
\begin{equation*} \baspsi_i(x) = \sin ((i+1)\pi x),\quad i\in\If\tp \end{equation*}
$$

An approximation to the parabola \( f(x)=10(x-1)^2-1 \) for \( x\in\Omega=[1,2] \) from
the section <a href="#fem:approx:global:linear">Example: linear approximation</a> can then be computed by the
<code>least_squares</code> function from the section <a href="#fem:approx:global:LS:code">Implementation of the least squares method</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>sin(sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega)
comparison_plot(f, u, Omega)
</pre></div>
<p>
Figure <a href="#fem:approx:global:fig:parabola:sine1">4</a> (left) shows the oscillatory approximation
of \( \sum_{j=0}^Nc_j\sin ((j+1)\pi x) \) when \( N=3 \).
Changing \( N \) to 11 improves the approximation considerably, see
Figure <a href="#fem:approx:global:fig:parabola:sine1">4</a> (right).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions.  <div id="fem:approx:global:fig:parabola:sine1"></div> </p></center>
<p><img src="fig-approx/parabola_ls_sines4_12.png" align="bottom" width=800></p>
</center>

<p>
There is an error \( f(0)-u(0)=9 \) at \( x=0 \) in Figure <a href="#fem:approx:global:fig:parabola:sine1">4</a> regardless of how large \( N \) is, because all \( \baspsi_i(0)=0 \) and hence
\( u(0)=0 \). We may help the approximation to be correct at \( x=0 \) by
seeking

$$
\begin{equation}
u(x) = f(0) + \sum_{j\in\If} c_j\baspsi_j(x)
\tp
\end{equation}
$$

However, this adjustment introduces a new problem at \( x=1 \) since
we now get an error \( f(1)-u(1)=f(1)-0=-1 \) at this point. A more
clever adjustment is to replace the \( f(0) \) term by a term that
is \( f(0) \) at \( x=0 \) and \( f(1) \) at \( x=1 \). A simple linear combination
\( f(0)(1-x) + xf(1) \) does the job:
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\baspsi_j(x)
\tp
\end{equation}
$$

This adjustment of \( u \) alters the linear system slightly. In the general
case, we set

$$ u(x) = B(x) +  \sum_{j\in\If} c_j\baspsi_j(x),$$

and the linear system becomes

$$ \sum_{j\in\If}(\baspsi_i,\baspsi_j)c_j = (f-B,\baspsi_i),\quad i\in\If\tp$$

The calculations can still utilize the <code>least_squares</code> or
<code>least_squares_orth</code> functions, but solve for \( u-b \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  f1 <span style="color: #666666">=</span> <span style="color: #666666">-1</span>
B <span style="color: #666666">=</span> f0<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x) <span style="color: #666666">+</span> x<span style="color: #666666">*</span>f1
u_sum, c <span style="color: #666666">=</span> least_squares_orth(f<span style="color: #666666">-</span>b, psi, Omega)
u <span style="color: #666666">=</span> B <span style="color: #666666">+</span> u_sum
</pre></div>
<p>
Figure <a href="#fem:approx:global:fig:parabola:sine2">5</a> shows the result
of the technique for
ensuring right boundary values. Even 3 sines can now adjust the
\( f(0)(1-x) + xf(1) \) term such that \( u \) approximates the parabola really
well, at least visually.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term.  <div id="fem:approx:global:fig:parabola:sine2"></div> </p></center>
<p><img src="fig-approx/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800></p>
</center>

<h2 id="fem:approx:global:orth">Orthogonal basis functions</h2>

<p>
The choice of sine functions \( \baspsi_i(x)=\sin ((i+1)\pi x) \) has a great
computational advantage: on \( \Omega=[0,1] \) these basis functions are
<em>orthogonal</em>, implying that \( A_{i,j}=0 \) if \( i\neq j \). This
result is realized by trying

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">integrate(sin(j<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x)<span style="color: #666666">*</span>sin(k<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x), x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
in <a href="http://wolframalpha.com" target="_self">WolframAlpha</a>
(avoid <code>i</code> in the integrand as this symbol means
the imaginary unit \( \sqrt{-1} \)).
Asking WolframAlpha also
about \( \int_0^1\sin^2 (j\pi x) \dx \), we find that it equals
1/2.
With a diagonal matrix we can easily solve for the coefficients
by hand:

$$
\begin{equation}
c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) \dx,\quad i\in\If,
\end{equation}
$$

which is nothing but the classical formula for the coefficients of
the Fourier sine series of \( f(x) \) on \( [0,1] \). In fact, when
\( V \) contains the basic functions used in a Fourier series expansion,
the approximation method derived in the section <a href="#fem:approx:global">Approximation of functions</a>
results in the classical Fourier series for \( f(x) \) (see <a href="._approx-sol011.html#fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</a>
for details).

<p>
With orthogonal basis functions we can make the
<code>least_squares</code> function (much) more efficient since we know that
the matrix is diagonal and only the diagonal elements need to be computed:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)
    b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        A[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">**2</span>, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        b[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">*</span>f,  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> [b[i]<span style="color: #666666">/</span>A[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(b))]
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)):
        u <span style="color: #666666">+=</span> c[i]<span style="color: #666666">*</span>psi[i]
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
As mentioned in the section <a href="#fem:approx:global:LS:code">Implementation of the least squares method</a>, symbolic integration
may fail or take very long time. It is therefore natural to extend the
implementation above with a version where we can choose between symbolic
and numerical integration and fall back on the latter if the former
fails:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_orth</span>(f, psi, Omega, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># plain list to hold symbolic expressions</span>
    b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>]<span style="color: #666666">*</span>(N<span style="color: #666666">+1</span>)
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #408080; font-style: italic"># Diagonal matrix term</span>
        A[i] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(psi[i]<span style="color: #666666">**2</span>, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))

        <span style="color: #408080; font-style: italic"># Right-hand side term</span>
        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        <span style="color: #008000; font-weight: bold">if</span> symbolic:
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand,  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> symbolic <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;numerical integration of&#39;</span>, integrand
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        b[i] <span style="color: #666666">=</span> I
    c <span style="color: #666666">=</span> [b[i]<span style="color: #666666">/</span>A[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(b))]
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
This function is found in the file <code>approx1D.py</code>. Observe that
we here assume that
\( \int_\Omega\basphi_i^2\dx \) can always be symbolically computed,
which is not an unreasonable assumption
when the basis functions are orthogonal, but there is no guarantee,
so an improved version of the function above would implement
numerical integration also for the <code>A[i,i]</code> term.

<h2 id="___sec19">Numerical computations </h2>

<p>
Sometimes the basis functions \( \baspsi_i \) and/or the function \( f \)
have a nature that makes symbolic integration CPU-time
consuming or impossible.
Even though we implemented a fall back on numerical integration
of \( \int f\basphi_i \dx \), considerable time might still be required
by <code>sympy</code> just by <em>attempting</em> to integrate symbolically.
Therefore, it will be handy to have function for fast
<em>numerical integration and numerical solution
of the linear system</em>. Below is such a method. It requires
Python functions <code>f(x)</code> and <code>psi(x,i)</code> for \( f(x) \) and \( \baspsi_i(x) \)
as input. The output is a mesh function
with values <code>u</code> on the mesh with points in the array <code>x</code>.
Three numerical integration methods are offered:
<code>scipy.integrate.quad</code> (precision set to \( 10^{-8} \)),
<code>sympy.mpmath.quad</code> (about machine precision), and a Trapezoidal
rule based on the points in <code>x</code> (unknown accuracy, but
increasing with the number of mesh points in <code>x</code>).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares_numerical</span>(f, psi, N, x,
                            integration_method<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scipy&#39;</span>,
                            orthogonal_basis<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.integrate</span>
    A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    Omega <span style="color: #666666">=</span> [x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>]]
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        j_limit <span style="color: #666666">=</span> i<span style="color: #666666">+1</span> <span style="color: #008000; font-weight: bold">if</span> orthogonal_basis <span style="color: #008000; font-weight: bold">else</span> N<span style="color: #666666">+1</span>
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, j_limit):
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;(</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">,</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">)&#39;</span> <span style="color: #666666">%</span> (i, j)
            <span style="color: #008000; font-weight: bold">if</span> integration_method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scipy&#39;</span>:
                A_ij <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>quad(
                    <span style="color: #008000; font-weight: bold">lambda</span> x: psi(x,i)<span style="color: #666666">*</span>psi(x,j),
                    Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], epsabs<span style="color: #666666">=1E-9</span>, epsrel<span style="color: #666666">=1E-9</span>)[<span style="color: #666666">0</span>]
            <span style="color: #008000; font-weight: bold">elif</span> integration_method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;sympy&#39;</span>:
                A_ij <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(
                    <span style="color: #008000; font-weight: bold">lambda</span> x: psi(x,i)<span style="color: #666666">*</span>psi(x,j),
                    [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
            <span style="color: #008000; font-weight: bold">else</span>:
                values <span style="color: #666666">=</span> psi(x,i)<span style="color: #666666">*</span>psi(x,j)
                A_ij <span style="color: #666666">=</span> trapezoidal(values, dx)
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> A_ij

        <span style="color: #008000; font-weight: bold">if</span> integration_method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scipy&#39;</span>:
            b_i <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>quad(
                <span style="color: #008000; font-weight: bold">lambda</span> x: f(x)<span style="color: #666666">*</span>psi(x,i), Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>],
                epsabs<span style="color: #666666">=1E-9</span>, epsrel<span style="color: #666666">=1E-9</span>)[<span style="color: #666666">0</span>]
        <span style="color: #008000; font-weight: bold">elif</span> integration_method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;sympy&#39;</span>:
            b_i <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(
                <span style="color: #008000; font-weight: bold">lambda</span> x: f(x)<span style="color: #666666">*</span>psi(x,i), [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        <span style="color: #008000; font-weight: bold">else</span>:
            values <span style="color: #666666">=</span> f(x)<span style="color: #666666">*</span>psi(x,i)
            b_i <span style="color: #666666">=</span> trapezoidal(values, dx)
        b[i] <span style="color: #666666">=</span> b_i

    c <span style="color: #666666">=</span> b<span style="color: #666666">/</span>np<span style="color: #666666">.</span>diag(A) <span style="color: #008000; font-weight: bold">if</span> orthogonal_basis <span style="color: #008000; font-weight: bold">else</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi(x, i) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>))
    <span style="color: #008000; font-weight: bold">return</span> u, c

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">trapezoidal</span>(values, dx):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Integrate values by the Trapezoidal rule (mesh size dx).&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> dx<span style="color: #666666">*</span>(np<span style="color: #666666">.</span>sum(values) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>values[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>values[<span style="color: #666666">-1</span>])
</pre></div>
<p>
Here is an example on calling the function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, tanh, pi

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">psi</span>(x, i):
    <span style="color: #008000; font-weight: bold">return</span> sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x)

x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">2*</span>pi, <span style="color: #666666">501</span>)
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>
u, c <span style="color: #666666">=</span> least_squares_numerical(<span style="color: #008000; font-weight: bold">lambda</span> x: tanh(x<span style="color: #666666">-</span>pi), psi, N, x,
                               orthogonal_basis<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>

<h2 id="fem:approx:global:interp">The interpolation (or collocation) method</h2>

<p>
The principle of minimizing the distance between \( u \) and \( f \) is
an intuitive way of computing a best approximation \( u\in V \) to \( f \).
However, there are other approaches as well.
One is to demand that \( u(\xno{i}) = f(\xno{i}) \) at some selected points
\( \xno{i} \), \( i\in\If \):

$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i\in\If\tp \end{equation}
$$

We recognize that the equation \( \sum_j c_j \baspsi_j(\xno{i}) = f(\xno{i}) \)
is actually a linear system with \( N+1 \) unknown coefficients \( \sequencej{c} \):

$$
\begin{equation}
\sum_{j\in\If} A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation}
$$

with coefficient matrix and right-hand side vector given by

$$
\begin{align}
A_{i,j} &= \baspsi_j(\xno{i}),\\ 
b_i &= f(\xno{i})\tp  \end{align}
$$

This time the coefficient matrix is not symmetric because
\( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general.
The method is often referred to as an <em>interpolation method</em>
since some point values of \( f \) are given (\( f(\xno{i}) \)) and we
fit a continuous function \( u \) that goes through the \( f(\xno{i}) \) points.
In this case the \( \xno{i} \) points are called <em>interpolation points</em>.
When the same approach is used to approximate differential equations,
one usually applies the name <em>collocation method</em> and
\( \xno{i} \) are known as <em>collocation points</em>.

<p>
Given \( f \)  as a <code>sympy</code> symbolic expression <code>f</code>, \( \sequencei{\baspsi} \)
as a list <code>psi</code>, and a set of points \( \sequencei{x} \)  as a list or array
<code>points</code>, the following Python function sets up and solves the matrix system
for the coefficients \( \sequencei{c} \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">interpolation</span>(f, psi, points):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    psi_sym <span style="color: #666666">=</span> psi  <span style="color: #408080; font-style: italic"># save symbolic expression</span>
    <span style="color: #408080; font-style: italic"># Turn psi and f into Python functions</span>
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> psi[j](points[i])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> f(points[i])
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    <span style="color: #408080; font-style: italic"># c is a sympy Matrix object, turn to list</span>
    c <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(c[i,<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]
    u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(<span style="color: #008000">sum</span>(c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>psi_sym[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
The <code>interpolation</code> function is a part of the <code>approx1D</code>
module.

<p>
We found it convenient in the above function to turn the expressions <code>f</code> and
<code>psi</code> into ordinary Python functions of <code>x</code>, which can be called with
<code>float</code> values in the list <code>points</code> when building the matrix and
the right-hand side. The alternative is to use the <code>subs</code> method
to substitute the <code>x</code> variable in an expression by an element from
the <code>points</code> list. The following session illustrates both approaches
in a simple setting:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> e <span style="color: #666666">=</span> x<span style="color: #666666">**2</span>              <span style="color: #408080; font-style: italic"># symbolic expression involving x</span>
<span style="color: #666666">&gt;&gt;&gt;</span> p <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>               <span style="color: #408080; font-style: italic"># a value of x</span>
<span style="color: #666666">&gt;&gt;&gt;</span> v <span style="color: #666666">=</span> e<span style="color: #666666">.</span>subs(x, p)      <span style="color: #408080; font-style: italic"># evaluate e for x=p</span>
<span style="color: #666666">&gt;&gt;&gt;</span> v
<span style="color: #666666">0.250000000000000</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(v)
sympy<span style="color: #666666">.</span>core<span style="color: #666666">.</span>numbers<span style="color: #666666">.</span>Float
<span style="color: #666666">&gt;&gt;&gt;</span> e <span style="color: #666666">=</span> lambdify([x], e)  <span style="color: #408080; font-style: italic"># make Python function of e</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(e)
<span style="color: #666666">&gt;&gt;&gt;</span> function
<span style="color: #666666">&gt;&gt;&gt;</span> v <span style="color: #666666">=</span> e(p)              <span style="color: #408080; font-style: italic"># evaluate e(x) for x=p</span>
<span style="color: #666666">&gt;&gt;&gt;</span> v
<span style="color: #666666">0.25</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000">type</span>(v)
<span style="color: #008000">float</span>
</pre></div>
<p>
A nice feature of the interpolation or collocation method is that it
avoids computing integrals. However, one has to decide on the location
of the \( \xno{i} \) points.  A simple, yet common choice, is to
distribute them uniformly throughout \( \Omega \).

<h3 id="___sec21">Example </h3>

<p>
Let us illustrate the interpolation method by approximating
our parabola \( f(x)=10(x-1)^2-1 \) by a linear function on \( \Omega=[1,2] \),
using two collocation points \( x_0=1+1/3 \) and \( x_1=1+2/3 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
psi <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, x]
Omega <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]
points <span style="color: #666666">=</span> [<span style="color: #666666">1</span> <span style="color: #666666">+</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">3</span>), <span style="color: #666666">1</span> <span style="color: #666666">+</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">2</span>,<span style="color: #666666">3</span>)]
u, c <span style="color: #666666">=</span> interpolation(f, psi, points)
comparison_plot(f, u, Omega)
</pre></div>
<p>
The resulting linear system becomes

$$
\begin{equation*}
\left(\begin{array}{ll}
1 & 4/3\\ 
1 & 5/3\\ 
\end{array}\right)
\left(\begin{array}{l}
c_0\\ 
c_1\\ 
\end{array}\right)
=
\left(\begin{array}{l}
1/9\\ 
31/9\\ 
\end{array}\right)
\end{equation*}
$$

with solution \( c_0=-119/9 \) and \( c_1=10 \).
Figure <a href="#fem:approx:global:linear:interp:fig1">6</a> (left) shows the resulting
approximation \( u=-119/9 + 10x \).
We can easily test other interpolation points, say \( x_0=1 \) and \( x_1=2 \).
This changes the line quite significantly, see
Figure <a href="#fem:approx:global:linear:interp:fig1">6</a> (right).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right).  <div id="fem:approx:global:linear:interp:fig1"></div> </p></center>
<p><img src="fig-approx/parabola_inter.png" align="bottom" width=800></p>
</center>

<h2 id="fem:approx:global:regression">The regression method</h2>

<p>
The interpolation method in the previous section used exactly
\( N+1 \) interpolation points. An alternative is to use \( m+1>N+1 \)
interpolation points \( \xno{0},\xno{1},\ldots,\xno{m} \).
This is particularly relevant if \( f \) is just known
through measured point values and we have many such values.
The resulting method is called <em>regression</em> and
is well known from statistics when fitting a simple (usually polynomial)
function to a set of data points.

<h3 id="___sec23">Overdetermined equation system </h3>

<p>
Intuitively, we would demand \( u \) to equal \( f \) at all the
data points \( \xno{i} \), \( i0,1,\ldots,m \),

$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i=0,1,\ldots,m\tp
\end{equation}
$$

The fundamental problem here is that we have more equations than
unknowns since there are \( N+1 \) unknowns and \( m+1>N+1 \) equations.
Such a system of equations is called an <em>overdetermined system</em>.
We can write it matrix form as

$$
\begin{equation}
\sum_{j\in\If} A_{i,j}c_j = b_i,\quad i=0,1,\ldots,m,
\end{equation}
$$

with coefficient matrix and right-hand side vector given by

$$
\begin{align}
A_{i,j} &= \baspsi_j(\xno{i}),
\tag{21}\\ 
b_i &= f(\xno{i})\tp
\tag{22}
\end{align}
$$

Note that the matrix is a <em>rectangular</em> \( (m+1)\times(N+1) \)
matrix since \( i=0,\ldots,m \) and \( j=0,\ldots,N \).

<h3 id="___sec24">The normal equations derived from a least squares principle </h3>

<p>
The least squares method is a common technique for solving
overdetermined equations systems. Let us write the overdetermined
system \( \sum_{j\in\If} A_{i,j}c_j = b_i \) more compactly in matrix form
as \( Ac=b \).  Since we have more equations than unknowns, it is (in
general) impossible to find a vector \( c \) that fulfills \( Ac=b \). The
best we can do is to make the residual \( r=b-Ac \) as small as
possible. That is, we can find \( c \) such it minimizes the norm
Euclidean norm of \( r \): \( ||r|| \).  The algebra simplifies significantly
by minimizing \( ||r||^2 \) instead.  This principle corresponds to a
least squares method.

<p>
The \( i \)-th component of \( r \) reads \( r_i = b_i -\sum_jA_{i,j}c_j \),
so \( ||r||^2 = \sum_ir_i^2 \).
Minimizing \( ||r||^2 \) with respect to the unknowns \( c_0,\ldots,c_N \)
implies that

$$
\begin{equation}
\frac{\partial}{\partial k}||r||^2=0,\quad k=0,\ldots,N,
\tag{23}
\end{equation}
$$

which leads to

$$ \frac{\partial}{\partial k}\sum_i r_i^2 =
\sum_i 2r_i\frac{\partial r_i}{\partial k}
=\sum_i 2r_i \frac{\partial}{\partial k}(b_i -\sum_jA_{i,j}c_j)
= 2\sum_i r_i(-A_{i,k}) = 0\tp$$

By inserting \( r_i = b_i -\sum_jA_{i,j}c_j \) the last expression we
get

$$ \sum_i\left(b_i -\sum_jA_{i,j}c_j\right)\left(-A_{i,k}\right)
= -\sum_i b_iA_{i,k} + \sum_j (\sum_i A_{i,j}A_{i,k})c_j = 0\tp$$

Introducing the transpose of \( A \), \( A^T \), we know that \( A^T_{i,j}=A_{j,i} \),
to the expression \( \sum_i A_{i,j}A_{i,k} \) can be written
as \( \sum_i A^T{k,i}A_{i,j} \) and recognized as the formula for the
matrix-matrix product \( A^TA \). Also, \( \sum_i b_i A_{i,k} \) can be written
\( \sum_i A^T_{k,i}b_i \) and recognized as the matrix-vector product
\( A^Tb \). These observations imply that <a href="#mjx-eqn-23">(23)</a>
is equivalent to the linear system

$$
\begin{equation}
\sum_j (\underbrace{\sum_i A^T{k,i}A_{i,j}}{=(A^TA)_{k,j}}
c_j = \sum_i \underbrace{A^T_{k,i}b_i}{=(A^Tb)_k},\quad k=0,\ldots,N,
\tag{24}
\end{equation}
$$

or in matrix form,

$$
\begin{equation}
 A^TA = A^Tb\tp
\tag{25}
\end{equation}
$$

The equation system <a href="#mjx-eqn-24">(24)</a> or
<a href="#mjx-eqn-25">(25)</a> are known as the
<em>normal equations</em>.
With \( A \) as an \( (m+1)\times (N+1) \) matrix, \( A^TA \) becomes an \( (N+1)\times (N+1) \)
matrix, and \( A^Tb \) becomes a vector of length \( N+1 \). Often, \( m\gg N \),
so \( A^TA \) has much smaller size than \( A \).

<p>
Many prefer to write the linear system <a href="#mjx-eqn-24">(24)</a> on the standard form \( \sum_j B_{i,j}=d_i \), \( i=0,\ldots,N \).
We can easily do so by exchanging the \( i \) and \( k \) index (\( i\leftrightarrow k \)),
\( \sum_i A^T{k,i}A_{i,j} = \sum_k A^T{i,k}A_{k,j} \), and setting
\( B_{i,j}=\sum_k A^T{i,k}A_{k,j} \). Similarly, we exchange \( i \) and \( k \) in
the right-hand side expression and get \( \sum_k A^T_{i,k}b_k = d_i \).
Expressing \( B_{i,j} \) and \( d_i \) in terms of the \( \baspsi_i \) and \( \xno{i} \),
using <a href="#mjx-eqn-21">(21)</a> and
<a href="#mjx-eqn-22">(22)</a>, we end up with the formulas

$$
\begin{align}
B_{i,j} &= \sum_k A^T{i,k}A_{k,j} = \sum_k A{k,i}A_{k,j}
=\sum_{k=0}^m\baspsi_i(\xno{k}\baspsi_j(\xno{k},
\tag{26}\\ 
d_i &=\sum_k A^T_{i,k}b_k = \sum_k A_{k,i}b_k =\sum_{k=0}^m
\baspsi_i(\xno{k})f(\xno{k})
\tag{27}
\end{align}
$$

<h3 id="___sec25">Implementation </h3>

<p>
The following function defines the matrix entries \( B_{i,j} \) according to
<a href="#mjx-eqn-26">(26)</a> and the right-hand side
entries \( d_i \) according <a href="#mjx-eqn-27">(27)</a>. Thereafter,
it solves the linear system \( \sum_jB_{i,j}c_j=d_i \).
The input data <code>f</code> and <code>psi</code> hold \( f(x) \) and \( \xno{i} \), \( i=0,\ldots,N \),
as symbolic expression, but
since \( m \) is thought to be much larger than \( N \), and there are
loops from \( 0 \) to \( m \), we use numerical computing
to speed up the computations.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">regression</span>(f, psi, points):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(points)
    <span style="color: #408080; font-style: italic"># Use numpy arrays and numerical computing</span>
    B <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    <span style="color: #408080; font-style: italic"># Wrap psi and f in Python functions rather than expressions</span>
    <span style="color: #408080; font-style: italic"># so that we can evaluate psi at points[i]</span>
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    psi_sym <span style="color: #666666">=</span> psi  <span style="color: #408080; font-style: italic"># save symbolic expression</span>
    psi <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>lambdify([x], psi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
            B[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m<span style="color: #666666">+1</span>):
                B[i,j] <span style="color: #666666">+=</span> psi[i](points[k])<span style="color: #666666">*</span>psi[j](points[k])
        d[i] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m<span style="color: #666666">+1</span>):
            d[i] <span style="color: #666666">+=</span> psi[i](points[k])<span style="color: #666666">*</span>f(points[k])
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(B, d)
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi_sym[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>

<h3 id="___sec26">Example </h3>

<p>
We repeat the computational example from
the section <a href="#fem:approx:global:interp">The interpolation (or collocation) method</a>, but this time with many more
points. The parabola \( f(x)=10(x-1)^2-1 \) is to be
approximated by a linear function on \( \Omega=[1,2] \). We divide
\( \Omega \) into \( m+2 \) intervals and use the inner \( m+1 \) points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
psi <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, x]
Omega <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]
m_values <span style="color: #666666">=</span> [<span style="color: #666666">2-1</span>, <span style="color: #666666">8-1</span>, <span style="color: #666666">64-1</span>]
<span style="color: #408080; font-style: italic"># Create m+3 points and use the inner m+1 points</span>
<span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> m_values:
    points <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], m<span style="color: #666666">+3</span>)[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
    u, c <span style="color: #666666">=</span> regression(f, psi, points)
    comparison_plot(
        f, u, Omega,
        filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;parabola_by_regression_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (m<span style="color: #666666">+1</span>),
        points<span style="color: #666666">=</span>points,
        points_legend<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> interpolation points&#39;</span> <span style="color: #666666">%</span> (m<span style="color: #666666">+1</span>),
        legend_loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
</pre></div>
<p>
Figure <a href="#fem:approx:global:linear:regression:fig1">7</a> shows results for
\( m+1=2 \) (left), \( m+1=8 \) (middle), and \( m+1=64 \) (right) data points.
The approximating function is not so sensitive to the number of
points as long as they cover a significant part of the domain (2 points
are too much in the middle, but 8 points cover almost the entire
domain, and 64 points do not improve the results much):

$$
\begin{align*}
u(x) &= 10x - 13.2,\quad 2\hbox{ points}\\ 
u(x) &= 10x - 12.7,\quad 8\hbox{ points}\\ 
u(x) &= 10x - 12.7,\quad 64\hbox{ points}
\end{align*}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Approximation of a parabola by a regression method with varying number of points.  <div id="fem:approx:global:linear:regression:fig1"></div> </p></center>
<p><img src="fig-approx/parabola_by_regression.png" align="bottom" width=800></p>
</center>

<p>
To explicitly make the link to classical regression in statistics, we
consider \( f=10(x-1)^2 - 1 + \epsilon \), where \( \epsilon \) is a random,
normally distributed variable. The goal in classical regression is
to find the straight line that best fits the data points (in a least
squares sense). The only difference from the previous setup, is that
the \( f(\xno{i}) \) values are based on a function formula, here \( 10(x-1)^2-1 \),
<em>plus</em> normally distributed noise.
Figure <a href="#fem:approx:global:linear:regression:fig2">8</a> shows three sets of
data points, along with the original \( f(x) \) function without noise, and
the straight line that is a least squares approximation to the data points.
<!-- python ex_approx1D.py run_noisy_parabola_by_regression -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Approximation of a parabola with noise by a straight line.  <div id="fem:approx:global:linear:regression:fig2"></div> </p></center>
<p><img src="fig-approx/noisy_parabola_by_linear_regression.png" align="bottom" width=800></p>
</center>

<p>
We can fit a parabola instead of a straight line, as done in
Figure <a href="#fem:approx:global:linear:regression:fig3">9</a>. When \( m \) becomes large,
the fitted parabola and the original parabola without noise become very close.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Approximation of a parabola with noise by a parabola.  <div id="fem:approx:global:linear:regression:fig3"></div> </p></center>
<p><img src="fig-approx/noisy_parabola_by_linear_regression.png" align="bottom" width=800></p>
</center>

<h3 id="___sec27">Remark </h3>

<p>
The regression method is not much used for approximating differential
equations or given function, but is central in uncertainty quantification
methods such as polynomial chaos expansions.

<h2 id="fem:approx:global:Lagrange">Lagrange polynomials</h2>

<p>
In the section <a href="#fem:approx:global:Fourier">Fourier series</a> we explained the advantage with having
a diagonal matrix: formulas for the coefficients \( \sequencei{c} \) can
then be derived by hand. For an interpolation (or collocation) method a
diagonal matrix implies that
\( \baspsi_j(\xno{i}) = 0 \) if \( i\neq j \). One set of basis functions \( \baspsi_i(x) \)
with this property is the <em>Lagrange interpolating polynomials</em>,
or just <em>Lagrange polynomials</em>. (Although the functions are named
after Lagrange, they were first discovered by Waring in 1779,
rediscovered by Euler in 1783, and published by Lagrange in 1795.)
Lagrange polynomials key building blocks in the finite element method, so
familiarity with these polynomials will be required anyway.

<p>
A Lagrange polynomial can be written as

$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\tag{28}
\end{equation}
$$

for \( i\in\If \).
We see from <a href="#mjx-eqn-28">(28)</a> that all the \( \baspsi_i \)
functions are polynomials of degree \( N \) which have the property

$$
\begin{equation}
\baspsi_i(x_s) = \delta_{is},\quad \delta_{is} =
\left\lbrace\begin{array}{ll}
1, & i=s,\\ 
0, & i\neq s,
\end{array}\right.
\tag{29}
\end{equation}
$$

when \( x_s \) is an interpolation (collocation) point.
Here we have used the <em>Kronecker delta</em> symbol \( \delta_{is} \).
This property implies that \( A_{i,j}=0 \) for \( i\neq j \) and
\( A_{i,j}=1 \) when \( i=j \). The solution of the linear system is
then simply

$$
\begin{equation}
c_i = f(\xno{i}),\quad i\in\If,
\end{equation}
$$

and

$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)\tp  \end{equation}
$$

<p>
The following function computes the Lagrange interpolating polynomial
\( \baspsi_i(x) \), given the interpolation points \( \xno{0},\ldots,\xno{N} \) in
the list or array <code>points</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(points)):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #008000; font-weight: bold">return</span> p
</pre></div>
<p>
The next function computes a complete basis using equidistant points throughout
\( \Omega \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomials_01</span>(x, N):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, sym<span style="color: #666666">.</span>Symbol):
        h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>, N<span style="color: #666666">-1</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(N<span style="color: #666666">-1</span>)
    points <span style="color: #666666">=</span> [i<span style="color: #666666">*</span>h <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N)]
    psi <span style="color: #666666">=</span> [Lagrange_polynomial(x, i, points) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N)]
    <span style="color: #008000; font-weight: bold">return</span> psi, points
</pre></div>
<p>
When <code>x</code> is an <code>sym.Symbol</code> object, we let the
spacing between
the interpolation points, <code>h</code>, be a <code>sympy</code> rational number, so
that we get nice end results in the formulas for \( \baspsi_i \).
The other case, when <code>x</code> is a plain Python <code>float</code>,
signifies numerical computing, and then we let <code>h</code> be a floating-point
number.
Observe that the <code>Lagrange_polynomial</code> function works equally well
in the symbolic and numerical case - just think of <code>x</code> being an
<code>sym.Symbol</code> object or a Python <code>float</code>.
A little interactive session illustrates the difference between symbolic
and numerical computing of the basis functions and points:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> psi, points <span style="color: #666666">=</span> Lagrange_polynomials_01(x, N<span style="color: #666666">=3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> points
[<span style="color: #666666">0</span>, <span style="color: #666666">1/2</span>, <span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> psi
[(<span style="color: #666666">1</span> <span style="color: #666666">-</span> x)<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>x), <span style="color: #666666">2*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">2</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>x), <span style="color: #666666">-</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>x)]

<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>  <span style="color: #408080; font-style: italic"># numerical computing</span>
<span style="color: #666666">&gt;&gt;&gt;</span> psi, points <span style="color: #666666">=</span> Lagrange_polynomials_01(x, N<span style="color: #666666">=3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> points
[<span style="color: #666666">0.0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1.0</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> psi
[<span style="color: #666666">-0.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">0.0</span>]
</pre></div>
<p>
The Lagrange polynomials are very much used in finite element methods
because of their property <a href="#mjx-eqn-29">(29)</a>.

<h3 id="___sec29">Approximation of a polynomial </h3>

<p>
The Galerkin or least squares method lead to an exact approximation
if \( f \) lies in the space spanned by the basis functions. It could be
of interest to see how the interpolation method with Lagrange
polynomials as basis is able to approximate a polynomial, e.g.,
a parabola. Running

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>, <span style="color: #666666">8</span>, <span style="color: #666666">10</span>, <span style="color: #666666">12</span>:
    f <span style="color: #666666">=</span> x<span style="color: #666666">**2</span>
    psi, points <span style="color: #666666">=</span> Lagrange_polynomials_01(x, N)
    u <span style="color: #666666">=</span> interpolation(f, psi, points)
</pre></div>
<p>
shows the result that up to <code>N=4</code> we achieve an exact approximation,
and then round-off errors start to grow, such that
<code>N=15</code> leads to a 15-degree polynomial for \( u \) where
the coefficients in front of \( x^r \) for \( r>2 \) are
of size \( 10^{-5} \) and smaller.

<h3 id="___sec30">Successful example </h3>

<p>
Trying out the Lagrange polynomial basis for approximating
\( f(x)=\sin 2\pi x \) on \( \Omega =[0,1] \) with the least squares
and the interpolation techniques can be done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>sin(<span style="color: #666666">2*</span>sym<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x)
psi, points <span style="color: #666666">=</span> Lagrange_polynomials_01(x, N)
Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
u, c <span style="color: #666666">=</span> least_squares(f, psi, Omega)
comparison_plot(f, u, Omega)
u, c <span style="color: #666666">=</span> interpolation(f, psi, points)
comparison_plot(f, u, Omega)
</pre></div>
<p>
Figure <a href="#fem:approx:global:Lagrange:fig:sine:ls:colloc">10</a> shows the results.
There is little difference between the least squares and the interpolation
technique. Increasing \( N \) gives visually better approximations.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 3. <div id="fem:approx:global:Lagrange:fig:sine:ls:colloc"></div> </p></center>
<p><img src="fig-approx/Lagrange_ls_interp_sin_4.png" align="bottom" width=800></p>
</center>

<h3 id="___sec31">Less successful example </h3>

<p>
The next example concerns interpolating \( f(x)=|1-2x| \) on
\( \Omega =[0,1] \) using Lagrange polynomials. Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14">11</a> shows a peculiar effect: the approximation starts to oscillate
more and more as \( N \) grows. This numerical artifact is not surprising
when looking at the individual Lagrange polynomials. Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:osc">12</a> shows two such polynomials, \( \psi_2(x) \) and
\( \psi_7(x) \), both of degree 11 and computed from uniformly spaced
points \( \xno{x_i}=i/11 \), \( i=0,\ldots,11 \), marked with circles.
We clearly see the property of Lagrange polynomials:
\( \psi_2(\xno{i})=0 \) and \( \psi_7(\xno{i})=0 \) for all \( i \),
except \( \psi_2(\xno{2})=1 \) and \( \psi_7(\xno{7})=1 \).
The most striking feature, however, is the significant oscillation
near the boundary. The reason is easy to understand:
since we force the functions to zero at so many points,
a polynomial of high degree is forced to oscillate between
the points.
The phenomenon is named <em>Runge's phenomenon</em> and you can read
a more detailed explanation on <a href="http://en.wikipedia.org/wiki/Runge%27s_phenomenon" target="_self">Wikipedia</a>.

<h3 id="___sec32">Remedy for strong oscillations </h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\end{equation}
$$

on the interval \( \Omega = [a,b] \).
Here is a flexible version of the <code>Lagrange_polynomials_01</code> function above,
valid for any interval \( \Omega =[a,b] \) and with the possibility to generate
both uniformly distributed points and Chebyshev nodes:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomials</span>(x, N, Omega, point_distribution<span style="color: #666666">=</span><span style="color: #BA2121">&#39;uniform&#39;</span>):
    <span style="color: #008000; font-weight: bold">if</span> point_distribution <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;uniform&#39;</span>:
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, sym<span style="color: #666666">.</span>Symbol):
            h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Rational(Omega[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega[<span style="color: #666666">0</span>], N)
        <span style="color: #008000; font-weight: bold">else</span>:
            h <span style="color: #666666">=</span> (Omega[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega[<span style="color: #666666">0</span>])<span style="color: #666666">/</span><span style="color: #008000">float</span>(N)
        points <span style="color: #666666">=</span> [Omega[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">elif</span> point_distribution <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Chebyshev&#39;</span>:
        points <span style="color: #666666">=</span> Chebyshev_nodes(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], N)
    psi <span style="color: #666666">=</span> [Lagrange_polynomial(x, i, points) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">return</span> psi, points

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Chebyshev_nodes</span>(a, b, N):
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> cos, pi
    <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #666666">0.5*</span>(a<span style="color: #666666">+</span>b) <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">*</span>cos(<span style="color: #008000">float</span>(<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>N<span style="color: #666666">+1</span>))<span style="color: #666666">*</span>pi) \ 
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
</pre></div>
<p>
All the functions computing Lagrange polynomials listed
above are found in the module file <code>Lagrange.py</code>.

<p>
Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14">13</a> shows the improvement of
using Chebyshev nodes, compared with the equidistant points in
Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14">11</a>.
The reason for this improvement is that the corresponding Lagrange
polynomials have much smaller oscillations, which can be seen by
comparing Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:Cheb:osc">14</a>
(Chebyshev points)
with Figure <a href="#fem:approx:global:Lagrange:fig:abs:Lag:unif:osc">12</a>
(equidistant points). Note the different scale on the vertical axes in
the two figures.

<p>
Another cure for undesired oscillations of higher-degree interpolating
polynomials is to use lower-degree Lagrange
polynomials on many small patches of the domain. This is actually the idea
pursued in the finite element method. For instance, linear Lagrange
polynomials on \( [0,1/2] \) and \( [1/2,1] \) would yield a perfect
approximation to \( f(x)=|1-2x| \) on \( \Omega = [0,1] \)
since \( f \) is piecewise linear.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right).  <div id="fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14"></div> </p></center>
<p><img src="fig-approx/Lagrange_interp_abs_8_15.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Illustration of the oscillatory behavior of two Lagrange polynomials based on 12 uniformly spaced points (marked by circles).  <div id="fem:approx:global:Lagrange:fig:abs:Lag:unif:osc"></div> </p></center>
<p><img src="fig-approx/Lagrange_basis_12.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right).  <div id="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14"></div> </p></center>
<p><img src="fig-approx/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  Illustration of the less oscillatory behavior of two Lagrange polynomials based on 12 Chebyshev points (marked by circles).  <div id="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:osc"></div> </p></center>
<p><img src="fig-approx/Lagrange_basis_Cheb_12.png" align="bottom" width=400></p>
</center>

<p>
How does the least squares or projection methods work with Lagrange
polynomials?
We can just call the <code>least_squares</code> function, but
<code>sympy</code> has problems integrating the \( f(x)=|1-2x| \)
function times a polynomial, so we need to fall back on numerical
integration.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, psi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(psi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>psi[j]
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
                <span style="color: #408080; font-style: italic"># Could not integrate symbolically, fall back</span>
                <span style="color: #408080; font-style: italic"># on numerical integration with mpmath.quad</span>
                integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
                I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
            A[i,j] <span style="color: #666666">=</span> A[j,i] <span style="color: #666666">=</span> I
        integrand <span style="color: #666666">=</span> psi[i]<span style="color: #666666">*</span>f
        I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(I, sym<span style="color: #666666">.</span>Integral):
            integrand <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], integrand)
            I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    c <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(c[i,<span style="color: #666666">0</span>]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(c<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])]
    u <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(c[i]<span style="color: #666666">*</span>psi[i] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi)))
    <span style="color: #008000; font-weight: bold">return</span> u, c
</pre></div>
<p>
<!-- Convergence of Lagrange polynomials. -->

<p>
The idea of avoiding oscillatory solutions by
using lower-order Lagrange polynomials on smaller patches
throughout the domain, is important in the finite element
method, and the next section introduces finite element basis
functions based on Lagrange polynomials.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._approx-sol002.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._approx-sol004.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

