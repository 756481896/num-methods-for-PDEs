<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec23'),
              ('Successful example', 3, None, '___sec24'),
              ('Less successful example', 3, None, '___sec25'),
              ('Remedy for strong oscillations', 3, None, '___sec26'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec29'),
              ('The basis functions', 2, None, '___sec30'),
              ('Construction principles', 3, None, '___sec31'),
              ('Properties of $\\basphi_i$', 3, None, '___sec32'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec33'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec34'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec35'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec37'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec38'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec40'),
              ('Assembly of element matrices', 3, None, '___sec41'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec42'),
              ('The element vector', 3, None, '___sec43'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec45'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec46'),
              ('Formulas for local basis functions', 3, None, '___sec47'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               None,
               '___sec61'),
              ('Computations in physical space', 3, None, '___sec62'),
              ('Elementwise computations', 3, None, '___sec63'),
              ('Terminology', 3, None, '___sec64'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec71'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec73'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec76'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec79'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec80'),
              ('Element matrices and vectors', 3, None, '___sec81'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec82'),
              ('Affine mapping of the reference cell', 2, None, '___sec83'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec84'),
              ('Computing integrals', 2, None, '___sec85'),
              ('Exercises', 1, None, '___sec86'),
              ('Exercise 1: Linear algebra refresher I',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Exercise 2: Linear algebra refresher II',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              ('Exercise 3: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Exercise 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Exercise 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Exercise 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec93'),
              ('Exercise 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec95'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Exercise 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Exercise 10: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Exercise 11: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Exercise 12: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Exercise 13: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Exercise 14: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Exercise 15: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 16: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Exercise 17: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 18: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 19: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Problem 20: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 21: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 22: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec111')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0011"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized010.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized012.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec86">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg1">Exercise 1: Linear algebra refresher I</h2>

<p>
Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.
Prove that vectors in the plane \( (a,b) \) form a vector space
by showing that all the axioms of a vector space
are satisfied. Similarly,
prove that all linear functions of the form \( ax+b \) constitute a vector space,
\( a,b\in\Real \).

<p>
On the contrary,
show that all quadratic functions of the form \( 1 + ax^2 + bx \) <em>do not</em>
constitute a vector space.
Filename: <code>linalg1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg2">Exercise 2: Linear algebra refresher II</h2>

<p>
As an extension of <a href="#fem:approx:exer:linalg1">Exercise 1: Linear algebra refresher I</a>, check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form \( ax+b \), \( a,b\in\Real \).
Show that this inner product satisfies the
general requirements of an inner product in a vector space.
Filename: <code>linalg2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:vec:3Dby2D">Exercise 3: Approximate a three-dimensional vector in a plane</h2>

<p>
Given \( \f = (1,1,1) \) in \( \Real^3 \), find the best approximation vector
\( \u \) in the plane spanned by the unit vectors \( (1,0) \) and \( (0,1) \).
Repeat the calculations using the vectors \( (2,1) \) and \( (1,2) \).

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>vec111_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:exp:powers">Exercise 4: Approximate the exponential function by power functions</h2>

<p>
Let \( V \) be a function space with basis functions \( x^i \),
\( i=0,1,\ldots,N \).  Find the best approximation to \( f(x)=\exp(-x) \) on
\( \Omega =[0,8] \) among all functions in \( V \) for \( N=2,4,6 \). Illustrate
the three approximations in three separate plots.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Apply the <code>lest_squares</code> and
<code>comparison_plot</code> functions in the <code>approx1D.py</code> module as these
make the exercise easier to solve.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>exp_powers</code>.

<p>
<!-- Taylor: these polynomials go so far off on [0,8] that it is not a -->
<!-- good idea to add them. -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:sin:powers">Exercise 5: Approximate the sine function by power functions</h2>

<p>
In this exercise we want to approximate the sine function by polynomials
of order \( N+1 \). Consider two bases:

$$
\begin{align*}
V_1 &= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\ 
V_2 &= \{1,x,x^2,x^3,\ldots, x^N\}\tp
\end{align*}
$$

The basis \( V_1 \) is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while \( V_2 \)
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.

<p>
Compute the best approximation to \( f(x)=\sin(x) \) among all functions
in \( V_1 \) and \( V_2 \) on two domains of increasing sizes: \( \Omega_{1,k} =
[0, k\pi] \), \( k=2,3\ldots,6 \) and \( \Omega_{2,k} = [-k\pi /2, k\pi/2] \),
\( k=2,3,4,5 \).  Make plots for all combinations of \( V_1 \), \( V_2 \),
\( \Omega_1 \), \( \Omega_2 \), \( k=2,3,\ldots,6 \).

<p>
Add a plot of the \( N \)-th degree Taylor polynomial approximation of
\( \sin(x) \) around \( x=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can make a loop over \( V_1 \) and \( V_2 \), a loop over
\( \Omega_1 \) and \( \Omega_2 \), and a loop over \( k \). Inside the loops,
call the functions <code>least_squares</code> and
<code>comparison_plot</code> from the <code>approx1D</code> module.
\( N=7 \) is a suggested value.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>sin_powers</code>.

<p>
<!-- Solveig explanations based on f-B approx -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine1">Exercise 6: Approximate a steep function by sines</h2>

<p>
Find the best approximation of \( f(x) = \tanh (s(x-\pi)) \) on
\( [0, 2\pi] \) in the space \( V \) with basis
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
Make a movie showing how \( u=\sum_{j\in\If}c_j\baspsi_j(x) \)
approximates \( f(x) \) as \( N \) grows. Choose \( s \) such that \( f \) is
steep (\( s=20 \) is appropriate).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 1.</b>
One may naively call the <code>least_squares_orth</code> and <code>comparison_plot</code>
from the <code>approx1D</code> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <code>least_squares_orth</code>
compute with only one basis function at a time and accumulate
the corresponding <code>u</code> in the total solution.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 2.</b>
<code>ffmpeg</code> or <code>avconv</code> may skip frames when plot files are combined to
a movie. Since there are few files and we want to see each of them,
use <code>convert</code> to make an animated GIF file (<code>-delay 200</code> is
suitable).

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_sines_approx</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec93">Remarks </h3>

<p>
Approximation of a discontinuous (or steep) \( f(x) \) by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in \( f \).
This is known as the <a href="http://en.wikipedia.org/wiki/Gibbs_phenomenon" target="_self">Gibb's phenomenon</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine3">Exercise 7: Approximate a steep function by sines with boundary adjustment</h2>

<p>
We study the same approximation problem as in
<a href="#fem:approx:exer:tanh:sine1">Exercise 6: Approximate a steep function by sines</a>. Since \( \baspsi_i(0)=\baspsi_i(2\pi)=0 \)
for all \( i \), \( u=0 \) at the boundary points \( x=0 \) and \( x=2\pi \), while
\( f(0)=-1 \) and \( f(2\pi)=1 \). This discrepancy at the boundary can be
removed by adding a boundary function \( B(x) \):

$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
$$

where \( B(x) \) has the right boundary values: \( B(x_L)=f(x_L) \) and
\( B(x_R)=f(x_R) \), with \( x_L=0 \) and \( x_R=2\pi \) as the boundary points.
A linear choice of \( B(x) \) is

$$ B(x) = \frac{(x_R-x)f(x_L) + (x-x_L)f(x_R)}{x_R-x_L}\tp$$

<p>
<b>a)</b>
Use the basis
\( \baspsi_i(x) = \sin((i+1)x) \), \( i\in\If = \{0,\ldots,N\} \)
and plot \( u \) and \( f \) for \( N=16 \). (It suffices to make plots for even \( i \).)

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Use the basis from <a href="#fem:approx:exer:tanh:sine1">Exercise 6: Approximate a steep function by sines</a>,
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
(It suffices to make plots for even \( i \).)
Observe that the approximation converges to a piecewise
linear function!

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>c)</b>
Use the basis
\( \baspsi_i(x) = \sin(2(i+1)x) \), \( i\in\If = \{0,\ldots,N\} \),
and observe that the approximation converges to a piecewise
constant function.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>tanh_sines_boundary_term</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec95">Remarks </h3>

<p>
The strange results in b) and c) are due to the choice of
basis. In b), \( \basphi_i(x) \) is an odd function around
\( x=\pi/2 \) and \( x=3\pi/2 \). No combination of basis functions
is able to approximate the flat regions of \( f \).
All basis functions in c) are even around \( x=\pi/2 \) and \( x=3\pi/2 \),
but odd at \( x=0,\pi,2\pi \). With all the sines represented, as in a),
the approximation is not constrained with a particular symmetry
behavior.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</h2>

<p>
<b>a)</b>
Given a function \( f(x) \) on an interval \( [0,L] \), look up the formula
for the coefficients \( a_j \) and \( b_j \) in the Fourier series of \( f \):

$$
\begin{equation*}
f(x) = \frac{1}{2}a_0 +
\sum_{j=1}^\infty a_j\cos \left(j\frac{2\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{2\pi x}{L}\right)\tp
\end{equation*}
$$

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
Let an infinite-dimensional vector space \( V \) have the basis functions
\( \cos j\frac{2\pi x}{L} \) for \( j=0,1,\dots,\infty \) and
\( \sin j\frac{2\pi x}{L} \) for \( j=1,\dots,\infty \).  Show that the least squares
approximation method from the section <a href="._approx-solarized003.html#fem:approx:global">Approximation of functions</a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of \( f(x) \) (see also
the section <a href="._approx-solarized003.html#fem:approx:global:Fourier">Fourier series</a>).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You may choose

$$
\begin{equation}
\baspsi_{2i} = \cos\left( i\frac{2\pi}{L}x\right),\quad
\baspsi_{2i+1} = \sin\left( i\frac{2\pi}{L}x\right),
\tag{47}
\end{equation}
$$

for \( i=0,1,\ldots,N\rightarrow\infty \).

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>c)</b>
Choose \( f(x) = H(x-\half) \) on \( \Omega=[0,1] \), where \( H \) is the
Heaviside function: \( H(x)=0 \) for \( x < 0 \), \( H(x)=1 \) for \( x>0 \) and
\( H(0)=\half \). Find the coefficients \( a_j \) and \( b_j \) in the
Fourier series for \( f(x) \). Plot the sum for \( j=2N+1 \), where \( N=5 \) and
\( N=100 \).

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>Fourier_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange">Exercise 9: Approximate a steep function by Lagrange polynomials</h2>

<p>
Use interpolation with uniformly distributed
points and Chebychev nodes to approximate

$$
\begin{equation*} f(x) = -\tanh(s(x-\half)),\quad x\in [0,1],\end{equation*}
$$

by Lagrange polynomials for \( s=5 \) and \( s=20 \), and \( N=3,7,11,15 \).
Combine \( 2\times 2 \) plots of the approximation for the four
\( N \) values, and create such figures for the four combinations of
\( s \) values and point types.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_Lagrange</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</h2>

<p>
Consider a domain \( \Omega =[0,2] \) divided into the three elements
\( [0,1] \), \( [1,1.2] \), and \( [1.2,2] \).

<p>
For P1 and P2 elements, set up the list of coordinates and nodes
(<code>nodes</code>) and the numbers of the nodes that belong to each element
(<code>elements</code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_numberings1.</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh2">Exercise 11: Define vertices, cells, and dof maps</h2>

<p>
Repeat <a href="#fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</a>, but define the
data structures <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> instead of
<code>nodes</code> and <code>elements</code>.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_numberings2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:defmesh:sparsity">Exercise 12: Construct matrix sparsity patterns</h2>

<p>
<a href="#fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a \( 5\times 5 \) matrix and fill in the entries that will be nonzero.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
A matrix entry \( (i,j) \) is nonzero if \( i \) and \( j \) are nodes in the
same element.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>fe_sparsity_pattern</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:symbolic">Exercise 13: Perform symbolic finite element computations</h2>

<p>
Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating \( f(x) = \sin (x) \) on
\( \Omega=[0, \pi] \) by two P1 elements of size \( \pi/2 \).  Solve the
system and compare \( u(\pi/2) \) with the exact value 1.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>sin_approx_P1</code>.

<p>
<!-- Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b), -->
<!-- which is the integral -->
<!-- that arises on the right-hand side. -->

<p>
<!-- solution: -->
<!-- from fe_approx1D_numint import * -->
<!-- c = approximate(sym.sin(x), symbolic=True, d=1, N_e=2, numint=None, -->
<!-- Omega=[0,sym.pi]) -->
<!-- print sym.simplify(c[1,0].subs('h', sym.pi/2)) -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P1P2">Exercise 14: Approximate a steep function by P1 and P2 elements</h2>

<p>
Given

$$
\begin{equation*} f(x) = \tanh(s(x-\half))\end{equation*}
$$

use the Galerkin or least squares method with finite elements to find
an approximate function \( u(x) \). Choose \( s=20 \) and try
\( N_e=4,8,16 \) P1 elements and
\( N_e=2,4,8 \) P2 elements.
Integrate \( f\basphi_i \) numerically.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
You can automate the computations by calling the <code>approximate</code> method
in the <code>fe_approx1D_numint</code> module.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->Filename: <code>tanh_fe_P1P2_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P3P4">Exercise 15: Approximate a steep function by P3 and P4 elements</h2>

<p>
<b>a)</b>
Solve <a href="#fem:approx:exer:tanh:P1P2">Exercise 14: Approximate a steep function by P1 and P2 elements</a> using \( N_e=1,2,4 \) P3 and P4
elements.

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
<b>b)</b>
How will an interpolation method work in
this case with the same number of nodes?

<p>
<!-- removed !bsol ... !esol environment (because of the command-line option --without_solutions)
 -->
<p>
Filename: <code>tanh_fe_P3P4_approx</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:interpol:error">Exercise 16: Investigate the approximation error in finite elements</h2>

<p>
The theory <a href="._approx-solarized007.html#mjx-eqn-40">(40)</a> from the section <a href="._approx-solarized007.html#fem:approx:fe:error">Computing the error of the approximation</a> predicts that the error in the Pd
approximation of a function should behave as \( h^{d+1} \), where \( h \) is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough \( h \)).  Choose three examples:
\( f(x)=Ae^{-\omega x} \) on \( [0,3/\omega] \), \( f(x) = A\sin (\omega x) \) on
\( \Omega=[0, 2\pi/\omega] \) for constant \( A \) and \( \omega \), and
\( f(x)=\sqrt{x} \) on \( [0,1] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Run a series of experiments: \( (h_i,E_i) \), \( i=0,\ldots,m \), where \( E_i \)
is the \( L^2 \) norm of the error corresponding to element length \( h_i \).
Assume an error model \( E=Ch^r \) and compute \( r \) from two successive
experiments:

$$ r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1\tp$$

Hopefully, the sequence \( r_0,\ldots,r_{m-1} \) converges to the true
\( r \), and \( r_{m-1} \) can be taken as an approximation to \( r \).
Run such experiments for different \( d \) for the different \( f(x) \) functions.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Pd_approx_error</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Heaviside">Exercise 17: Approximate a step function by finite elements</h2>

<p>
Approximate the step function

$$
\begin{equation*} f(x) = \left\lbrace\begin{array}{ll}
1 & 0\leq x < \halfi,\\ 
2 & \halfi \leq x \geq \halfi
\end{array}\right.
\end{equation*}
$$

by 2, 4, and 8 P1 and P2 elements. Compare
approximations visually.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
This \( f \) can also be expressed in terms of the Heaviside function \( H(x) \):
\( f(x) = H(x-\halfi) \).
Therefore, \( f \) can be defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">f = sym.Heaviside(x - sym.Rational(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">2</span>))
</pre></div>
<p>
making the <code>approximate</code> function in the
<code>fe_approx1D.py</code> module an obvious candidate to solve the
problem. However, <code>sympy</code> does not handle symbolic integration
with this particular integrand, and the <code>approximate</code> function faces a problem
when converting <code>f</code> to a Python function (for plotting) since
<code>Heaviside</code> is not an available function in <code>numpy</code>. It is better to make
special-purpose code for this case or perform all
calculations by hand.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Heaviside_fe_P1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:2Dsines:symbolic">Exercise 18: 2D approximation with orthogonal functions</h2>

<p>
Assume we have basis functions \( \basphi_i(x,y) \) in 2D that are
orthogonal
such that \( (\basphi_i,\basphi_j)=0 \) when \( i\neq j \).
The function <code>least_squares</code> in the
file <a href="http://tinyurl.com/nm5587k/fem/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a> will then spend much time on computing off-diagonal terms
in the coefficient matrix that we know are zero.
To speed up the computations, make a
version <code>least_squares_orth</code> that utilizes the orthogonality among the
basis functions. Apply the function to approximate

$$ f(x,y) = x(1-x)y(1-y)e^{-x-y}$$

on \( \Omega = [0,1]\times [0,1] \) via basis functions

$$ \basphi_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
$$

where \( p=0,\ldots,N_x \) and \( q=0,\ldots,N_y \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Get ideas from the function <code>least_squares_orth</code> in
the section <a href="._approx-solarized003.html#fem:approx:global:orth">Orthogonal basis functions</a> and
file <a href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>approx2D_least_squares_orth</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:trapez">Exercise 19: Use the Trapezoidal rule and P1 elements</h2>

<p>
Consider approximation of some \( f(x) \) on an interval \( \Omega \) using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a href="._approx-solarized008.html#mjx-eqn-41">(41)</a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form \( c_i=f(\xno{i}) \) for \( i\in\If \).
Filename: <code>fe_P1_trapez</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:P1:vs:interp">Problem 20: Compare P1 elements and interpolation</h2>

<p>
We shall approximate the function

$$ f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],$$

where \( n\in\Integer \) and \( \epsilon \geq 0 \).

<p>
<b>a)</b>
Plot \( f(x) \) for \( n=1,2,3 \) and find the wave length of the function.

<p>
<b>b)</b>
We want to use \( N_P \) elements per wave length. Show that the number
of elements is then \( nN_P \).

<p>
<b>c)</b>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an \( f \) with just one wave length in \( \Omega = [0,1] \).
Set \( \epsilon = 0.5 \).

<p>
Run the least squares or projection/Galerkin method for
\( N_P=2,4,8,16,32 \). Compute the error \( E=||u-f||_{L^2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use the <code>fe_approx1D_numint</code> module to compute \( u \) and use
the technique from the section <a href="._approx-solarized007.html#fem:approx:fe:error">Computing the error of the approximation</a> to
compute the norm of the error.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute \( u(x) \) (recall that \( c_i \) is now simply \( f(\xno{i}) \)).
Compute the error \( E=||u-f||_{L^2} \).
Which method seems to be most accurate?

<p>
Filename: <code>P1_vs_interp</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:3D:approx3D">Exercise 21: Implement 3D computations with global basis functions</h2>

<p>
Extend the <a href="http://tinyurl.com/nm5587k/fem/approx2D.py" target="_self"><tt>approx2D.py</tt></a> code to 3D
applying ideas from the section <a href="._approx-solarized009.html#fem:approx:3D:global">Extension to 3D</a>.
Use a 3D generalization of the test problem in the section <a href="._approx-solarized009.html#fem:approx:2D:global:code">Implementation</a> to test the implementation.
Filename: <code>approx3D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:simpson">Exercise 22: Use Simpson's rule and P2 elements</h2>

<p>
Redo <a href="#fem:approx:fe:exer:1D:trapez">Exercise 19: Use the Trapezoidal rule and P1 elements</a>, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.
Filename: <code>fe_P2_simpson</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized010.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized012.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

