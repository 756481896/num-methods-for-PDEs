<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec23'),
              ('Successful example', 3, None, '___sec24'),
              ('Less successful example', 3, None, '___sec25'),
              ('Remedy for strong oscillations', 3, None, '___sec26'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec29'),
              ('The basis functions', 2, None, '___sec30'),
              ('Construction principles', 3, None, '___sec31'),
              ('Properties of $\\basphi_i$', 3, None, '___sec32'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec33'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec34'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec35'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec37'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec38'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec40'),
              ('Assembly of element matrices', 3, None, '___sec41'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec42'),
              ('The element vector', 3, None, '___sec43'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec45'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec46'),
              ('Formulas for local basis functions', 3, None, '___sec47'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               None,
               '___sec61'),
              ('Computations in physical space', 3, None, '___sec62'),
              ('Elementwise computations', 3, None, '___sec63'),
              ('Terminology', 3, None, '___sec64'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec71'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec73'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec76'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec79'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec80'),
              ('Element matrices and vectors', 3, None, '___sec81'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec82'),
              ('Affine mapping of the reference cell', 2, None, '___sec83'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec84'),
              ('Computing integrals', 2, None, '___sec85'),
              ('Exercises', 1, None, '___sec86'),
              ('Exercise 1: Linear algebra refresher I',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Exercise 2: Linear algebra refresher II',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              ('Exercise 3: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 4: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Exercise 5: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Exercise 6: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Exercise 7: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec94'),
              ('Exercise 8: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec96'),
              ('Exercise 9: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Exercise 10: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Exercise 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Exercise 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Exercise 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Exercise 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Exercise 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Exercise 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Exercise 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Problem 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec112')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0010"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized009.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized011.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec79">Finite elements in 2D and 3D </h1>

<p>
Finite element approximation is particularly powerful in 2D and 3D because
the method can handle a geometrically complex domain \( \Omega \) with ease.
The principal idea is, as in 1D, to divide the domain into cells
and use polynomials for approximating a function over a cell.
Two popular cell shapes are triangles and quadrilaterals.
Figures <a href="#fem:approx:fe:2D:fig:rectP1">33</a>, <a href="#fem:approx:fe:2D:fig:circP1">34</a>,
and <a href="#fem:approx:fe:2D:fig:rectQ1">35</a> provide examples. P1 elements
means linear functions (\( a_0 + a_1x + a_2y \)) over triangles, while Q1 elements
have bilinear functions (\( a_0 + a_1x + a_2y + a_3xy \)) over rectangular cells.
Higher-order elements can easily be defined.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 33:  Examples on 2D P1 elements. <div id="fem:approx:fe:2D:fig:rectP1"></div> </p></center>
<p><img src="fig-approx/mesh2D_rect_P1.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  Examples on 2D P1 elements in a deformed geometry. <div id="fem:approx:fe:2D:fig:circP1"></div> </p></center>
<p><img src="fig-approx/mesh2D_quarter_circle.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 35:  Examples on 2D Q1 elements. <div id="fem:approx:fe:2D:fig:rectQ1"></div> </p></center>
<p><img src="fig-approx/mesh2D_rect_Q1.png" align="bottom" width=400></p>
</center>

<h2 id="___sec80">Basis functions over triangles in the physical domain </h2>

<p>
Cells with triangular shape will be in main focus here.  With the P1
triangular element, \( u \) is a linear function over each cell, as
depicted in Figure <a href="#fem:approx:fe:2D:fig:femfunc">36</a>, with
discontinuous derivatives at the cell boundaries.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 36:  Example on piecewise linear 2D functions defined on triangles. <div id="fem:approx:fe:2D:fig:femfunc"></div> </p></center>
<p><img src="fig-approx/demo2D_4x3r.png" align="bottom" width=400></p>
</center>

<p>
We give the vertices of the cells global and local numbers as in 1D.
The degrees of freedom in the P1 element are the function values at
a set of nodes, which are the three vertices.
The basis function \( \basphi_i(x,y) \) is then 1 at the vertex with global vertex
number \( i \) and zero at all other vertices.
On an element, the three degrees of freedom uniquely determine
the linear basis functions in that element, as usual.
The global
\( \basphi_i(x,y) \) function is then a combination of the linear functions
(planar surfaces)
over all the neighboring cells
that have vertex number \( i \) in common. Figure <a href="#fem:approx:fe:2D:fig:basphi">37</a>
tries to illustrate the shape of such a &quot;pyramid&quot;-like function.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 37:  Example on a piecewise linear 2D basis function over a patch of triangles. <div id="fem:approx:fe:2D:fig:basphi"></div> </p></center>
<p><img src="fig-approx/demo2D_basisfunc.png" align="bottom" width=400></p>
</center>

<h3 id="___sec81">Element matrices and vectors </h3>

<p>
As in 1D, we split the integral over \( \Omega \) into a sum of integrals
over cells. Also as in 1D, \( \basphi_i \) overlaps \( \basphi_j \)
(i.e., \( \basphi_i\basphi_j\neq 0 \)) if and only if
\( i \) and \( j \) are vertices in the same cell. Therefore, the integral
of \( \basphi_i\basphi_j \) over an element is nonzero only when \( i \) and \( j \)
run over the vertex numbers in the element. These nonzero contributions
to the coefficient matrix are, as in 1D, collected in an element matrix.
The size of the element matrix becomes \( 3\times 3 \) since there are
three degrees of freedom
that \( i \) and \( j \) run over. Again, as in 1D, we number the
local vertices in a cell, starting at 0, and add the entries in
the element matrix into the global system matrix, exactly as in 1D.
All details and code appear below.

<h2 id="___sec82">Basis functions over triangles in the reference cell </h2>

<p>
As in 1D, we can define the basis functions and the degrees of freedom
in a reference cell and then use a mapping from the reference coordinate
system to the physical coordinate system.
We also have a mapping of local degrees of freedom numbers to global degrees
of freedom numbers.
<!-- (<code>dof_map</code>). -->

<p>
The reference cell in an \( (X,Y) \) coordinate system has vertices
\( (0,0) \), \( (1,0) \), and \( (0,1) \), corresponding to local vertex numbers
0, 1, and 2, respectively. The P1 element has linear functions
\( \refphi_r(X,Y) \) as basis functions, \( r=0,1,2 \).
Since a linear function \( \refphi_r(X,Y) \) in 2D is on
the form \( C_{r,0} + C_{r,1}X + C_{r,2}Y \), and hence has three
parameters \( C_{r,0} \), \( C_{r,1} \), and \( C_{r,2} \), we need three
degrees of freedom. These are in general taken as the function values at a
set of nodes. For the P1 element the set of nodes is the three vertices.
Figure <a href="#fem:approx:fe:2D:fig:P12D">38</a> displays the geometry of the
element and the location of the nodes.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 38:  2D P1 element. <div id="fem:approx:fe:2D:fig:P12D"></div> </p></center>
<p><img src="fig-approx/fenics-book/elements/P1_2d.png" align="bottom" width=100></p>
</center>

<p>
Requiring \( \refphi_r=1 \) at node number \( r \) and
\( \refphi_r=0 \) at the two other nodes, gives three linear equations to
determine \( C_{r,0} \), \( C_{r,1} \), and \( C_{r,2} \). The result is

$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y,\\ 
\refphi_1(X,Y) &= X,\\ 
\refphi_2(X,Y) &= Y
\end{align}
$$

<p>
Higher-order approximations are obtained by increasing the polynomial order,
adding additional nodes, and letting the degrees of freedom be
function values at the nodes. Figure <a href="#fem:approx:fe:2D:fig:P22D">39</a>
shows the location of the six nodes in the P2 element.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 39:  2D P2 element. <div id="fem:approx:fe:2D:fig:P22D"></div> </p></center>
<p><img src="fig-approx/fenics-book/elements/P2_2d.png" align="bottom" width=100></p>
</center>

<p>
<!-- 2DO: write up local basis funcs for P2 -->

<p>
A polynomial of degree \( p \) in \( X \) and \( Y \) has \( n_p=(p+1)(p+2)/2 \) terms
and hence needs \( n_p \) nodes. The values at the nodes constitute \( n_p \)
degrees of freedom. The location of the nodes for
\( \refphi_r \) up to degree 6 is displayed in Figure
<a href="#fem:approx:fe:2D:fig:P162D">40</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 40:  2D P1, P2, P3, P4, P5, and P6 elements. <div id="fem:approx:fe:2D:fig:P162D"></div> </p></center>
<p><img src="fig-approx/fenics-book/elements/P1-6_2d.png" align="bottom" width=400></p>
</center>

<p>
The generalization to 3D is straightforward: the reference element is a
<a href="http://en.wikipedia.org/wiki/Tetrahedron" target="_self">tetrahedron</a>
with vertices \( (0,0,0) \), \( (1,0,0) \), \( (0,1,0) \), and \( (0,0,1) \)
in a \( X,Y,Z \) reference coordinate system. The P1 element has its degrees
of freedom as four nodes, which are the four vertices, see Figure
<a href="#fem:approx:fe:2D:fig:P1:123D">41</a>. The P2 element adds additional
nodes along the edges of the cell, yielding a total of 10 nodes and
degrees of freedom, see
Figure <a href="#fem:approx:fe:2D:fig:P2:123D">42</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 41:  P1 elements in 1D, 2D, and 3D. <div id="fem:approx:fe:2D:fig:P1:123D"></div> </p></center>
<p><img src="fig-approx/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 42:  P2 elements in 1D, 2D, and 3D. <div id="fem:approx:fe:2D:fig:P2:123D"></div> </p></center>
<p><img src="fig-approx/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>
The interval in 1D, the triangle in 2D, the tetrahedron in 3D, and
its generalizations to higher space dimensions are known
as <em>simplex</em> cells (the geometry) or <em>simplex</em> elements (the geometry,
basis functions, degrees of freedom, etc.). The plural forms
<a href="http://en.wikipedia.org/wiki/Simplex" target="_self">simplices</a> and
simplexes are
also a much used shorter terms when referring to this type of cells or elements.
The side of a simplex is called a <em>face</em>, while the tetrahedron also
has <em>edges</em>.

<p>
<b>Acknowledgment.</b>
Figures <a href="#fem:approx:fe:2D:fig:P12D">38</a>-<a href="#fem:approx:fe:2D:fig:P2:123D">42</a>
are created by Anders Logg and taken from the <a href="https://launchpad.net/fenics-book" target="_self">FEniCS book</a>: <em>Automated Solution of Differential Equations by the Finite Element Method</em>, edited by A. Logg, K.-A. Mardal, and G. N. Wells, published
by <a href="http://goo.gl/lbyVMH" target="_self">Springer</a>, 2012.

<h2 id="___sec83">Affine mapping of the reference cell </h2>

<p>
Let \( \refphi_r^{(1)} \) denote the basis functions associated
with the P1 element in 1D, 2D, or 3D, and let \( \xdno{q(e,r)} \) be
the physical coordinates of local vertex number \( r \) in cell \( e \).
Furthermore,
let \( \X \) be a point in the reference coordinate system corresponding
to the point \( \x \) in the physical coordinate system.
The affine mapping of any \( \X \) onto \( \x \) is
then defined by

$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)},
\tag{44}
\end{equation}
$$

where \( r \) runs over the local vertex numbers in the cell.
The affine mapping essentially stretches, translates, and rotates
the triangle. Straight or planar faces of the reference cell are
therefore mapped onto
straight or planar faces in the physical coordinate system. The mapping can
be used for both P1 and higher-order elements, but note that the
mapping itself always applies the P1 basis functions.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 43:  Affine mapping of a P1 element. <div id="fem:approx:fe:map:fig:2DP1"></div> </p></center>
<p><img src="fig-approx/ElmT3n2D_map.png" align="bottom" width=400></p>
</center>

<h2 id="___sec84">Isoparametric mapping of the reference cell </h2>

<p>
Instead of using the P1 basis functions in the mapping
<a href="#mjx-eqn-44">(44)</a>,
we may use the basis functions of the actual Pd element:

$$
\begin{equation}
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)},
\tag{45}
\end{equation}
$$

where \( r \) runs over all nodes, i.e., all points associated with the
degrees of freedom. This is called an <em>isoparametric mapping</em>.
For P1 elements it is identical to the affine mapping
<a href="#mjx-eqn-44">(44)</a>, but for higher-order elements
the mapping of the straight or planar faces of the reference cell will
result in a <em>curved</em> face in the physical coordinate system.
For example, when we use the basis functions of the triangular P2 element
in 2D in <a href="#mjx-eqn-45">(45)</a>, the straight faces of the
reference triangle are mapped onto curved faces of parabolic shape in
the physical coordinate system, see Figure <a href="#fem:approx:fe:map:fig:2DP2">44</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 44:  Isoparametric mapping of a P2 element. <div id="fem:approx:fe:map:fig:2DP2"></div> </p></center>
<p><img src="fig-approx/ElmT6n2D_map.png" align="bottom" width=400></p>
</center>

<p>
From <a href="#mjx-eqn-44">(44)</a> or
<a href="#mjx-eqn-45">(45)</a> it is easy to realize that the
vertices are correctly mapped. Consider a vertex with local number \( s \).
Then \( \refphi_s=1 \) at this vertex and zero at the others.
This means that only one term in the sum is nonzero and \( \x=\xdno{q(e,s)} \),
which is the coordinate of this vertex in the global coordinate system.

<h2 id="___sec85">Computing integrals </h2>

<p>
Let \( \tilde\Omega^r \) denote the reference cell and \( \Omega^{(e)} \)
the cell in the physical coordinate system. The transformation of
the integral from the physical to the reference coordinate system reads

$$
\begin{align}
\int_{\Omega^{(e)}}\basphi_i (\x) \basphi_j (\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) \refphi_j (\X)
\det J\, \dX,\\ 
\int_{\Omega^{(e)}}\basphi_i (\x) f(\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) f(\x(\X)) \det J\, \dX,
\end{align}
$$

where \( \dx \) means the infinitesimal area element \( dx dy \) in 2D and
\( dx dy dz \) in 3D, with a similar
definition of \( \dX \). The quantity \( \det J \) is the determinant of the
Jacobian of the mapping \( \x(\X) \). In 2D,

$$
\begin{equation}
J = \left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
\frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
\end{array}\right], \quad
\det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
- \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
\tp
\tag{46}
\end{equation}
$$

With the affine mapping
<a href="#mjx-eqn-44">(44)</a>, \( \det J=2\Delta \), where \( \Delta \) is
the area or volume of the cell in the physical coordinate system.

<p>
<b>Remark.</b>
Observe that finite elements in 2D and 3D builds on the same
<em>ideas</em> and <em>concepts</em> as in 1D, but there is simply much
more to compute because the
specific mathematical formulas in 2D and 3D are more complicated
and the book keeping with dof maps also gets more complicated.
The manual work is tedious, lengthy, and error-prone
so automation by the computer is a must.

<p>
<!-- 2DO -->
<!-- First: two triangles -->
<!-- vertices = [(0,0), (1,0), (0,1), (1,1)] -->
<!-- cells = [[0, 1, 3], [0, 3, 2]] -->
<!-- dof_map = cells -->
<!-- write up affine mapping -->
<!-- D is the area that sympy.Triangle can compute :-) No, do that directly! 0.5... -->
<!-- rhs: choose simple f=x*y, try hand-calculation or two-step -->
<!-- sympy: first integrate in y with (0,1-x) as limits, then -->
<!-- integrate the result in x -->
<!-- a = integrate(x*y*(1-x-y), (y, 0, 1-x)) -->
<!-- b = integrate(a, (x,0,1)) -->
<!-- use the same for local element matrix -->
<!-- show assembly -->
<!-- should have pysketcher prog for drawing 2D mesh, mark and number nodes -->
<!-- and elements -->

<p>
<!-- Should have example with x**8*(1-x)*y**8*(1-y) worked out, but -->
<!-- need software -->

<p>
<!-- Need 2D exercises -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized009.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized011.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

