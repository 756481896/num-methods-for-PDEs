<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec23'),
              ('Successful example', 3, None, '___sec24'),
              ('Less successful example', 3, None, '___sec25'),
              ('Remedy for strong oscillations', 3, None, '___sec26'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec29'),
              ('The basis functions', 2, None, '___sec30'),
              ('Construction principles', 3, None, '___sec31'),
              ('Properties of $\\basphi_i$', 3, None, '___sec32'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec33'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec34'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec35'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec37'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec38'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec40'),
              ('Assembly of element matrices', 3, None, '___sec41'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec42'),
              ('The element vector', 3, None, '___sec43'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec45'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec46'),
              ('Formulas for local basis functions', 3, None, '___sec47'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               None,
               '___sec61'),
              ('Computations in physical space', 3, None, '___sec62'),
              ('Elementwise computations', 3, None, '___sec63'),
              ('Terminology', 3, None, '___sec64'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec71'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec73'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec76'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec79'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec80'),
              ('Element matrices and vectors', 3, None, '___sec81'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec82'),
              ('Affine mapping of the reference cell', 2, None, '___sec83'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec84'),
              ('Computing integrals', 2, None, '___sec85'),
              ('Exercises', 1, None, '___sec86'),
              ('Exercise 1: Linear algebra refresher I',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Exercise 2: Linear algebra refresher II',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              ('Exercise 3: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 4: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Exercise 5: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Exercise 6: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Exercise 7: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec94'),
              ('Exercise 8: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec96'),
              ('Exercise 9: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Exercise 10: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Exercise 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Exercise 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Exercise 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Exercise 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Exercise 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Exercise 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Exercise 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Problem 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec112')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0009"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized008.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized010.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:approx:2D">Approximation of functions in 2D</h1>

<p>
All the concepts and algorithms developed for approximation of 1D functions
\( f(x) \) can readily be extended to 2D functions \( f(x,y) \) and 3D functions
\( f(x,y,z) \). Basically, the extensions consist of defining basis functions
\( \baspsi_i(x,y) \) or \( \baspsi_i(x,y,z) \) over some domain \( \Omega \), and
for the least squares and Galerkin methods, the integration is done over
\( \Omega \).

<p>
As in 1D, the least squares and projection/Galerkin methods
lead to linear systems

$$
\begin{align*}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If,\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j),\\ 
b_i &= (f,\baspsi_i),
\end{align*}
$$

where the inner product of two functions \( f(x,y) \) and \( g(x,y) \) is defined
completely analogously to the 1D case <a href="._approx-solarized003.html#mjx-eqn-15">(15)</a>:
$$
\begin{equation}
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
\end{equation}
$$

<h2 id="fem:approx:2D:global">2D basis functions as tensor products of 1D functions</h2>

<p>
One straightforward way to construct a basis in 2D is to combine 1D
basis functions. Say we have the 1D vector space

$$
\begin{equation}
V_x = \mbox{span}\{ \hat\baspsi_0(x),\ldots,\hat\baspsi_{N_x}(x)\}
\tag{42}
\tp
\end{equation}
$$

A similar space for a function's variation in \( y \) can be defined,

$$
\begin{equation}
V_y = \mbox{span}\{ \hat\baspsi_0(y),\ldots,\hat\baspsi_{N_y}(y)\}
\tag{43}
\tp
\end{equation}
$$

We can then form 2D basis functions as <em>tensor products</em> of 1D basis functions.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tensor products.</b>
<p>
Given two vectors \( a=(a_0,\ldots,a_M) \) and \( b=(b_0,\ldots,b_N) \),
their <em>outer tensor product</em>, also called the <em>dyadic product</em>,
is \( p=a\otimes b \), defined through

$$ p_{i,j}=a_ib_j,\quad i=0,\ldots,M,\ j=0,\ldots,N\tp$$

In the tensor terminology,
\( a \) and \( b \) are first-order tensors (vectors with one index, also termed
rank-1 tensors), and then their outer
tensor product is a second-order tensor (matrix with two indices, also
termed rank-2 tensor). The
corresponding <em>inner tensor product</em> is the well-known scalar or dot
product of two vectors: \( p=a\cdot b = \sum_{j=0}^N a_jb_j \). Now,
\( p \) is a rank-0 tensor.

<p>
Tensors are typically represented by arrays in computer code.
In the above example, \( a \) and \( b \) are represented by
one-dimensional arrays of length
\( M \) and \( N \), respectively, while \( p=a\otimes b \) must be represented
by a two-dimensional array of size \( M\times N \).

<p>
<a href="http://en.wikipedia.org/wiki/Tensor_product" target="_self">Tensor products</a> can
be used in a variety of context.
</div>


<p>
<!-- The following is from <a href="http://en.wikipedia.org/wiki/Tensor_product" target="_self"><tt>http://en.wikipedia.org/wiki/Tensor_product</tt></a>, -->
<!-- Notation and examples -->
Given the vector spaces \( V_x \) and \( V_y \) as defined
in <a href="#mjx-eqn-42">(42)</a> and <a href="#mjx-eqn-43">(43)</a>, the
tensor product space \( V=V_x\otimes V_y \) has a basis formed
as the tensor product of the basis for \( V_x \) and \( V_y \).
That is, if \( \left\{ \basphi_i(x) \right\}_{i\in\Ix} \)
and \( \left\{ \basphi_i(y) \right\}_{i\in \Iy} \) are basis for
\( V_x \) and \( V_y \), respectively, the elements in the basis for \( V \) arise
from the tensor product:
\( \left\{ \basphi_i(x)\basphi_j(y) \right\}_{i\in \Ix,j\in \Iy} \).
The index sets are \( I_x=\{0,\ldots,N_x\} \) and \( I_y=\{0,\ldots,N_y\} \).

<p>
The notation for a basis function in 2D can employ a double index as in

$$ \baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad p\in\Ix,q\in\Iy\tp
$$

The expansion for \( u \) is then written as a double sum

$$ u = \sum_{p\in\Ix}\sum_{q\in\Iy} c_{p,q}\baspsi_{p,q}(x,y)\tp
$$

Alternatively, we may employ a single index,

$$
\baspsi_i(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
$$

and use the standard form for \( u \),

$$ u = \sum_{j\in\If} c_j\baspsi_j(x,y)\tp$$

The single index is related to the double index through
\( i=p (N_y+1) + q \) or \( i=q (N_x+1) + p \).

<h2 id="___sec76">Example: Polynomial basis in 2D </h2>

<p>
Suppose we choose \( \hat\baspsi_p(x)=x^p \), and try an approximation with
\( N_x=N_y=1 \):

$$ \baspsi_{0,0}=1,\quad \baspsi_{1,0}=x, \quad \baspsi_{0,1}=y,
\quad \baspsi_{1,1}=xy
\tp
$$

Using a mapping to one index like \( i=q (N_x+1) + p \), we get

$$ \baspsi_0=1,\quad \baspsi_1=x, \quad \baspsi_2=y,\quad\baspsi_3 =xy
\tp
$$

<p>
With the specific choice \( f(x,y) = (1+x^2)(1+2y^2) \) on
\( \Omega = [0,L_x]\times [0,L_y] \), we can perform actual calculations:

$$
\begin{align*}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_0^{L_y}\int_{0}^{L_x}
\baspsi_0(x,y)^2 dx dy = \int_0^{L_y}\int_{0}^{L_x}dx dy = L_xL_y,\\ 
A_{1,0} &= (\baspsi_1,\baspsi_0) = \int_0^{L_y}\int_{0}^{L_x} x dxdy =
{\half}L_x^2L_y,\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_0^{L_y}\int_{0}^{L_x} y dxdy =
{\half}L_y^2L_x,\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_0^{L_y}\int_{0}^{L_x} xy dxdy =
\int_0^{L_y}ydy \int_{0}^{L_x} xdx =
\frac{1}{4}L_y^2L_x^2
\tp
\end{align*}
$$

The right-hand side vector has the entries

$$
\begin{align*}
b_{0} &= (\baspsi_0,f) = \int_0^{L_y}\int_{0}^{L_x}1\cdot (1+x^2)(1+2y^2) dxdy\\ 
&= \int_0^{L_y}(1+2y^2)dy \int_{0}^{L_x} (1+x^2)dx
= (L_y + \frac{2}{3}L_y^3)(L_x + \frac{1}{3}L_x^3)\\ 
b_{1} &= (\baspsi_1,f) = \int_0^{L_y}\int_{0}^{L_x} x(1+x^2)(1+2y^2) dxdy\\ 
&=\int_0^{L_y}(1+2y^2)dy \int_{0}^{L_x} x(1+x^2)dx
= (L_y + \frac{2}{3}L_y^3)({\half}L_x^2 + \frac{1}{4}L_x^4)\\ 
b_{2} &= (\baspsi_2,f) = \int_0^{L_y}\int_{0}^{L_x} y(1+x^2)(1+2y^2) dxdy\\ 
&= \int_0^{L_y}y(1+2y^2)dy \int_{0}^{L_x} (1+x^2)dx
= ({\half}L_y + {\half}L_y^4)(L_x + \frac{1}{3}L_x^3)\\ 
b_{3} &= (\baspsi_2,f) = \int_0^{L_y}\int_{0}^{L_x} xy(1+x^2)(1+2y^2) dxdy\\ 
&= \int_0^{L_y}y(1+2y^2)dy \int_{0}^{L_x} x(1+x^2)dx
= ({\half}L_y^2 + {\half}L_y^4)({\half}L_x^2 + \frac{1}{4}L_x^4)
\tp
\end{align*}
$$

<p>
There is a general pattern in these calculations that we can explore.
An arbitrary matrix entry has the formula

$$
\begin{align*}
A_{i,j} &= (\baspsi_i,\baspsi_j) = \int_0^{L_y}\int_{0}^{L_x}
\baspsi_i\baspsi_j dx dy \\ 
&= \int_0^{L_y}\int_{0}^{L_x}
\baspsi_{p,q}\baspsi_{r,s} dx dy
= \int_0^{L_y}\int_{0}^{L_x}
\hat\baspsi_p(x)\hat\baspsi_q(y)\hat\baspsi_r(x)\hat\baspsi_s(y) dx dy\\ 
&= \int_0^{L_y} \hat\baspsi_q(y)\hat\baspsi_s(y)dy
\int_{0}^{L_x} \hat\baspsi_p(x) \hat\baspsi_r(x) dx\\ 
&= \hat A^{(x)}_{p,r}\hat A^{(y)}_{q,s},
\end{align*}
$$

where

$$ \hat A^{(x)}_{p,r} = \int_{0}^{L_x} \hat\baspsi_p(x) \hat\baspsi_r(x) dx,
\quad
\hat A^{(y)}_{q,s} = \int_0^{L_y} \hat\baspsi_q(y)\hat\baspsi_s(y)dy,
$$

are matrix entries for one-dimensional approximations. Moreover,
\( i=q N_y+q \) and \( j=s N_y+r \).

<p>
With \( \hat\baspsi_p(x)=x^p \) we have

$$ \hat A^{(x)}_{p,r} = \frac{1}{p+r+1}L_x^{p+r+1},\quad
\hat A^{(y)}_{q,s} = \frac{1}{q+s+1}L_y^{q+s+1},
$$

and

$$ A_{i,j} = \hat A^{(x)}_{p,r} \hat A^{(y)}_{q,s} =
\frac{1}{p+r+1}L_x^{p+r+1} \frac{1}{q+s+1}L_y^{q+s+1},
$$

for \( p,r\in\Ix \) and \( q,s\in\Iy \).

<p>
Corresponding reasoning for the right-hand side leads to

$$
\begin{align*}
b_i &= (\baspsi_i,f) = \int_0^{L_y}\int_{0}^{L_x}\baspsi_i f\,dxdx\\ 
&= \int_0^{L_y}\int_{0}^{L_x}\hat\baspsi_p(x)\hat\baspsi_q(y) f\,dxdx\\ 
&= \int_0^{L_y}\hat\baspsi_q(y) (1+2y^2)dy
\int_0^{L_y}\hat\baspsi_p(x) x^p (1+x^2)dx\\ 
&= \int_0^{L_y} y^q (1+2y^2)dy
\int_0^{L_y}x^p (1+x^2)dx\\ 
&= (\frac{1}{q+1} L_y^{q+1} + \frac{2}{q+3}L_y^{q+3})
(\frac{1}{p+1} L_x^{p+1} + \frac{2}{q+3}L_x^{p+3})
\end{align*}
$$

<p>
Choosing \( L_x=L_y=2 \), we have

$$
A =
\left[\begin{array}{cccc}
4 & 4 & 4 & 4\\ 
4 & \frac{16}{3} & 4 & \frac{16}{3}\\ 
4 & 4 & \frac{16}{3} & \frac{16}{3}\\ 
4 & \frac{16}{3} & \frac{16}{3} & \frac{64}{9}
\end{array}\right],\quad
b = \left[\begin{array}{c}
\frac{308}{9}\\\frac{140}{3}\\44\\60\end{array}\right],
\quad c = \left[
\begin{array}{r}
-\frac{1}{9} \\ 
\frac{4}{3} \\ 
 - \frac{2}{3} \\ 
 8
\end{array}\right]
\tp
$$

Figure <a href="#fem:approx:fe:2D:fig:ubilinear">32</a> illustrates the result.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 32:  Approximation of a 2D quadratic function (left) by a 2D bilinear function (right) using the Galerkin or least squares method. <div id="fem:approx:fe:2D:fig:ubilinear"></div> </p></center>
<p><img src="fig-approx/approx2D_bilinear.png" align="bottom" width=800></p>
</center>

<h2 id="fem:approx:2D:global:code">Implementation</h2>

<p>
The <code>least_squares</code> function from
the section <a href="._approx-solarized003.html#fem:approx:global:orth">Orthogonal basis functions</a> and/or the
file <a href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>
can with very small modifications solve 2D approximation problems.
First, let <code>Omega</code> now be a list of the intervals in \( x \) and \( y \) direction.
For example, \( \Omega = [0,L_x]\times [0,L_y] \) can be represented
by <code>Omega = [[0, L_x], [0, L_y]]</code>.

<p>
Second, the symbolic integration must be extended to 2D:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

integrand = psi[i]*psi[j]
I = sym.integrate(integrand,
                 (x, Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">1</span>]),
                 (y, Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">1</span>]))
</pre></div>
<p>
provided <code>integrand</code> is an expression involving the <code>sympy</code> symbols <code>x</code>
and <code>y</code>.
The 2D version of numerical integration becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
    integrand = sym.lambdify([x,y], integrand)
    I = sym.mpmath.quad(integrand,
                       [Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">0</span>][<span style="color: #B452CD">1</span>]],
                       [Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>][<span style="color: #B452CD">1</span>]])
</pre></div>
<p>
The right-hand side integrals are modified in a similar way.

<p>
Third, we must construct a list of 2D basis functions. Here are two
examples based on tensor products of 1D "Taylor-style" polynomials \( x^i \)
and 1D sine functions \( \sin((i+1)\pi x) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">taylor</span>(x, y, Nx, Ny):
    <span style="color: #8B008B; font-weight: bold">return</span> [x**i*y**j <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nx+<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ny+<span style="color: #B452CD">1</span>)]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">sines</span>(x, y, Nx, Ny):
    <span style="color: #8B008B; font-weight: bold">return</span> [sym.sin(sym.pi*(i+<span style="color: #B452CD">1</span>)*x)*sym.sin(sym.pi*(j+<span style="color: #B452CD">1</span>)*y)
            <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nx+<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ny+<span style="color: #B452CD">1</span>)]
</pre></div>
<p>
The complete code appears in
<a href="http://tinyurl.com/nm5587k/fem/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a>.

<p>
The previous hand calculation where a quadratic \( f \) was approximated by
a bilinear function can be computed symbolically by

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx2D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; f = (<span style="color: #B452CD">1</span>+x**<span style="color: #B452CD">2</span>)*(<span style="color: #B452CD">1</span>+<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span>)
&gt;&gt;&gt; psi = taylor(x, y, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>)
&gt;&gt;&gt; Omega = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">8</span>*x*y - <span style="color: #B452CD">2</span>*x/<span style="color: #B452CD">3</span> + <span style="color: #B452CD">4</span>*y/<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sym.expand(f)
<span style="color: #B452CD">2</span>*x**<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>
</pre></div>
<p>
We may continue with adding higher powers to the basis:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; psi = taylor(x, y, <span style="color: #B452CD">2</span>, <span style="color: #B452CD">2</span>)
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">2</span>*x**<span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">2</span>*y**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u-f
<span style="color: #B452CD">0</span>
</pre></div>
<p>
For \( N_x\geq 2 \) and \( N_y\geq 2 \) we recover the exact function \( f \), as
expected, since in that case \( f\in V \) (see
the section <a href="._approx-solarized003.html#fem:approx:global:exact">Perfect approximation</a>).

<h2 id="fem:approx:3D:global">Extension to 3D</h2>

<p>
Extension to 3D is in principle straightforward once the 2D extension
is understood. The only major difference is that we need the
repeated outer tensor product,

$$ V = V_x\otimes V_y\otimes V_z\tp$$

In general, given vectors (first-order tensors)
\( a^{(q)} = (a^{(q)}_0,\ldots,a^{(q)}_{N_q} \), \( q=0,\ldots,m \),
the tensor product \( p=a^{(0)}\otimes\cdots\otimes a^{m} \) has
elements

$$ p_{i_0,i_1,\ldots,i_m} = a^{(0)}_{i_1}a^{(1)}_{i_1}\cdots a^{(m)}_{i_m}\tp$$

The basis functions in 3D are then

$$ \baspsi_{p,q,r}(x,y,z) = \hat\baspsi_p(x)\hat\baspsi_q(y)\hat\baspsi_r(z),$$

with \( p\in\Ix \), \( q\in\Iy \), \( r\in\Iz \). The expansion of \( u \) becomes

$$ u(x,y,z) = \sum_{p\in\Ix}\sum_{q\in\Iy}\sum_{r\in\Iz} c_{p,q,r}
\baspsi_{p,q,r}(x,y,z)\tp$$

A single index can be introduced also here, e.g., \( i=N_xN_yr + q_Nx + p \),
\( u=\sum_i c_i\baspsi_i(x,y,z) \).

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Use of tensor product spaces.</b>
<p>
Constructing a multi-dimensional space and basis from tensor products
of 1D spaces is a standard technique when working with global basis
functions. In the world of finite elements, constructing basis functions
by tensor products is much used on quadrilateral and hexahedra cell
shapes, but not on triangles and tetrahedra. Also, the global
finite element basis functions are almost exclusively denoted by a single
index and not by the natural tuple of indices that arises from
tensor products.
</div>


<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._approx-solarized008.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._approx-solarized010.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

