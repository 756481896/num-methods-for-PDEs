<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,basis vector,norm,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation method (approximation),approximation interpolation,normal equations,$A^TA=A^Tb$ (normal equations),Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,internal node,shared node,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Approximation of vectors',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              ('Approximation of planar vectors',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              ('The least squares method', 3, None, '___sec2'),
              ('The projection method', 3, None, '___sec3'),
              ('Approximation of general vectors',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              ('The least squares method', 3, None, '___sec5'),
              ('The Galerkin or projection method', 3, None, '___sec6'),
              ('Approximation of functions',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              ('The least squares method',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              ('The projection (or Galerkin) method', 2, None, '___sec9'),
              ('Example: linear approximation',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              ('Implementation of the least squares method',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              ('Symbolic integration', 3, None, '___sec12'),
              ('Fall back on numerical integration', 3, None, '___sec13'),
              ('Plotting the approximation', 3, None, '___sec14'),
              ('Perfect approximation',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              ('Ill-conditioning',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              ('Fourier series',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              ('Orthogonal basis functions',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              ('Numerical computations', 2, None, '___sec19'),
              ('The interpolation (or collocation) method',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              ('Example', 3, None, '___sec21'),
              ('The regression method',
               2,
               'fem:approx:global:regression',
               'fem:approx:global:regression'),
              ('Overdetermined equation system', 3, None, '___sec23'),
              ('The normal equations derived from a least squares principle',
               3,
               None,
               '___sec24'),
              ('Implementation', 3, None, '___sec25'),
              ('Example', 3, None, '___sec26'),
              ('Remark', 3, None, '___sec27'),
              ('Lagrange polynomials',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              ('Approximation of a polynomial', 3, None, '___sec29'),
              ('Successful example', 3, None, '___sec30'),
              ('Less successful example', 3, None, '___sec31'),
              ('Remedy for strong oscillations', 3, None, '___sec32'),
              ('Finite element basis functions',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              ('Elements and nodes',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              ('Example', 3, None, '___sec35'),
              ('The basis functions', 2, None, '___sec36'),
              ('Construction principles', 3, None, '___sec37'),
              ('Properties of $\\basphi_i$', 3, None, '___sec38'),
              ('Example on piecewise quadratic finite element functions',
               2,
               None,
               '___sec39'),
              ('Example on piecewise linear finite element functions',
               2,
               None,
               '___sec40'),
              ('Example on piecewise cubic finite element basis functions',
               2,
               None,
               '___sec41'),
              ('Calculating the linear system',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              ('Calculating specific matrix entries', 3, None, '___sec43'),
              ('Calculating a general row in the matrix',
               3,
               None,
               '___sec44'),
              ('Assembly of elementwise computations',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              ('The element matrix', 3, None, '___sec46'),
              ('Assembly of element matrices', 3, None, '___sec47'),
              ('Assembly of irregularly numbered elements and nodes',
               3,
               None,
               '___sec48'),
              ('The element vector', 3, None, '___sec49'),
              ('Mapping to a reference element',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              ('The coordinate transformation', 3, None, '___sec51'),
              ('Formulas for the element matrix and vector entries',
               3,
               None,
               '___sec52'),
              ('Formulas for local basis functions', 3, None, '___sec53'),
              ('Example: Integration over a reference element',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              ('Implementation',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              ('Integration',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              ('Linear system assembly and solution',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              ('Example on computing symbolic approximations',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              ('Using interpolation instead of least squares',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              ('Example on computing numerical approximations',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              ('The structure of the coefficient matrix',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              ('Applications',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              ('Sparse matrix storage and solution',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              ('Comparison of finite element and finite difference approximations',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              ('Finite difference approximation of given functions',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              ('Finite difference interpretation of a finite element approximation',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              ('Making finite elements behave as finite differences',
               2,
               'fem:deq:1D:approx:fem_vs_fdm',
               'fem:deq:1D:approx:fem_vs_fdm'),
              ('Computations in physical space', 3, None, '___sec68'),
              ('Elementwise computations', 3, None, '___sec69'),
              ('Terminology', 3, None, '___sec70'),
              ('A generalized element concept',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              ('Cells, vertices, and degrees of freedom',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              ('Extended finite element concept',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              ('Implementation',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              ('Computing the error of the approximation',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              ('Example: Cubic Hermite polynomials',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              ('Numerical integration', 1, None, '___sec77'),
              ('Newton-Cotes rules',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              ('Gauss-Legendre rules with optimized points',
               2,
               None,
               '___sec79'),
              ('Approximation of functions in 2D',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              ('2D basis functions as tensor products of 1D functions',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              ('Example: Polynomial basis in 2D', 2, None, '___sec82'),
              ('Implementation',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              ('Extension to 3D',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              ('Finite elements in 2D and 3D', 1, None, '___sec85'),
              ('Basis functions over triangles in the physical domain',
               2,
               None,
               '___sec86'),
              ('Element matrices and vectors', 3, None, '___sec87'),
              ('Basis functions over triangles in the reference cell',
               2,
               None,
               '___sec88'),
              ('Affine mapping of the reference cell', 2, None, '___sec89'),
              ('Isoparametric mapping of the reference cell',
               2,
               None,
               '___sec90'),
              ('Computing integrals', 2, None, '___sec91'),
              ('Exercises', 1, None, '___sec92'),
              ('Problem 1: Linear algebra refresher',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              ('Problem 2: Approximate a three-dimensional vector in a plane',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              ('Problem 3: Approximate a parabola by a sine',
               2,
               'fem:approx:exer:parabola_sine',
               'fem:approx:exer:parabola_sine'),
              ('Problem 4: Approximate the exponential function by power functions',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              ('Problem 5: Approximate the sine function by power functions',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              ('Problem 6: Approximate a steep function by sines',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              ('Remarks', 3, None, '___sec99'),
              ('Problem 7: Approximate a steep function by sines with boundary adjustment',
               2,
               'fem:approx:exer:tanh:sine3',
               'fem:approx:exer:tanh:sine3'),
              ('Remarks', 3, None, '___sec101'),
              ('Exercise 8: Fourier series as a least squares approximation',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              ('Problem 9: Approximate a steep function by Lagrange polynomials',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              ('Problem 10: Approximate a steep function by Lagrange polynomials and regression',
               2,
               'fem:approx:exer:tanh:Lagrange:regression',
               'fem:approx:exer:tanh:Lagrange:regression'),
              ('Problem 11: Define nodes and elements',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              ('Problem 12: Define vertices, cells, and dof maps',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              ('Problem 13: Construct matrix sparsity patterns',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              ('Problem 14: Perform symbolic finite element computations',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              ('Problem 15: Approximate a steep function by P1 and P2 elements',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              ('Problem 16: Approximate a steep function by P3 and P4 elements',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              ('Exercise 17: Investigate the approximation error in finite elements',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              ('Problem 18: Approximate a step function by finite elements',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              ('Exercise 19: 2D approximation with orthogonal functions',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              ('Exercise 20: Use the Trapezoidal rule and P1 elements',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              ('Exercise 21: Compare P1 elements and interpolation',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              ('Exercise 22: Implement 3D computations with global basis functions',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              ("Exercise 23: Use Simpson's rule and P2 elements",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              ('Bibliography', 1, None, '___sec118')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="approx-sol.html">Approximation of functions</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#fem:approx:vec" style="font-size: 80%;"><b>Approximation of vectors</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#fem:approx:vec:plane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of planar vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The projection method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#fem:approx:vec:Np1dim" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Approximation of general vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol002.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Galerkin or projection method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global" style="font-size: 80%;"><b>Approximation of functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:LS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The projection (or Galerkin) method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: linear approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:LS:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of the least squares method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fall back on numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting the approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:exact" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Perfect approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:illconditioning" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Ill-conditioning</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Fourier series</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:orth" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Orthogonal basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical computations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The interpolation (or collocation) method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The regression method</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overdetermined equation system</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The normal equations derived from a least squares principle</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#fem:approx:global:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Approximation of a polynomial</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Successful example</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less successful example</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol003.html#___sec32" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remedy for strong oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe" style="font-size: 80%;"><b>Finite element basis functions</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe:def:elements:nodes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construction principles</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of \( \basphi_i \)</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example on piecewise quadratic finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example on piecewise linear finite element functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example on piecewise cubic finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:global:linearsystem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Calculating the linear system</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating specific matrix entries</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec44" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculating a general row in the matrix</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe:elementwise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Assembly of elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element matrix</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of element matrices</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec48" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assembly of irregularly numbered elements and nodes</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The element vector</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe:mapping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Mapping to a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The coordinate transformation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for the element matrix and vector entries</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulas for local basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol004.html#fem:approx:fe:intg:ref" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: Integration over a reference element</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl" style="font-size: 80%;"><b>Implementation</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:intg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:linsys" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear system assembly and solution</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:ex1:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example on computing symbolic approximations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:ex1:collocation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Using interpolation instead of least squares</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:ex1:numeric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example on computing numerical approximations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:A:structure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The structure of the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:ex2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Applications</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol005.html#fem:approx:fe:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Sparse matrix storage and solution</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:approx:fe:fd" style="font-size: 80%;"><b>Comparison of finite element and finite difference approximations</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:approx:fe:fd:fdproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference approximation of given functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:approx:fe:fd:feproj" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference interpretation of a finite element approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#fem:deq:1D:approx:fem_vs_fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Making finite elements behave as finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computations in physical space</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elementwise computations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol006.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminology</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:element" style="font-size: 80%;"><b>A generalized element concept</b></a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:element:terminology" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Cells, vertices, and degrees of freedom</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:element:def" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Extended finite element concept</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:element:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing the error of the approximation</a></li>
     <!-- navigation toc: --> <li><a href="#fem:approx:fe:element:impl:Hermite" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: Cubic Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol008.html#___sec77" style="font-size: 80%;"><b>Numerical integration</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol008.html#fem:approx:fe:numint1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton-Cotes rules</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol008.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Gauss-Legendre rules with optimized points</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:2D" style="font-size: 80%;"><b>Approximation of functions in 2D</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:2D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;2D basis functions as tensor products of 1D functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: Polynomial basis in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:2D:global:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol009.html#fem:approx:3D:global" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Extension to 3D</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec85" style="font-size: 80%;"><b>Finite elements in 2D and 3D</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basis functions over triangles in the physical domain</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element matrices and vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basis functions over triangles in the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Affine mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Isoparametric mapping of the reference cell</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol010.html#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Computing integrals</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#___sec92" style="font-size: 80%;"><b>Exercises</b></a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:linalg1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 1: Linear algebra refresher</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:vec:3Dby2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 2: Approximate a three-dimensional vector in a plane</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:parabola_sine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 3: Approximate a parabola by a sine</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:exp:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 4: Approximate the exponential function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:sin:powers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 5: Approximate the sine function by power functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:sine1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 6: Approximate a steep function by sines</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:sine3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 7: Approximate a steep function by sines with boundary adjustment</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 8: Fourier series as a least squares approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:Lagrange" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 9: Approximate a steep function by Lagrange polynomials</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:Lagrange:regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 10: Approximate a steep function by Lagrange polynomials and regression</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:mesh1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 11: Define nodes and elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:mesh2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 12: Define vertices, cells, and dof maps</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:defmesh:sparsity" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 13: Construct matrix sparsity patterns</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:Asinwt:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 14: Perform symbolic finite element computations</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:P1P2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 15: Approximate a steep function by P1 and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:exer:tanh:P3P4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 16: Approximate a steep function by P3 and P4 elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:Asinwt:interpol:error" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 17: Investigate the approximation error in finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:Heaviside" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 18: Approximate a step function by finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:2Dsines:symbolic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 19: 2D approximation with orthogonal functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:1D:trapez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 20: Use the Trapezoidal rule and P1 elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:1D:P1:vs:interp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 21: Compare P1 elements and interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:3D:approx3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 22: Implement 3D computations with global basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol011.html#fem:approx:fe:exer:1D:simpson" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 23: Use Simpson's rule and P2 elements</a></li>
     <!-- navigation toc: --> <li><a href="._approx-sol012.html#___sec118" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0007"></a>
<!-- !split -->

<h1 id="fem:approx:fe:element">A generalized element concept</h1>

<p>
So far, finite element computing has employed the <code>nodes</code> and
<code>element</code> lists together with the definition of the basis functions
in the reference element. Suppose we want to introduce a piecewise
constant approximation with one basis function \( \refphi_0(x)=1 \) in
the reference element, corresponding to a \( \basphi_i(x) \) function that
is 1 on element number \( i \) and zero on all other elements.
Although we could associate the function value
with a node in the middle of the elements, there are no nodes at the
ends, and the previous code snippets will not work because we
cannot find the element boundaries from the <code>nodes</code> list.

<p>
In order to get a richer space of finite element approximations, we need
to revise the simple node and element concept presented so far and
introduce a more powerful terminology. Much literature employs the
definition of node and element introduced in the previous sections
so it is important have this knowledge, besides being a good pedagogical
background from understanding the extended element concept in the following.

<h2 id="fem:approx:fe:element:terminology">Cells, vertices, and degrees of freedom</h2>

<p>
We now introduce <em>cells</em> as the subdomains \( \Omega^{(e)} \) previously
referred to as elements. The cell boundaries are denoted as <em>vertices</em>.
The reason for this name is that cells are recognized by their vertices
in 2D and 3D. We also define a set of <em>degrees of freedom</em> (dof), which are
the quantities we aim to compute. The most common type of degree
of freedom is the value of the unknown function \( u \) at some point.
(For example, we can introduce nodes as before and say the degrees of
freedom are the values of \( u \) at the nodes.) The basis functions are
constructed so that they equal unity for one particular degree of
freedom and zero for the rest. This property ensures that when
we evaluate \( u=\sum_j c_j\basphi_j \) for degree of freedom number \( i \),
we get \( u=c_i \). Integrals are performed over cells, usually by
mapping the cell of interest to a <em>reference cell</em>.

<p>
With the concepts of cells, vertices, and degrees of freedom we
increase the decoupling of the geometry (cell, vertices) from the
space of basis functions. We will associate different
sets of basis functions with a cell. In 1D, all cells are intervals,
while in 2D we can have cells that are triangles with straight sides,
or any polygon, or in fact any two-dimensional geometry. Triangles and
quadrilaterals are most common, though. The popular cell types in 3D
are tetrahedra and hexahedra.

<h2 id="fem:approx:fe:element:def">Extended finite element concept</h2>

<p>
The concept of a <em>finite element</em> is now

<ul>
  <li> a <em>reference cell</em> in a local reference coordinate system;</li>
  <li> a set of <em>basis functions</em> \( \refphi_i \) defined on the cell;</li>
  <li> a set of <em>degrees of freedom</em> that uniquely determines
    the basis functions such that \( \refphi_i=1 \) for degree of freedom
    number \( i \) and \( \refphi_i=0 \) for all other degrees of freedom;</li>
  <li> a mapping between local and global degree of freedom numbers,
    here called the <em>dof map</em>;</li>
  <li> a geometric <em>mapping</em> of the reference cell onto the cell in the physical
    domain.</li>
</ul>

There must be a geometric description of a cell. This is trivial in 1D
since the cell is an interval and is described by the interval limits,
here called vertices. If the cell is \( \Omega^{(e)}=[x_L,x_R] \),
vertex 0 is \( x_L \) and vertex 1 is \( x_R \). The reference cell in 1D
is \( [-1,1] \) in the reference coordinate system \( X \).

<p>
The expansion of \( u \) over one cell is often used:

$$
\begin{equation}
u(x) = \tilde u(X) = \sum_{r} c_r\refphi_r(X),\quad x\in\Omega^{(e)},\ 
X\in [-1,1],
\tag{100}
\end{equation}
$$

where the sum is taken over the numbers of the degrees of freedom and
\( c_r \) is the value of \( u \) for degree of freedom number \( r \).

<p>
Our previous P1, P2, etc., elements are defined by introducing \( d+1 \)
equally spaced nodes in the reference cell and saying that the degrees
of freedom are the \( d+1 \) function values at these nodes.  The basis
functions must be 1 at one node and 0 at the others, and the Lagrange
polynomials have exactly this property.  The nodes can be numbered
from left to right with associated degrees of freedom that are
numbered in the same way.  The degree of freedom mapping becomes what
was previously represented by the <code>elements</code> lists.  The cell mapping
is the same affine mapping <a href="._approx-sol004.html#mjx-eqn-70">(70)</a> as
before.

<h2 id="fem:approx:fe:element:impl">Implementation</h2>

<p>
Implementationwise,

<ul>
  <li> we replace <code>nodes</code> by <code>vertices</code>;</li>
  <li> we introduce <code>cells</code> such that <code>cell[e][r]</code> gives the mapping
    from local vertex <code>r</code> in cell <code>e</code> to the global vertex number
    in <code>vertices</code>;</li>
  <li> we replace <code>elements</code> by <code>dof_map</code> (the contents are the same
    for Pd elements).</li>
</ul>

Consider the example from the section <a href="._approx-sol004.html#fem:approx:fe:def:elements:nodes">Elements and nodes</a>
where \( \Omega =[0,1] \) is divided into two cells,
\( \Omega^{(0)}=[0,0.4] \) and \( \Omega^{(1)}=[0.4,1] \), as
depicted in Figure <a href="._approx-sol004.html#fem:approx:fe:def:elements:nodes:fig:P2">18</a>.
The vertices are \( [0,0.4,1] \). Local vertex 0 and 1 are
\( 0 \) and \( 0.4 \) in cell 0 and \( 0.4 \) and \( 1 \) in cell 1.
A P2 element means that the degrees of freedom are
the value of \( u \) at three equally spaced points (nodes) in each
cell. The data structures become

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">1</span>]
cells <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]]
</pre></div>
<p>
If we would approximate \( f \) by piecewise constants, known as
P0 elements, we simply
introduce one point or node in an element, preferably \( X=0 \),
and define one degree of freedom, which is the function value
at this node. Moreover, we set \( \refphi_0(X)=1 \).
The <code>cells</code> and <code>vertices</code> arrays remain the same, but
<code>dof_map</code> is altered:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">1</span>]]
</pre></div>
<p>
We use the <code>cells</code> and <code>vertices</code> lists to retrieve information
on the geometry of a cell, while <code>dof_map</code> is the
\( q(e,r) \) mapping introduced earlier in the
assembly of element matrices and vectors.
For example, the <code>Omega_e</code> variable (representing the cell interval)
in previous code snippets must now be computed as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Omega_e <span style="color: #666666">=</span> [vertices[cells[e][<span style="color: #666666">0</span>], vertices[cells[e][<span style="color: #666666">1</span>]]
</pre></div>
<p>
The assembly is done by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A[dof_map[e][r], dof_map[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
b[dof_map[e][r]] <span style="color: #666666">+=</span> b_e[r]
</pre></div>
<p>
We will hereafter drop the <code>nodes</code> and <code>elements</code> arrays
and work exclusively with <code>cells</code>, <code>vertices</code>, and <code>dof_map</code>.
The module <code>fe_approx1D_numint.py</code> now replaces the module
<code>fe_approx1D</code> and offers similar functions that work with
the new concepts:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> x)
N_e <span style="color: #666666">=</span> <span style="color: #666666">10</span>
vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(N_e, d<span style="color: #666666">=3</span>, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])
phi <span style="color: #666666">=</span> [basis(<span style="color: #008000">len</span>(dof_map[e])<span style="color: #666666">-1</span>) <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e)]
A, b <span style="color: #666666">=</span> assemble(vertices, cells, dof_map, phi, f)
c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)
<span style="color: #408080; font-style: italic"># Make very fine mesh and sample u(x) on this mesh for plotting</span>
x_u, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map,
                resolution_per_element<span style="color: #666666">=51</span>)
plot(x_u, u)
</pre></div>
<p>
These steps are offered in the <code>approximate</code> function, which we here
apply to see how well four P0 elements (piecewise constants)
can approximate a parabola:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D_numint</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
x<span style="color: #666666">=</span>sym<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&quot;x&quot;</span>)
<span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">4</span>, <span style="color: #666666">8</span>:
    approximate(x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x), d<span style="color: #666666">=0</span>, N_e<span style="color: #666666">=</span>N_e, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])
</pre></div>
<p>
Figure <a href="#fem:approx:fe:element:impl:fig:P0:x2">34</a> shows the result.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  Approximation of a parabola by 4 (left) and 8 (right) P0 elements. <div id="fem:approx:fe:element:impl:fig:P0:x2"></div> </p></center>
<p><img src="fig-approx/fe_p0_x2_4e_8e.png" align="bottom" width=600></p>
</center>

<h2 id="fem:approx:fe:error">Computing the error of the approximation</h2>

<p>
So far we have focused on computing the coefficients \( c_j \) in the
approximation \( u(x)=\sum_jc_j\basphi_j \) as well as on plotting \( u \) and
\( f \) for visual comparison. A more quantitative comparison needs to
investigate the error \( e(x)=f(x)-u(x) \). We mostly want a single number to
reflect the error and use a norm for this purpose, usually the \( L^2 \) norm

$$ ||e||_{L^2} = \left(\int_{\Omega} e^2 \dx\right)^{1/2}\tp$$

Since the finite element approximation is defined for all \( x\in\Omega \),
and we are interested in how \( u(x) \) deviates from \( f(x) \) through all
the elements,
we can either integrate analytically or use an accurate numerical
approximation. The latter is more convenient as it is a generally
feasible and simple approach. The idea is to sample \( e(x) \)
at a large number of points in each element. The function <code>u_glob</code>
in the <code>fe_approx1D_numint</code> module does this for \( u(x) \) and returns
an array <code>x</code> with coordinates and an array <code>u</code> with the \( u \) values:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x, u <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map,
              resolution_per_element<span style="color: #666666">=101</span>)
e <span style="color: #666666">=</span> f(x) <span style="color: #666666">-</span> u
</pre></div>
<p>
Let us use the Trapezoidal method to approximate the integral. Because
different elements may have different lengths, the <code>x</code> array has
a non-uniformly distributed set of coordinates. Also, the <code>u_glob</code>
function works in an element by element fashion such that coordinates
at the boundaries between elements appear twice. We therefore need
to use a "raw" version of the Trapezoidal rule where we just add up
all the trapezoids:

$$ \int_\Omega g(x) \dx \approx \sum_{j=0}^{n-1} \half(g(x_j) +
g(x_{j+1}))(x_{j+1}-x_j),$$

if \( x_0,\ldots,x_n \) are all the coordinates in <code>x</code>. In
vectorized Python code,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">g_x <span style="color: #666666">=</span> g(x)
integral <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>sum((g_x[:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> g_x[<span style="color: #666666">1</span>:])<span style="color: #666666">*</span>(x[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span> x[:<span style="color: #666666">-1</span>]))
</pre></div>
<p>
Computing the \( L^2 \) norm of the error, here named <code>E</code>, is now achieved by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">e2 <span style="color: #666666">=</span> e<span style="color: #666666">**2</span>
E <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>sum((e2[:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> e2[<span style="color: #666666">1</span>:])<span style="color: #666666">*</span>(x[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span> x[:<span style="color: #666666">-1</span>]))
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How does the error depend on \( h \) and \( d \)?</b>
Theory and experiments show that the least squares or projection/Galerkin
method in combination with Pd elements of equal length \( h \) has an error

$$
\begin{equation}
||e||_{L^2} = C|f^{(d+1)}|h^{d+1},
\tag{101}
\end{equation}
$$

where \( C \) is a constant depending on \( d \) and \( \Omega=[0,L] \),
but not on \( h \), and the norm \( |f^{(d+1)}| \) is defined through

$$ |f^{(d+1)}|^2 = \int_0^L \left(\frac{d^{d+1}f}{dx^{d+1}}\right)^2dx$$

<p>
</div>


<h2 id="fem:approx:fe:element:impl:Hermite">Example: Cubic Hermite polynomials</h2>

<p>
The finite elements considered so far represent \( u \) as piecewise
polynomials with discontinuous derivatives at the cell boundaries.
Sometimes it is desirable to have continuous derivatives. A primary
example is the solution of differential equations with fourth-order
derivatives where standard finite element formulations lead to
a need for basis functions with continuous first-order derivatives.
The most common type of such basis functions in 1D is the
so-called cubic Hermite polynomials.
The construction of such polynomials, as explained next, will further
exemplify the concepts of a cell, vertex, degree of freedom, and dof map.

<p>
Given a reference cell \( [-1,1] \), we seek cubic polynomials
with the values of the <em>function</em> and its <em>first-order derivative</em> at
\( X=-1 \) and \( X=1 \) as the four degrees of freedom. Let us number
the degrees of freedom as

<ul>
  <li> 0: value of function at \( X=-1 \)</li>
  <li> 1: value of first derivative at \( X=-1 \)</li>
  <li> 2: value of function at \( X=1 \)</li>
  <li> 3: value of first derivative at \( X=1 \)</li>
</ul>

By having the derivatives as unknowns, we ensure that
the derivative of a basis function in two neighboring elements
is the same at the node points.

<p>
The four basis functions can be written in a general form
$$ \refphi_i (X) = \sum_{j=0}^3 C_{i,j}X^j, $$

with four coefficients \( C_{i,j} \), \( j=0,1,2,3 \), to be determined for
each \( i \). The constraints
that basis function number \( i \) must be 1 for degree of
freedom number \( i \) and zero for the other three degrees of freedom,
gives four equations to determine \( C_{i,j} \) for each \( i \). In mathematical
detail,
$$
\begin{align*}
\refphi_0 (-1) &= 1,\quad \refphi_0 (1)=\refphi_0'(-1)=\refphi_i' (1)=0,\\ 
\refphi_1' (-1) &= 1,\quad \refphi_1 (-1)=\refphi_1(1)=\refphi_1' (1)=0,\\ 
\refphi_2 (1) &= 1,\quad \refphi_2 (-1)=\refphi_2'(-1)=\refphi_2' (1)=0,\\ 
\refphi_3' (1) &= 1,\quad \refphi_3 (-1)=\refphi_3'(-1)=\refphi_3 (1)=0
\tp
\end{align*}
$$

These four \( 4\times 4 \) linear equations can be solved, yielding the
following formulas
for the cubic basis functions:

$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3
\tag{102}\\ 
\refphi_1(X) &= -(X+1)(1 - \half(X+1))^2
\tag{103}\\ 
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \half(X+1)^3
\tag{104}\\ 
\refphi_3(X) &= -\half(X+1)(\half(X+1)^2 - (X+1))
\tag{105}\\ 
\tag{106}
\end{align}
$$

<p>
The construction of the dof map needs a scheme for numbering the
global degrees of freedom. A natural left-to-right numbering
has the function value at vertex \( \xno{i} \)
as degree of freedom number \( 2i \) and the value of the derivative
at \( \xno{i} \) as degree of freedom number \( 2i+1 \), \( i=0,\ldots,N_e+1 \).

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._approx-sol006.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._approx-sol008.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

