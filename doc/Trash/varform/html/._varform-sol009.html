<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Stationary variational forms">
<meta name="keywords" content="residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition">

<title>Stationary variational forms</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems and their solutions',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec4'),
              ('The Galerkin method', 2, None, '___sec5'),
              ('The Method of Weighted Residuals', 2, None, '___sec6'),
              ('Test and Trial Functions', 2, None, '___sec7'),
              ('The collocation method', 2, None, '___sec8'),
              ('The subdomain collocation method', 3, None, '___sec9'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec11'),
              ('Basis functions', 3, None, '___sec12'),
              ('The residual', 3, None, '___sec13'),
              ('The least squares method', 3, None, '___sec14'),
              ('The Galerkin method', 3, None, '___sec15'),
              ('The collocation method', 3, None, '___sec16'),
              ('Comparison', 3, None, '___sec17'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec19'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and minimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Example', 3, None, '___sec23'),
              ('The general minimization problem', 3, None, '___sec24'),
              ('Derivation', 3, None, '___sec25'),
              ('Minimization of the discretized functional',
               3,
               None,
               '___sec26'),
              ('Calculus of variations', 3, None, '___sec27'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec29'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec30'),
              ('Nonlinear coefficient', 2, None, '___sec31'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec33'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions',
               2,
               None,
               '___sec35'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               'fem:deq:1D:fdm_vs_fem',
               'fem:deq:1D:fdm_vs_fem'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec39'),
              ('The integral for the element vector', 3, None, '___sec40'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec41'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec42'),
              ('Assembly', 3, None, '___sec43'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec46'),
              ('Computations in physical coordinates', 3, None, '___sec47'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec48'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec50'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               None,
               '___sec52'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec54'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec58'),
              ('Implementation', 1, 'fem:deq:1D:code', 'fem:deq:1D:code'),
              ('Global basis functions',
               2,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Example: constant right-hand side', 2, None, '___sec61'),
              ('Finite elements',
               2,
               'fem:deq:1D:code:fe',
               'fem:deq:1D:code:fe'),
              ('Utilizing a sparse matrix',
               2,
               'fem:deq:1D:code:fe_sparse',
               'fem:deq:1D:code:fe_sparse'),
              ('Example', 3, None, '___sec64'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec66'),
              ('Example on a multi-dimensional variational problem',
               2,
               None,
               '___sec67'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec68'),
              ('Numerical integration', 2, None, '___sec69'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec70'),
              ('A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec71'),
              ('Abstract variational forms', 3, None, '___sec72'),
              ('Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec73'),
              ('Assumptions', 3, None, '___sec74'),
              ('Existence and uniqueness', 3, None, '___sec75'),
              ('Stability', 3, None, '___sec76'),
              ('Equivalent minimization problem', 3, None, '___sec77'),
              ('Best approximation principle', 3, None, '___sec78'),
              ('Best approximation property in the norm of the space',
               3,
               None,
               '___sec79'),
              ('Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec80'),
              ('Equivalent matrix minimization problem', 3, None, '___sec81'),
              ('A priori error estimate for the derivative',
               3,
               None,
               '___sec82'),
              ('A priori error estimate for the solution',
               3,
               None,
               '___sec83'),
              ('Summary', 1, None, '___sec84'),
              ('Exercises', 1, None, '___sec85'),
              ('Exercise 1: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 2: Compute the deflection of a cable with sine functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Least squares method', 3, None, '___sec88'),
              ("Galerkin's method", 3, None, '___sec89'),
              ('Decay of coefficients', 3, None, '___sec90'),
              ('Error in one-term solution', 3, None, '___sec91'),
              ('Exercise 3: Compute the deflection of a cable with power functions',
               2,
               'fem:deq:exer:tension:cable_xn',
               'fem:deq:exer:tension:cable_xn'),
              ('Exercise 4: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 5: Compute the deflection of a cable with 2 P1 elements',
               2,
               'fem:deq:exer:cable:2P1',
               'fem:deq:exer:cable:2P1'),
              ('Method 1: Excluding the unknown at $x=0$',
               3,
               None,
               '___sec95'),
              ('Method 2: Modifying the linear system', 3, None, '___sec96'),
              ('Exercise 6: Compute the deflection of a cable with 1 P2 element',
               2,
               'fem:deq:exer:cable:1P2',
               'fem:deq:exer:cable:1P2'),
              ('Method 1: Excluding the unknown at $x=0$',
               3,
               None,
               '___sec98'),
              ('Method 2: Modifying the linear system', 3, None, '___sec99'),
              ('Exercise 7: Compute the deflection of a cable with a step load',
               2,
               'fem:deq:exer:cable:stepload',
               'fem:deq:exer:cable:stepload'),
              ('Exercise 8: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 9: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 10: Investigate exact finite element solutions',
               2,
               'fem:deq:exer:1D:exact_numerics',
               'fem:deq:exer:1D:exact_numerics'),
              ('Plots for m=0', 3, None, '___sec104'),
              ('Plots for m=1', 3, None, '___sec105'),
              ('Plots for m=2', 3, None, '___sec106'),
              ('Plots for m=3', 3, None, '___sec107'),
              ('Plots for m=4', 3, None, '___sec108'),
              ('Exercise 11: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 12: Compute with variable coefficients and P1 elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 13: Solve a 2D Poisson equation using polynomials and sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Bibliography', 1, None, '___sec112')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="varform-sol.html">Stationary variational forms</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._varform-sol001.html#fem:deq:1D:principles" style="font-size: 80%;">Basic principles for approximating differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol002.html#fem:deq:1D:varform:ex" style="font-size: 80%;">Examples on variational formulations</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol003.html#fem:deq:1D:fem1" style="font-size: 80%;">Computing with finite elements</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol004.html#fem:deq:1D:essBC" style="font-size: 80%;">Boundary conditions: specified nonzero value</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol005.html#fem:deq:1D:BC:nat" style="font-size: 80%;">Boundary conditions: specified derivative</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol006.html#fem:deq:1D:code" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol007.html#fem:deq:2D:varform" style="font-size: 80%;">Variational formulations in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol008.html#___sec84" style="font-size: 80%;">Summary</a></li>
     <!-- navigation toc: --> <li><a href="#___sec85" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._varform-sol010.html#___sec112" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0009"></a>
<!-- !split -->

<h1 id="___sec85">Exercises </h1>

<p>
<!-- examples on model4 with 1, x, x^2 etc. Show that N=2 recovers -->
<!-- the exact solution -->

<p>
<!-- heat conduction in the ground with radioactivity, need good  model, not -->
<!-- just the old one -->
<!-- string with load -->
<!-- hanging cable, see ideas/5620 articles about that (nonlinear) -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:BVP1D:class">Exercise 1: Refactor functions into a more general class</h2>

<p>
The section <a href="._varform-sol001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a> lists three functions for
computing the analytical solution of some simple model problems. There
is quite some repetitive code, suggesting that the functions can
benefit from being refactored into a class hierarchy, where the super
class solves \( -(a(x)u'(x))'=f(x) \) and where subclasses define the
equations for the boundary conditions in a model. Make a method for
returning the residual in the differential equation and the boundary
conditions when the solution is inserted in these equations. Create a
test function that verifies that all three residuals vanish for each
of the model problems in the section <a href="._varform-sol001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>.  Also
make a method that returns the solution either as <code>sympy</code> expression
or as a string in LaTeX format.  Add a fourth subclass for the problem
\( -(au')'=f \) with a Robin boundary condition:

$$ u(0)=0,\quad -u'(L) = C(u - D)\tp$$

Demonstrate the use of this subclass for the case \( f=0 \) and \( a=\sqrt{1+x} \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

<p>
This is an exercise in software engineering.
The model-specific information is related to the boundary
conditions only. We can then let the super class take care of the
differential equation and the solution process, while subclasses
provide a method <code>get_bc</code> to
return the symbolic expressions for the boundary equations.

<p>
The super class may be coded as
shown below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, L, C, D, c_0, c_1, <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x L C D c_0 c_1&#39;</span>)

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">TwoPtBoundaryValueProblem</span>(<span style="color: #008000">object</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve -(a*u&#39;)&#39; = f(x) with boundary conditions</span>
<span style="color: #BA2121; font-style: italic">    specified in subclasses (method get_bc).</span>
<span style="color: #BA2121; font-style: italic">    a and f must be sympy expressions of x.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, f, a<span style="color: #666666">=1</span>, L<span style="color: #666666">=</span>L, C<span style="color: #666666">=</span>C, D<span style="color: #666666">=</span>D):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Default values for L, C, D are symbols.&quot;&quot;&quot;</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>f <span style="color: #666666">=</span> f
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a <span style="color: #666666">=</span> a
        <span style="color: #008000">self</span><span style="color: #666666">.</span>L <span style="color: #666666">=</span> L
        <span style="color: #008000">self</span><span style="color: #666666">.</span>C <span style="color: #666666">=</span> C
        <span style="color: #008000">self</span><span style="color: #666666">.</span>D <span style="color: #666666">=</span> D

        <span style="color: #408080; font-style: italic"># Integrate twice</span>
        u_x <span style="color: #666666">=</span> <span style="color: #666666">-</span> sym<span style="color: #666666">.</span>integrate(f, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_0
        u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(u_x<span style="color: #666666">/</span>a, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_1
        <span style="color: #408080; font-style: italic"># Set up 2 equations from the 2 boundary conditions and solve</span>
        <span style="color: #408080; font-style: italic"># with respect to the integration constants c_0, c_1</span>
        eq <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_bc(u)
        eq <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(eq_) <span style="color: #008000; font-weight: bold">for</span> eq_ <span style="color: #AA22FF; font-weight: bold">in</span> eq]
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;BC eq:&#39;</span>, eq
        <span style="color: #008000">self</span><span style="color: #666666">.</span>u <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>apply_bc(eq, u)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">apply_bc</span>(<span style="color: #008000">self</span>, eq, u):
        <span style="color: #408080; font-style: italic"># Solve BC eqs respect to the integration constants</span>
        r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve(eq, [c_0, c_1])
        <span style="color: #408080; font-style: italic"># Substitute the integration constants in the solution</span>
        u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(c_0, r[c_0])<span style="color: #666666">.</span>subs(c_1, r[c_1])
        u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(u))
        <span style="color: #008000; font-weight: bold">return</span> u

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_solution</span>(<span style="color: #008000">self</span>, latex<span style="color: #666666">=</span><span style="color: #008000">False</span>):
        <span style="color: #008000; font-weight: bold">return</span> sym<span style="color: #666666">.</span>latex(<span style="color: #008000">self</span><span style="color: #666666">.</span>u, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>) <span style="color: #008000; font-weight: bold">if</span> latex <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_residuals</span>(<span style="color: #008000">self</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return the residuals in the equation and BCs.&quot;&quot;&quot;</span>
        R_eq <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(sym<span style="color: #666666">.</span>diff(<span style="color: #008000">self</span><span style="color: #666666">.</span>u, x)<span style="color: #666666">*</span><span style="color: #008000">self</span><span style="color: #666666">.</span>a, x) <span style="color: #666666">+</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>f
        R_0, R_L <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>get_bc(<span style="color: #008000">self</span><span style="color: #666666">.</span>u)
        residuals <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>simplify(R) <span style="color: #008000; font-weight: bold">for</span> R <span style="color: #AA22FF; font-weight: bold">in</span> R_eq, R_0, R_L]
        <span style="color: #008000; font-weight: bold">return</span> residuals

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_bc</span>(<span style="color: #008000">self</span>, u):
        <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">NotImplementedError</span>(
            <span style="color: #BA2121">&#39;class </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> has not implemented get_bc&#39;</span> <span style="color: #666666">%</span>
            <span style="color: #008000">self</span><span style="color: #666666">.</span>__class__<span style="color: #666666">.</span>__name__)
</pre></div>
<p>
The various subclasses deal with the boundary conditions of the
various model problems:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Model1</span>(TwoPtBoundaryValueProblem):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;u(0)=0, u(L)=D.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_bc</span>(<span style="color: #008000">self</span>, u):
        <span style="color: #008000; font-weight: bold">return</span> [u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-0</span>,               <span style="color: #408080; font-style: italic"># x=0 condition</span>
                u<span style="color: #666666">.</span>subs(x, <span style="color: #008000">self</span><span style="color: #666666">.</span>L) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>D]   <span style="color: #408080; font-style: italic"># x=L condition</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Model2</span>(TwoPtBoundaryValueProblem):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;u&#39;(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_bc</span>(<span style="color: #008000">self</span>, u):
        <span style="color: #008000; font-weight: bold">return</span> [sym<span style="color: #666666">.</span>diff(u,x)<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>C, <span style="color: #408080; font-style: italic"># x=0 cond.</span>
                u<span style="color: #666666">.</span>subs(x, <span style="color: #008000">self</span><span style="color: #666666">.</span>L) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>D]        <span style="color: #408080; font-style: italic"># x=L cond.</span>

<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Model3</span>(TwoPtBoundaryValueProblem):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;u(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_bc</span>(<span style="color: #008000">self</span>, u):
        <span style="color: #008000; font-weight: bold">return</span> [u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>C,
                u<span style="color: #666666">.</span>subs(x, <span style="color: #008000">self</span><span style="color: #666666">.</span>L) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>D]
</pre></div>
<p>
A suitable test function gets quite compact:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_TwoPtBoundaryValueProblem</span>():
    f <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    model <span style="color: #666666">=</span> Model1(f)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Model 1, u:&#39;</span>, model<span style="color: #666666">.</span>get_solution()
    <span style="color: #008000; font-weight: bold">for</span> R <span style="color: #AA22FF; font-weight: bold">in</span> model<span style="color: #666666">.</span>get_residuals():
        <span style="color: #008000; font-weight: bold">assert</span> R <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    f <span style="color: #666666">=</span> x
    model <span style="color: #666666">=</span> Model2(f)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Model 2, u:&#39;</span>, model<span style="color: #666666">.</span>get_solution()
    <span style="color: #008000; font-weight: bold">for</span> R <span style="color: #AA22FF; font-weight: bold">in</span> model<span style="color: #666666">.</span>get_residuals():
        <span style="color: #008000; font-weight: bold">assert</span> R <span style="color: #666666">==</span> <span style="color: #666666">0</span>

    f <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> x<span style="color: #666666">**2</span>
    model <span style="color: #666666">=</span> Model3(f, a<span style="color: #666666">=</span>a)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Model 3, u:&#39;</span>, model<span style="color: #666666">.</span>get_solution()
    <span style="color: #008000; font-weight: bold">for</span> R <span style="color: #AA22FF; font-weight: bold">in</span> model<span style="color: #666666">.</span>get_residuals():
        <span style="color: #008000; font-weight: bold">assert</span> R <span style="color: #666666">==</span> <span style="color: #666666">0</span>
</pre></div>
<p>
The fourth model is just about defining the boundary conditions as equations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Model4</span>(TwoPtBoundaryValueProblem):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;u(0)=0, -u&#39;(L)=C*(u-D).&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_bc</span>(<span style="color: #008000">self</span>, u):
        <span style="color: #008000; font-weight: bold">return</span> [u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>) <span style="color: #666666">-</span> <span style="color: #666666">0</span>,
                <span style="color: #666666">-</span>sym<span style="color: #666666">.</span>diff(u, x)<span style="color: #666666">.</span>subs(x, <span style="color: #008000">self</span><span style="color: #666666">.</span>L) <span style="color: #666666">-</span>
                <span style="color: #008000">self</span><span style="color: #666666">.</span>C<span style="color: #666666">*</span>(u<span style="color: #666666">.</span>subs(x, <span style="color: #008000">self</span><span style="color: #666666">.</span>L) <span style="color: #666666">-</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>D)]
</pre></div>
<p>
A demo function goes like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo_Model4</span>():
    f <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    model <span style="color: #666666">=</span> Model4(f, a<span style="color: #666666">=</span>sym<span style="color: #666666">.</span>sqrt(<span style="color: #666666">1+</span>x))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Model 4, u:&#39;</span>, model<span style="color: #666666">.</span>get_solution()
</pre></div>
<p>
The printout shows that the solution is

$$ u(x) = \frac{2CD\sqrt{1+L}(\sqrt{1+x}-1}{2C\sqrt{1+L} + 2C+1}\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>uxx_f_sympy_class</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</h2>

<p>
A hanging cable of length \( L \)
with significant tension \( T \) has a deflection \( w(x) \)
governed by

$$
T w''(x) = \ell(x),
$$

where \( \ell(x) \) the vertical load per unit length.
The cable is fixed at \( x=0 \) and \( x=L \) so the boundary conditions become
\( w(0)=w(L)=0 \). The deflection \( w \) is positive upwards, and \( \ell \) is
positive when it acts downwards.

<p>
If we assume a constant load \( \ell(x)=\hbox{const} \),
the solution is expected to be symmetric around \( x=L/2 \). For a function
\( w(x) \) that is symmetric around some point \( x_0 \), it means that
\( w(x_0-h) = w(x_0+h) \), and then \( w'(x_0)=\lim_{h\rightarrow 0}(w(x_0+h)-
w(x_0-h))/(2h)=0 \). We can therefore utilize symmetry to halve the domain.
We then seek \( w(x) \) in \( [0,L/2] \) with boundary conditions \( w(0)=0 \) and
\( w'(L/2)=0 \).

<p>
The problem can be scaled by introducing dimensionless independent
and dependent variables,

$$ \bar x = \frac{x}{L/2},\quad \bar u = \frac{w}{w_c},$$

where \( w_c \) is a characteristic size of \( w \).
Inserted in the problem for \( w \),

$$ \frac{4Tw_c}{L^{2}}\frac{d^2\bar u}{d\bar x^2} = \ell\ (= \hbox{const})\tp$$

A desire is to have \( u \) and its derivatives about unity, so
choosing \( w_c \) such that \( |d^2\bar u/d\bar x^2|=1 \) is an idea.
Then \( w_c=\frac{1}{4}\ell L^2/T \), and the problem for the scaled vertical
deflection \( u \) becomes

$$
u'' = 1,\quad x\in (0,1),\quad u(0)=0,\ u'(1)=0\tp
$$

Observe that there are no physical parameters in this scaled problem.
From now on we have for convenience
renamed \( x \) to be the scaled quantity \( \bar x \).

<p>
<b>a)</b>
Find the exact solution for the deflection \( u \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_2">

<p>
<a href="#fem:deq:exer:BVP1D:class">Exercise 1: Refactor functions into a more general class</a> or
the section <a href="._varform-sol001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a> features tools for finding
the analytical solution of this differential equation.
The present
model problem is close to model 2
in the section <a href="._varform-sol001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>. We can modify the <code>model2</code>
function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">model</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve u&#39;&#39; = -1, u(0)=0, u&#39;(1)=0.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    x, c_0, c_1, <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x c_0 c_1&#39;</span>)
    u_x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(<span style="color: #666666">1</span>, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_0
    u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(u_x, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_1
    r <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>solve([u<span style="color: #666666">.</span>subs(x,<span style="color: #666666">0</span>) <span style="color: #666666">-</span> <span style="color: #666666">0</span>,
                   sym<span style="color: #666666">.</span>diff(u,x)<span style="color: #666666">.</span>subs(x, <span style="color: #666666">1</span>) <span style="color: #666666">-</span> <span style="color: #666666">0</span>],
                  [c_0, c_1])
    u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(c_0, r[c_0])<span style="color: #666666">.</span>subs(c_1, r[c_1])
    u <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(u))
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
The solution becomes

$$ u(x) = \frac{1}{2}x(x-2)\tp$$

Plotting \( u(x) \) shows that \( |u|\in [0,\half] \) which is compatible with
the aim of the scaling, i.e., to have \( u \) of size <em>about</em> unity (at least
not very small or very large).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
A possible function space is spanned by \( \baspsi_i=\sin ((2i+1)\pi x/2) \),
\( i=0,\ldots,N \). These functions
fulfill the necessary condition \( \baspsi_i(0)=0 \),
but they also fulfill \( \baspsi_i'(1)=0 \) such that both boundary
conditions are fulfilled by the expansion \( u=\sum_jc_j\basphi_j \).

<p>
Use a Galerkin and a least squares method to find the coefficients
\( c_j \) in \( u(x)=\sum_j c_j\baspsi_j \). Find how fast the coefficients
decrease in magnitude by looking at \( c_j/c_{j-1} \).
Find the error in the maximum deflection at \( x=1 \) when only one
basis function is used (\( N=0 \)).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
In this case, where the basis functions and their derivatives are
orthogonal, it is easiest to set up the calculations by hand and
use <code>sympy</code> to help out with the integrals.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_3">

<p>
With \( u=\sum_{j=0}^Nc_j\baspsi_j(x) \) the residual becomes

$$ R = 1 - u'' = 1 +\sum_{j=0}^Nc_j\baspsi_j''(x) =
1 + \sum_{j=0}^Nc_j(2j+1)^2\frac{\pi^2}{4}\sin((2j+1)\frac{\pi x}{2})\tp$$

<h3 id="___sec88">Least squares method </h3>

<p>
The minimization of \( \int_0^1R^2dx \) leads to the equations

$$ (R,\frac{\partial R}{\partial c_i})=0,\quad i=0,\ldots,N\tp$$

We find that

$$ \frac{\partial R}{\partial c_i} =
(2i+1)^2\frac{\pi^2}{4}\sin((2i+1)\frac{\pi x}{2}),$$

so the governing equations become

$$ (1+\sum_{j=0}^Nc_j(2j+1)^2\frac{\pi^2}{4}\sin((2j+1)\frac{\pi x}{2}),
(2i+1)^2\frac{\pi^2}{4}\sin((2i+1)\frac{\pi x}{2}) = 0\tp$$

By linearity of the inner product (or integral) this expression can
be reordered to

$$
\begin{align*}
\sum_{j=0}^Nc_j((2j+1)^2\frac{\pi^2}{4}\sin((2j+1)\frac{\pi x}{2}), &
(2i+1)^2\frac{\pi^2}{4}\sin((2i+1)\frac{\pi x}{2}) = \\ 
& -(1, (2i+1)^2\frac{\pi^2}{4}\sin((2i+1)\frac{\pi x}{2})),
\end{align*}
$$

which is nothing but a linear system

$$ \sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,$$

with

$$
\begin{align*}
A_{i,j} &= (2j+1)^4\frac{\pi^4}{16}\int_0^1
\sin((2j+1)\frac{\pi x}{2})\sin((2i+1)\frac{\pi x}{2})dx,\\ 
b_i &= -(2i+1)^2\frac{\pi^2}{4}\int_0^1 \sin((2i+1)\frac{\pi x}{2})dx
\end{align*}
$$

Orthogonality of the sine functions \( \sin (k\pi x/2) \) on \( [0,1] \)
for integer \( k \) implies that
\( A_{i,j}=0 \) for \( i\neq j \), and \( A_{i,i} \) can be
computed by <code>sympy</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> i <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;i&#39;</span>, integer<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;x&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> integrate(sin(i<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)<span style="color: #666666">**2</span>, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">1/2</span>
</pre></div>
<p>
Therefore,

$$ A_{i,j} = \left\lbrace\begin{array}{ll}
0,& i\neq j\\ 
\half (2i+1)^4\frac{\pi^4}{16}, & i = j
\end{array}\right.
$$

The right-hand side can also be computed by <code>sympy</code>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> integrate(sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>), (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>))
</pre></div>
<p>
One should always be skeptical to symbolic software and integration of
periodic functions like the sine and cosine since the answers can be
too simplistic (see subexercise d!).
A general test is to perform numerical integration with
lots of sampling points to (partially) verify the symbolic formula.
Here is an application of the midpoint rule:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint_rule</span>(f, M<span style="color: #666666">=100000</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Integrate f(x) over [0,1] using M intervals.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #008000">sum</span>, linspace
    dx <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>M                       <span style="color: #408080; font-style: italic"># interval length</span>
    x <span style="color: #666666">=</span> linspace(dx<span style="color: #666666">/2</span>, <span style="color: #666666">1-</span>dx<span style="color: #666666">/2</span>, M)    <span style="color: #408080; font-style: italic"># integration points</span>
    <span style="color: #008000; font-weight: bold">return</span> dx<span style="color: #666666">*</span><span style="color: #008000">sum</span>(f(x))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_integral_b</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">12</span>):
        exact <span style="color: #666666">=</span> <span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>))
        numerical <span style="color: #666666">=</span> midpoint_rule(
            f<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>))
        <span style="color: #008000; font-weight: bold">print</span> i, <span style="color: #008000">abs</span>(exact <span style="color: #666666">-</span> numerical)
</pre></div>
<p>
The output shows that the difference between numerical and exact
integration is about \( 10^{-11} \), which is &quot;small&quot; (and gets smaller
by just increasing <code>M</code>). This result brings evidence that the
<code>sympy</code> answer is correct.
Alternatively, in this simple case, we can easily calculate the anti-derivative.
It goes like

$$ -\frac{2}{\pi(2i+1)}\cos((2k+1)\frac{\pi x}{2}),$$

and for \( x=1 \) we get
\( \cos\frac{\pi}{2} \), \( \cos 3\frac{\pi}{2} \), \( \cos 5\frac{\pi}{2} \),
and so on, which all evaluates to zero, and since the cosine is 1 for \( x=0 \),
the formula found by <code>sympy</code> is correct.

<p>
We then get

$$ b_i = -(2i+1)^2\frac{\pi^2}{4}\frac{2}{\pi(2i+1)} = -\half (2i+1)\pi,$$

and consequently,

$$ c_i = \frac{b_i}{A_{i,i}} = -\frac{\half (2i+1)\pi}{\half (2i+1)^4}\frac{\pi^4}{16} = -\frac{16}{\pi^3(2i+1)^3}\tp$$

<h3 id="___sec89">Galerkin's method </h3>

<p>
The Galerkin method applied to this problem
starts with

$$ (u'',v) = (1,v)\quad \forall v\in V,$$

and the requirement that \( v(0)=0 \) since \( u(0)=0 \).
Integration by parts and using \( u'(1)=0 \) and \( v(0)=0 \) makes the boundary
term vanish, and the variational form becomes

$$ (u',v') = -(1,v) \quad \forall v\in V\tp$$

Inserting \( u=\sum_{j=0}^Nc_j\baspsi_j(x) \) and \( v=\baspsi_i \) leads to

$$ \sum_{j=0}^N (\baspsi_j', \baspsi_i')c_j = (1,\baspsi_i),\quad i=0,\ldots,N\tp
$$

With \( \baspsi_i=\sin((2i+1)\frac{\pi x}{2}) \) the matrix entries become

$$ A_{i,j} =  (2i+1)(2j+1)\frac{\pi^2}{4}\int_0^1 \cos((2i+1)\frac{\pi x}{2})
\cos((2j+1)\frac{\pi x}{2})dx\tp$$

Orthogonality of the cosine functions implies \( A_{i,j}=0 \) for
\( i\neq j \), and \( A_{i,i} \) is computed by integrating the square
of the cosine function,

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> integrate(cos((k<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)<span style="color: #666666">**2</span>, (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">1/2</span>
</pre></div>
<p>
Now,

$$ A_{i,i} = (2i+1)^2\frac{\pi^2}{4}\half = \frac{1}{8}(2i+1)^2 \pi^2\tp$$

The right-hand side has almost the same integral as in the
least squares case,

$$ b_i = -\int_0^1 \sin((2i+1)\frac{\pi x}{2})dx = -\frac{2}{\pi (2i+1)}\tp$$

Consequently,

$$ c_i = \frac{b_i}{A_{i,i}} = -\frac{16}{\pi^3(2i+1)^3},$$

which is the same result as we obtained in the least squares method.

<h3 id="___sec90">Decay of coefficients </h3>

<p>
The coefficients decay,

$$ \frac{c_i}{c_{i+1}} = \left(\frac{2i+3}{2i+1}\right)^3 > 0\tp$$

The decay is most pronounced for the first terms:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">10</span>):
<span style="color: #666666">...</span>   <span style="color: #008000; font-weight: bold">print</span> (<span style="color: #008000">float</span>(<span style="color: #666666">2*</span>i<span style="color: #666666">+3</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>))<span style="color: #666666">**3</span>
<span style="color: #666666">...</span>
<span style="color: #666666">27.0</span>
<span style="color: #666666">4.62962962963</span>
<span style="color: #666666">2.744</span>
<span style="color: #666666">2.12536443149</span>
<span style="color: #666666">1.82578875171</span>
<span style="color: #666666">1.65063861758</span>
<span style="color: #666666">1.53618570778</span>
<span style="color: #666666">1.4557037037</span>
<span style="color: #666666">1.39609200081</span>
<span style="color: #666666">1.35019682169</span>
</pre></div>

<h3 id="___sec91">Error in one-term solution </h3>

<p>
Keeping just one term (\( N=0 \)) means that

$$ u(x) = -\frac{16}{\pi^3}\sin(\frac{\pi x}{2})\tp$$

The maximum deflection at \( x=1 \) becomes \( -16\pi^{-3}=-0.5160 \), to be compared
with the exact value \( -\half \). The error is 3.2 percent.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Visualize the solutions in b) for \( N=0,1,20 \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_4">

<p>
First we need a function to compute the approximate \( u \) in this case:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_sum</span>(x, N):
    s <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin, zeros
    u <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># u[k] is the sum i=0,...,k</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        s <span style="color: #666666">+=</span> <span style="color: #666666">-</span> <span style="color: #666666">16.0/</span>((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">**3*</span>pi<span style="color: #666666">**3</span>)<span style="color: #666666">*</span>sin((<span style="color: #666666">2*</span>i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)
        u<span style="color: #666666">.</span>append(s<span style="color: #666666">.</span>copy())  <span style="color: #408080; font-style: italic"># important with copy!</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
Note the need to append <code>s.copy()</code>: doing just <code>u.append(s)</code> will
make, e.g., <code>u[0]</code> a reference to <code>s</code>, which at the end of the
loop is an array corresponding to the maximum \( i \) value.

<p>
We also need a function that can create an appropriate plot:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_sine_sum</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace
    x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">501</span>)  <span style="color: #408080; font-style: italic"># coordinates for plot</span>
    u <span style="color: #666666">=</span> sine_sum(x, N<span style="color: #666666">=10</span>)
    u_e <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>x<span style="color: #666666">*</span>(x<span style="color: #666666">-2</span>)
    N_values <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">10</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> N_values:
        plt<span style="color: #666666">.</span>plot(x, u[k])
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plt<span style="color: #666666">.</span>plot(x, u_e)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> k <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> N_values] <span style="color: #666666">+</span> [<span style="color: #BA2121">&#39;exact&#39;</span>],
               loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$x$&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$u$&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmpc.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmpc.pdf&#39;</span>)
</pre></div>
<p>
The plot shows that the solution for \( N=0 \) has a slight deviation from the
exact curve, but even \( N=1 \) catches up visually with the exact solution (!).

<p>
<center><p><img src="fig-varform/cable_sin_c.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
The functions in b) were selected such that they fulfill the
condition \( \baspsi'(1)=0 \). However, in the Galerkin method, where we
integrate by parts, the condition \( u'(1)=0 \) is incorporated in the
variational form. This leads to the idea of just choosing a simpler
basis, namely &quot;all&quot; sine functions \( \baspsi_i = \sin((i+1)\frac{\pi x}{2}) \).
Will the method adjust the coefficient such that the additional
functions compared with those in b) get vanishing coefficients? Or
will the additional basis functions improve the solution?
Use Galerkin's method.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_5" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_5">

<p>
According to the calculations in b), the Galerkin method, with
\( \baspsi_i = \sin((i+1)\frac{\pi x}{2}) \), leads to the almost the
same
matrix entries on the diagonal:

$$
\begin{align*}
A_{i,i} &= (i+1)(j+1)\frac{\pi^2}{4}\int_0^1 \cos((i+1)\frac{\pi x}{2})
\cos((j+1)\frac{\pi x}{2})dx\\ 
&= (i+1)^2\frac{\pi^2}{4}\half = \frac{1}{8}(i+1)^2 \pi^2\tp
\end{align*}
$$

The right-hand side becomes (as before)

$$ b_i = -\int_0^1 \sin((i+1)\frac{\pi x}{2})dx = -\frac{2}{\pi (i+1)}\tp$$

We may use <code>sympy</code> to integrate,

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> integrate(sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>), (x, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>))
</pre></div>
<p>
As noted in b), let us be a bit skeptical to this answer and check it.
A quick check with numerical integration,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_integral_d_sympy_answer</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">12</span>):
        exact <span style="color: #666666">=</span> <span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>))
        numerical <span style="color: #666666">=</span> midpoint_rule(
            f<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>))
        <span style="color: #008000; font-weight: bold">print</span> i, <span style="color: #008000">abs</span>(exact <span style="color: #666666">-</span> numerical)
</pre></div>
<p>
gives the output

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">0 6.54487575247e-12
1 0.31830988621
2 1.96350713466e-11
3 0.159154943092
4 3.27249061183e-11
5 0.106103295473
6 4.58150045679e-11
7 0.0795774715459
8 5.89047144395e-11
9 0.0636619773677
10 7.19949447281e-11
11 0.0530516476973
</pre></div>
<p>
It is clear that for \( i \) odd, there are significant differences between
the <code>sympy</code> answer and the midpoint rule with high resolution!

<p>
We therefore need to do hand calculations to investigate this problem
further.
The anti-derivative is very easy to realize in this case:

$$
\begin{align*}
\int_0^1\sin ((i+1)\pi x/2)dx &= -\frac{2}{\pi(i+1)}(\cos((i+1)\frac{\pi}{2}) - \cos(0))\\ 
&= \frac{2}{\pi(i+1)}(1 - \cos((i+1)\frac{\pi}{2}))\tp
\end{align*}
$$

The value of the cosine expression depends on \( i \), and the first values are

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( i=0 \)</td> <td align="center">\( i=1 \)</td> <td align="center">\( i=2 \)</td> <td align="center">\( i=3 \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0            </td> <td align="center">   -1           </td> <td align="center">   0            </td> <td align="center">   1            </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
This pattern repeats and is the same for four consecutive values of \( i \).
Hence, the integral is \( 2/(\pi (i+1)) \) for even \( i \) (\( i=2k \) for
integer \( k \), or equivalently: when \( i\mbox{ mod } 2 = 0 \)). For \( i=4k+1 \), or
equivalently: when \( (i-1)\mbox{ mod } 4 = 0 \), the
integral is \( 4/(\pi(4k+1)) \), while for \( i=4k+3 \), the integral vanishes.
This is a more complicated answer than what <code>sympy</code> provides!

<p>
We can check our new answers against numerical integration:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">check_integral_d</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">24</span>):
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            exact <span style="color: #666666">=</span> <span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>))
        <span style="color: #008000; font-weight: bold">elif</span> (i<span style="color: #666666">-1</span>) <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            exact <span style="color: #666666">=</span> <span style="color: #666666">2*2/</span>(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>))
        <span style="color: #008000; font-weight: bold">else</span>:
            exact <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        numerical <span style="color: #666666">=</span> midpoint_rule(
            f<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>))
        <span style="color: #008000; font-weight: bold">print</span> i, <span style="color: #008000">abs</span>(exact <span style="color: #666666">-</span> numerical)
</pre></div>
<p>
The output now is around \( 10^{-10} \) and we take that as a sign that
our exact results are reliable.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Carefully check symbolic computations!</b>
The example above shows how <code>sympy</code> can fail.
<a href="http://wolframalpha.com" target="_self">Wolfram Alpha</a> does a better job: writing
<code>integrate sin(k*x*pi/2) from 0 to 1</code> (use <code>k</code> instead of <code>i</code> since the latter
is the imaginary unit) returns the <a href="http://www.wolframalpha.com/input/?i=integrate+sin%28k*x*pi%2F2%29+from+0+to+1" target="_self">result</a> \( 4\sin^2(\pi k/4)/(\pi k) \),
which coincides with out result.

<p>
There are three general techniques
to verify a symbolic computation:

<ul>
 <li> Use alternative software like Wolfram Alpha for comparison</li>
 <li> Check that the result satisfies the problem to be solved</li>
 <li> Make a high-resolution numerical approximation and compare</li>
</ul>

(The second technique is not so applicable here, since we work with
a definite integral, but one could compute the indefinite integral
instead, which is done correctly by <code>sympy</code>, and discuss values for
\( x=1 \).)
</div>


<p>
The final result for \( c_i \) is now

$$ c_i = \frac{b_i}{A_{i,i}} = \left\lbrace\begin{array}{ll}
-\frac{16}{\pi^3(i+1)^3}, & i\hbox{ even, or } i \hbox{ mod } 2 = 0\\ 
-\frac{32}{\pi^3(i+1)^3}, & (i-1)\hbox{ mod } 4 = 0,\\ 
0, & (i+1)\hbox{ mod } 4 = 0
\end{array}\right.
$$

We recognize that for \( i \) even, say \( i=2k \) for integer \( k \), we
have exactly the same result as in b):

$$ -\sum_k \frac{16}{\pi^3(2k+1)^3}\sin((2k+1)x\frac{\pi x}{2}),$$

but we get an additional set of terms for \( i=4k+1 \),

$$
\begin{equation}
-\sum_k \frac{32}{\pi^3(i+1)^3}\sin((4k+1)x\frac{\pi x}{2})\tp
\tag{96}
\end{equation}
$$

<p>
We can modify the software from c) to compute the approximate \( u \)
with the present set of basis functions and coefficients:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_sum_d</span>(x, N):
    s <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin, zeros
    u <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># u[k] is the sum i=0,...,k</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:       <span style="color: #408080; font-style: italic"># even i</span>
            s <span style="color: #666666">+=</span>   <span style="color: #666666">-</span> <span style="color: #666666">16.0/</span>((i<span style="color: #666666">+1</span>)<span style="color: #666666">**3*</span>pi<span style="color: #666666">**3</span>)<span style="color: #666666">*</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)
        <span style="color: #008000; font-weight: bold">elif</span> (i<span style="color: #666666">-1</span>) <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:   <span style="color: #408080; font-style: italic"># 1, 5, 9, 13, 17</span>
            s <span style="color: #666666">+=</span> <span style="color: #666666">-</span> <span style="color: #666666">2*16.0/</span>((i<span style="color: #666666">+1</span>)<span style="color: #666666">**3*</span>pi<span style="color: #666666">**3</span>)<span style="color: #666666">*</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)
        <span style="color: #008000; font-weight: bold">else</span>:
            s <span style="color: #666666">+=</span> <span style="color: #666666">0</span>
        u<span style="color: #666666">.</span>append(s<span style="color: #666666">.</span>copy())
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_sine_sum_d</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace
    x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">501</span>)  <span style="color: #408080; font-style: italic"># coordinates for plot</span>
    u <span style="color: #666666">=</span> sine_sum_d(x, N<span style="color: #666666">=20</span>)
    u_e <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>x<span style="color: #666666">*</span>(x<span style="color: #666666">-2</span>)
    N_values <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">20</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> N_values:
        plt<span style="color: #666666">.</span>plot(x, u[k])
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plt<span style="color: #666666">.</span>plot(x, u_e)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> k <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> N_values] <span style="color: #666666">+</span> [<span style="color: #BA2121">&#39;exact&#39;</span>],
               loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$x$&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$u$&#39;</span>)
    <span style="color: #408080; font-style: italic">#plt.axis([0.9, 1, -0.52, -0.49])</span>
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmpd.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmpd.pdf&#39;</span>)
</pre></div>
<p>
The approximations for \( N=0,1,3,20 \) appear below.

<p>
<center><p><img src="fig-varform/cable_sin_d.png" align="bottom" width=500></p></center>

<p>
While the approximation for \( N=0 \) coincides with the one in b), we
see that \( N=1 \) and higher values of \( N \) lead to a clearly wrong curve.
This strange feature has to be investigated!

<p>
Let us start by plotting the basis functions for \( i=0,1,\ldots,7 \):

<p>
<center><p><img src="fig-varform/sinix_int.png" align="bottom" width=800></p></center>

<p>
We observe from the figure that all the basis functions corresponding to
even \( i \) are symmetric around \( x=1 \), which is an important property of
the solution. The functions for odd \( i \) are anti-symmetric. However,
for \( i=3,7,11,\ldots \) the basis function has an integer number of
periods on \( [0,1] \) so the integral becomes zero, \( c_i=0 \), and
consequently
there is no effect from these functions. The functions corresponding
to \( i=1,5,9,13,\ldots \) are anti-symmetric around \( x=1 \) with nonzero
coefficients. The derivative of an anti-symmetric function at the point
of anti-symmetry is unity in size. Since the derivatives of all the
basis functions corresponding to even \( i \) vanish at \( x=1 \), the
extra terms (\( i=1,5,9,13,\ldots \)) in <a href="#mjx-eqn-96">(96)</a>
have a nonzero derivative, resulting in \( u'(1)\neq 0 \). That is,
these terms destroy the solution!

<p>
But we computed \( c_i \) by a Galerkin method, which is equivalent to a
least squares method, which gives us the &quot;best&quot; approximation possible?
That is true, but it is the best approximation in the chosen space \( V \).
The problem is that we have populated (or rather polluted) the space
\( V \) with some basis functions that have a wrong mathematical property: they
are anti-symmetric around \( x=1 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>e)</b>
Now we drop the symmetry condition at \( x=1 \) and extend the domain to
\( [0,2] \) such that it covers the entire (scaled) physical cable. The
problem now reads

$$ u'' = 1,\quad x\in (0,2),\quad u(0)=u(2)=0\tp$$

This time we need basis functions that are zero at \( x=0 \) and \( x=2 \).
The set \( \sin((i+1)\frac{\pi x}{2}) \) from d) is a candidate since
they vanish \( x=2 \) for any \( i \). Compute the approximation in this case.
Why is this approximation without the problem that this set of
basis functions introduced in d)?

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_6" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_6">

<p>
The formulas are almost the same as in d), only the integration domain
is different. Since the sine functions or orthogonal on \( [0,1] \), they
are also orthogonal on \( [0,2] \). Because

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> integrate(cos((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/2</span>)<span style="color: #666666">**2</span>, (x, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>))
<span style="color: #666666">1</span>
</pre></div>
<p>
we get (in Galerkin's method)

$$
\begin{align*}
A_{i,i} &= (i+1)(j+1)\frac{\pi^2}{4}\int_0^2 \cos((i+1)\frac{\pi x}{2})
\cos((i+1)\frac{\pi x}{2})dx\\ 
& = (i+1)^2\frac{\pi^2}{4}\tp
\end{align*}
$$

and

$$ b_i = -\int_0^2 \sin((i+1)\frac{\pi x}{2})dx = \frac{2}{\pi (i+1)}(\cos((i+1)\pi) - 1)\tp$$

We have that \( \cos((i+1)\pi = -1 \) for \( i \) even and
\( \cos((i+1)\pi = 1 \) for \( i \) odd. That is,

$$ b_i =\left\lbrace\begin{array}{ll}
-\frac{4}{\pi (i+1)}, & i\hbox{ even }\\ 
0, & i\hbox{ odd }
\end{array}\right.$$

The coefficients become

$$ c_i =\frac{b_i}{A_{i,i}} =\left\lbrace\begin{array}{ll}
-\frac{16}{\pi^3(i+1)^3}, & i\hbox{ even }\\ 
0, & i\hbox{ odd }
\end{array}\right.$$

Introducing \( i=2k \) and then switching from \( k \) to \( i \) as summation index
gives \( c_i = -\frac{16}{\pi^3(2i+1)^3} \) and

$$ u(x) = -\sum_{i=0}^N \frac{16}{\pi^3(2i+1)^3}\sin((i+1)\frac{\pi x}{2}),$$

which is the same expansion as in b).

<p>
The reason why the basis functions \( \baspsi_i=\sin((i+1)\frac{\pi x}{2}) \)
work well in this case is that the problematic functions for \( i=1,5,\ldots \)
in d) now live on \( [0,2] \) instead of \( [0,1] \). On \( [0,2] \) these functions
have an integer number of periods such that the integral from 0 to 2
becomes zero. These basis functions are therefore excluded from the
expansion since their coefficients vanish.
The lesson learned is that two equivalent boundary value
problems may make different demands to the basis functions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- BIG point: use polynomials, without integration by parts we cannot -->
<!-- handle the boundary condition. -->

<p>
Filename: <code>cable_sin</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:tension:cable_xn">Exercise 3: Compute the deflection of a cable with power functions</h2>

<p>
<b>a)</b>
Repeat <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a> b), but work with
the space

$$ V = \hbox{span}\{x, x^2, x^3, x^4, \ldots\}\tp $$

Choose the dimension of \( V \) to be 4 and observe that the exact solution
is recovered by the Galerkin method.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_1">

<p>
Use the <code>solver</code> function from <code>varform1D.py</code>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_2">

<p>
The Galerkin formulation of \( u''=1 \), \( u(0)=0 \), \( u'(1)=0 \), reads

$$ (u',v') = -(1,v)\quad\forall v\in V,$$

and the linear system becomes

$$ \sum_{j=}^N (\baspsi_i', \baspsi_j')c_j = -(1,\baspsi_i),\quad i=0,1,\ldots,N\tp$$

The <code>varform1D.solver</code> function needs a function specifying the integrands
on the left- and right-hand sides of the variational formulation.
Moreover, we must compute a dictionary of \( \baspsi_i \) and \( \baspsi_i' \).
The appropriate code becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">varform1D</span> <span style="color: #008000; font-weight: bold">import</span> solver
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, b <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x b&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Compute basis functions and their derivatives</span>
N <span style="color: #666666">=</span> <span style="color: #666666">4</span>
psi <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: [x<span style="color: #666666">**</span>(i<span style="color: #666666">+1</span>) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]}
psi[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>diff(psi_i, x) <span style="color: #008000; font-weight: bold">for</span> psi_i <span style="color: #AA22FF; font-weight: bold">in</span> psi[<span style="color: #666666">0</span>]]

<span style="color: #408080; font-style: italic"># Galerkin</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">integrand_lhs</span>(psi, i, j):
    <span style="color: #008000; font-weight: bold">return</span> psi[<span style="color: #666666">1</span>][i]<span style="color: #666666">*</span>psi[<span style="color: #666666">1</span>][j]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">integrand_rhs</span>(psi, i):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>f<span style="color: #666666">*</span>psi[<span style="color: #666666">0</span>][i]

Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]

u, c <span style="color: #666666">=</span> solver(integrand_lhs, integrand_rhs, psi, Omega,
              verbose<span style="color: #666666">=</span><span style="color: #008000">True</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Galerkin solution u:&#39;</span>, sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(u))
</pre></div>
<p>
Running this code gives the output

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solution u: x*(x - 2)/2
</pre></div>
<p>
which coincides with the exact solution (\( c_3=c_4=0 \)).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
What happens if we use a least squares method for this problem with
the basis in a)?

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_3_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_3_3">

<p>
The least squares formulation leads to

$$ (R,\frac{\partial R}{\partial c_i}=0,\quad i=0,\ldots,N,$$

with

$$ R = 1 - u'' = 1 - \sum_jc_j\baspsi_j''\tp$$

We have

$$ \frac{\partial R}{\partial c_i} = \baspsi_i'',$$

leading to the equations

$$ (1 + \sum_jc_j\baspsi_j'', \baspsi_i''),\quad i=0,\ldots,N,$$

which is a linear system

$$ \sum_{j=0}^N(\baspsi_j'',\baspsi_i'') = (-1,\baspsi_i''),\quad i=0,\ldots,N\tp$$

The fundamental problem with the basis in a) is that \( \baspsi_0''=0 \), so
if power functions of \( x \) are wanted, we need to work with the basis
\( V=\hbox{span}\{x^2, x^3,\ldots\} \). If we do so, we can easily modify
the code from a),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Least squares</span>
psi <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: [x<span style="color: #666666">**</span>(i<span style="color: #666666">+2</span>) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]}
psi[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>diff(psi_i, x) <span style="color: #008000; font-weight: bold">for</span> psi_i <span style="color: #AA22FF; font-weight: bold">in</span> psi[<span style="color: #666666">0</span>]]
psi[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>diff(psi_i, x) <span style="color: #008000; font-weight: bold">for</span> psi_i <span style="color: #AA22FF; font-weight: bold">in</span> psi[<span style="color: #666666">1</span>]]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">integrand_lhs</span>(psi, i, j):
    <span style="color: #008000; font-weight: bold">return</span> psi[<span style="color: #666666">2</span>][i]<span style="color: #666666">*</span>psi[<span style="color: #666666">2</span>][j]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">integrand_rhs</span>(psi, i):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>f<span style="color: #666666">*</span>psi[<span style="color: #666666">2</span>][i]

Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]

u, c <span style="color: #666666">=</span> solver(integrand_lhs, integrand_rhs, psi, Omega,
              verbose<span style="color: #666666">=</span><span style="color: #008000">True</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;solution u:&#39;</span>, sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(u))
</pre></div>
<p>
The result is \( u=-\half x^2 \). This function does not obey \( u'(1)=0 \) and
is completely wrong. In this least squares method we cannot access the basis
function \( x \), which is needed in the exact solution, and we have no means
to obtain \( u'(1)=0 \).

<p>
<b>Remark.</b>
There is a modification of the least squares method that
can be applied here. The
problem \( u''=1 \) must be rewritten as a system of two equations,
\( u_1'=u_2 \), \( u_2' =1 \). We expand \( u_1=\sum_{j=0}^N c_j\baspsi_j \) and
\( u_2=\sum_{j=0}^N d_j\baspsi_j \). The residuals in both equations are
added, squared, and differentiated with respect to \( c_i \) and \( d_i \),
\( i=0,\ldots,N \). The result is a coupled equation system for the
\( c_i \) and \( d_i \) coefficients.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>cable_xn</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:intg:parts">Exercise 4: Check integration by parts</h2>

<p>
Consider the Galerkin method for the problem involving \( u \)
in <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>.
Show that the formulas for \( c_j \) are independent of whether we perform
integration by parts or not.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
The Galerkin method is

$$ (u'',v)=(1,v)\quad\forall v\in V,$$

and with the choice of \( V \) we get

$$
\begin{align*}
A_{i,j} &=-(i+1)^2\pi^2 \int_0^1\sin^2((i+1)\frac{\pi x}{2})dx,\\ 
b_i &= \int_0^1\sin((i+1)\frac{\pi x}{2})dx
\end{align*}
$$

From <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a> we realize that
the integrals are the same as in the least squares method, and
those results were identical to those of the Galerkin method with
integration by parts.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>cable_integr_by_parts</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:cable:2P1">Exercise 5: Compute the deflection of a cable with 2 P1 elements</h2>

<p>
Solve the problem for \( u \) in <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>
using two P1 linear elements. Incorporate the condition \( u(0)=0 \)
by two methods: 1) excluding the unknown at \( x=0 \), 2) keeping the unknown
at \( x=0 \), but modifying the linear system.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
From <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>,
the Galerkin method, after integration by parts, reads

$$ (u',v')=-(1,v)\quad\forall v\in V\tp$$

We have two elements,
\( \Omega^{(0)}=[0,\half] \) and \( \Omega^{(1)}=[\half,1] \).

<h3 id="___sec95">Method 1: Excluding the unknown at \( x=0 \) </h3>

<p>
Since \( u(0)=0 \), we exclude the value at \( x=0 \) as degree of freedom in
the linear system. (There is no need for any boundary function.)
The expansion reads \( u=c_0\basphi_1(x) + c_1\basphi_2(x) \).
The element matrix has then only one entry in the first element,

$$ \tilde A^{(0)} = \frac{1}{h}(1)\tp$$

From element 1 we get the usual element matrix

$$ \tilde A^{(1)} = \frac{1}{h}
\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right)\tp
$$

The element vector in element 0 becomes

$$ \tilde b^{(0)} = \frac{h}{2}(-1),$$

while the second element gives a contribution

$$ \tilde b^{(1)} = \frac{h}{2}
\left(\begin{array}{c}
-1 \\ 
-1
\end{array}\right)\tp
$$

Assembling the contributions gives

$$ \frac{1}{h}
\left(\begin{array}{cc}
2 & -1\\ 
-1 & 1
\end{array}\right)
\left(\begin{array}{c}
c_0 \\ 
c_1
\end{array}\right)
=
- \frac{h}{2}
\left(\begin{array}{c}
2 \\ 
1
\end{array}\right)\tp
$$

Note that \( h=\half \).
Solving this system yields

$$ c_0 = -\frac{3}{8},\quad c_1=-\half\quad\Rightarrow\quad u=-\frac{3}{8}\basphi_1(x)-\half\baspsi_2(x)\tp$$

Evaluating the exact solution for \( x=\half \) and \( x=1 \), we get \( 3/8 \)
and \( 1/2 \), respectively, a result which shows
that the numerical solution with P1 is exact at the three node points.
The difference between the numerical and exact solution is that the
numerical solution varies linearly over the two elements while the
exact solution is quadratic.

<h3 id="___sec96">Method 2: Modifying the linear system </h3>

<p>
Now we let \( c_i \) correspond to the value at node \( \xno{i} \), i.e.,
all known Dirichlet values become part of the linear system.
The expansion is now simply \( u=\sum_{i=0}^2c_i\basphi_i(x) \), with
three unknowns \( c_0 \), \( c_1 \), and \( c_2 \).
Now the element matrix in the first and second element are equal.
The same is true for the element vectors.
Assembling yields

$$ \frac{1}{h}
\left(\begin{array}{ccc}
1 & -1 & 0\\ 
-1 & 2 & -1\\ 
0 & -1 & 1
\end{array}\right)
\left(\begin{array}{c}
c_0 \\ 
c_1\\ 
c_2
\end{array}\right)
=
- \frac{h}{2}
\left(\begin{array}{c}
1\\ 
2\\ 
1
\end{array}\right)\tp
$$

The next step is to modify the linear system to implement the
Dirichlet condition \( c_0=0 \). We first multiply by \( h=\half \) and replace the
first equation by \( c_0=0 \):

$$
\left(\begin{array}{ccc}
1 & 0 & 0\\ 
-1 & 2 & -1\\ 
0 & -1 & 1
\end{array}\right)
\left(\begin{array}{c}
c_0 \\ 
c_1\\ 
c_2
\end{array}\right)
=
- \left(\begin{array}{c}
0\\ 
\frac{1}{4}\\ 
\frac{1}{8}
\end{array}\right)\tp
$$

We see that the remaining \( 2\times 2 \) system is identical to the one
previously solved, and the solution is the same.

$$ u = 0\basphi_0(x) - \frac{3}{8}\basphi_1(x) - \half\baspsi_2(x)\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>cable_2P1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:cable:1P2">Exercise 6: Compute the deflection of a cable with 1 P2 element</h2>

<p>
Solve the problem for \( u \) in <a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>
using one P2 element with quadratic basis functions.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_1">

<p>
The P2 basis functions on a reference element \( [-1,1] \) are

$$
\begin{align*}
\refphi_0(X) &= \half (X-1)X
\\ 
\refphi_1(X) &= 1 - X^2
\\ 
\refphi_2(X) &= \half (X+1)X
\end{align*}
$$

The element matrix and vector are easily calculated by some lines with
<code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
X, h <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;X h&#39;</span>)
half <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>, <span style="color: #666666">2</span>)
psi <span style="color: #666666">=</span> [half<span style="color: #666666">*</span>(X<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>X, <span style="color: #666666">1-</span>X<span style="color: #666666">**2</span>, half<span style="color: #666666">*</span>(X<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>X]
dpsi_dX <span style="color: #666666">=</span> [sym<span style="color: #666666">.</span>diff(psi[r], X) <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(psi))]

<span style="color: #408080; font-style: italic"># Element matrix</span>
<span style="color: #408080; font-style: italic"># (2/h)*dpsi_dX[r]*(2/h)*dpsi_dX[s]*h/2</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
d <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #408080; font-style: italic"># Use a numpy matrix with general objects to hold A</span>
A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty((d<span style="color: #666666">+1</span>, d<span style="color: #666666">+1</span>), dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
<span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>):
    <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>):
        integrand <span style="color: #666666">=</span> dpsi_dX[r]<span style="color: #666666">*</span>dpsi_dX[s]<span style="color: #666666">*2/</span>h
        A[r,s] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #008000; font-weight: bold">print</span> A

<span style="color: #408080; font-style: italic"># Element vector</span>
<span style="color: #408080; font-style: italic"># f*psi[r]*h/2, f=1</span>
d <span style="color: #666666">=</span> <span style="color: #666666">2</span>
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty(d<span style="color: #666666">+1</span>, dtype<span style="color: #666666">=</span><span style="color: #008000">object</span>)
<span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>):
    integrand <span style="color: #666666">=</span> <span style="color: #666666">-</span>psi[r]<span style="color: #666666">*</span>h<span style="color: #666666">/2</span>
    b[r] <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(integrand, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #008000; font-weight: bold">print</span> b
</pre></div>
<p>
The formatted element matrix and vector output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[[7/(3*h) -8/(3*h) 1/(3*h)]
 [-8/(3*h) 16/(3*h) -8/(3*h)]
 [1/(3*h) -8/(3*h) 7/(3*h)]]
[-h/6 -2*h/3 -h/6]
</pre></div>
<p>
or in mathematical notation:

$$ \tilde A^{(e)}=\frac{1}{3h}
\left(\begin{array}{ccc}
7 & -8 & 1\\ 
-8 & 16 & -8\\ 
1 & -8 & 7
\end{array}\right),\quad
\tilde b^{(e)} = - \frac{h}{6}
\left(\begin{array}{c}
1\\ 
4\\ 
1
\end{array}\right)\tp
$$

<h3 id="___sec98">Method 1: Excluding the unknown at \( x=0 \) </h3>

<p>
The expansion is \( u=c_0\basphi_1(x) + c_1\basphi_2(x) \). The element matrix
corresponding to the first element excludes contributions associated with
the unknown at the left node, i.e., we exclude row and column 0. In the
element vector, we exclude the first entry.

$$ \tilde A^{(0)}=\frac{1}{3h}
\left(\begin{array}{cc}
16 & -8\\ 
-8 & 7
\end{array}\right),\quad
\tilde b^{(e)} = - \frac{h}{6}
\left(\begin{array}{c}
4\\ 
1
\end{array}\right)\tp
$$

Now, \( h=1 \).
The solution of the linear system

$$ \frac{1}{3h}
\left(\begin{array}{cc}
16 & -8\\ 
-8 & 7
\end{array}\right)
\left(\begin{array}{c}
c_1\\ 
c_2
\end{array}\right)
=
- \frac{h}{6}
\left(\begin{array}{c}
4\\ 
1
\end{array}\right)
$$

is \( c_1=3/8 \) and \( c_2=1/2 \). As for P1 elements in <a href="#fem:deq:exer:cable:2P1">Exercise 5: Compute the deflection of a cable with 2 P1 elements</a>, the values at the nodes are exact, but
this time the variation between the nodes is quadratic, i.e., exact.
One P2 element produces the complete, exact solution.

<h3 id="___sec99">Method 2: Modifying the linear system </h3>

<p>
This time the expansion reads \( u=\sum_{i=0}^2 c_i\basphi_i(x) \) with
three unknowns \( c_0 \), \( c_1 \), and \( c_2 \). The linear system consists
of the complete \( 3\times 3 \) element matrix and the corresponding
element vector:

$$ \frac{1}{3h}
\left(\begin{array}{ccc}
7 & -8 & 1\\ 
-8 & 16 & -8\\ 
1 & -8 & 7
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1\\ 
c_2
\end{array}\right)
=
- \frac{h}{6}
\left(\begin{array}{c}
1\\ 
4\\ 
1
\end{array}\right)\tp
$$

The boundary condition is incorporated by replacing the first equation
by \( c_0=0 \), but prior to taking that action, we multiply by \( 3h \) and
insert \( h=1 \).

$$
\left(\begin{array}{ccc}
1 & 0 & 0   \\ 
-8 & 16 & -8\\ 
1 & -8 & 7
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1\\ 
c_2
\end{array}\right)
=
\left(\begin{array}{c}
0\\ 
- 2\\ 
- \half
\end{array}\right)\tp
$$

Realizing that \( c_0=0 \), which means we can remove the first column of
the system, shows that the equations are the same as above and hence
that the solution is identical.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>cable_1P2</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:cable:stepload">Exercise 7: Compute the deflection of a cable with a step load</h2>

<p>
We consider the deflection of a tension cable as described in
<a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>: \( w''=\ell \), \( w(0)=w(L)=0 \).
Now the load is discontinuous:

$$ \ell (x) =\left\lbrace\begin{array}{ll}
\ell_1, & x < L/2,\\ 
\ell_2, & x \geq L/2
\end{array}\right.\quad x\in [0,L]
\tp
$$

This load is not symmetric
with respect to the midpoint \( x=L/2 \) so the solution loses its symmetry.
Scaling the problem by introducing

$$ \bar x = \frac{x}{L/2},\quad u = \frac{w}{w_c},\quad\bar\ell = \frac{\ell - \ell_1}{\ell_2 - \ell_1}\tp$$

This leads to a scaled problem on \( [0,2] \) (we rename \( \bar x \) as \( x \)
for convenience):

$$ u'' = \bar\ell(x) = \left\lbrace\begin{array}{ll}
1, & x < 1,\\ 
0, & x \geq 1
\end{array}\right.
\quad x\in (0,1),\quad u(0)=0,\ u(2)=0
\tp $$

<p>
<b>a)</b>
Find the analytical solution of the problem.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_1">

<p>
Integrate the equation separately for \( x < 1 \) and \( x>1 \). Use
the conditions that \( u \) and \( u' \) must be continuous at \( x=1 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_2">

<p>
For \( x < 1 \) we get \( u_1(x) = C_1x + C_2 \), and the boundary condition
\( u_1(0)=0 \) implies \( C_2=0 \). For \( x>1 \) we get \( u_2(x)=\half x^2 + C_3x + C_4 \).
Continuity of \( u'(1) \) leads to

$$ C_1 = 1 + C_3,$$

and continuity of \( u(1) \) means

$$  C_1 = \half + C_3 + C_4,$$

while the condition \( u_2(2)=0 \) gives the third equation we need:

$$ 2 + 2C_3 + C_4 = 0\tp$$

We use <code>sympy</code> to solve them:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> symbols, Rational, solve
<span style="color: #666666">&gt;&gt;&gt;</span> C1, C3, C4 <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;C1 C3 C4&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> solve([C1 <span style="color: #666666">-</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> C3,
           C1 <span style="color: #666666">-</span> Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>) <span style="color: #666666">-</span> C3 <span style="color: #666666">-</span> C4,
	   <span style="color: #666666">2</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>C3 <span style="color: #666666">+</span> C4], [C1,C3,C4])
{C1: <span style="color: #666666">-1/4</span>, C4: <span style="color: #666666">1/2</span>, C3: <span style="color: #666666">-5/4</span>}
</pre></div>
<p>
Then

$$ u(x) = \left\lbrace\begin{array}{ll}
-\frac{1}{4}x, & x\leq 1,\\ 
\half x^2 - \frac{5}{4}x + \half, & x\geq 1
\end{array}\right.
$$

<p>
<center><p><img src="fig-varform/cable_discont_load_u_exact.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Use \( \baspsi_i = \sin((i+1)\frac{\pi x}{2}) \),
\( i=0,\ldots,N \) and the Galerkin method to find an approximate
solution \( u=\sum_j c_j\baspsi_j \).
Plot how fast the coefficients \( c_j \) tend to zero (on a log scale).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_3">

<p>
The Galerkin formulation of the problem becomes

$$ (u',v') = -(\bar\ell, v) = \left\lbrace\begin{array}{ll}
0, & x\leq 1,\\ 
-(1,v), & x\geq 1
\end{array}\right.\quad\forall v\in V\tp$$

A requirement is that \( v(0)=v(2)=0 \) because of the boundary conditions
on \( u \). The chosen basis functions
fulfill this requirement for any integer \( i \). Inserting
\( u=\sum_{j=0}^N c_j\baspsi_j \) and \( v=\baspsi_i \), \( i=0,\ldots,N \),
gives as usual the linear system \( \sum_j A_{i,j}c_j = b_i \), \( i=0,\ldots,N \),
where

$$
A_{i,j} = (i+1)(j+1)\frac{\pi^2}{4}\int_0^2 \cos((i+1)\frac{\pi x}{2})
\cos((j+1)\frac{\pi x}{2})dx\tp$$

The cosine functions are orthogonal on \( [0,2] \) so \( A_{i,j}=0 \) for
\( i\neq j \), while \( A_{i,i} \) is computed (e.g., by <code>sympy</code>) as in
<a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>, part e. The result is

$$ A_{i,i} = (i+1)^2\frac{\pi^2}{4}\tp$$

The right-hand side is

$$ b_i =
-\int_1^2 \sin((i+1)\frac{\pi x}{2})dx
= \frac{2}{\pi (i+1)}(\cos((i+1)\pi) - \cos((i+1)\pi/2))\tp$$

(Trying to do the integral in <code>sympy</code> gives a complicated expression that
needs discussion - it
is easier to do all calculations by hand.)
We have that \( \cos((i+1)\pi = -1 \) for \( i \) even and
\( \cos((i+1)\pi = 1 \) for \( i \) odd, while \( \cos((i+1)\pi/2) \) is
discussed in
<a href="#fem:deq:exer:tension:cable">Exercise 2: Compute the deflection of a cable with sine functions</a>, part d. The values
of \( \cos((i+1)\pi) - \cos((i+1)\pi/2) \) can be summarized in the following
table:

<p>

<div class="row">
  <div class="col-xs-12">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( i\hbox{ mod } 4 = 0 \)</td> <td align="center">\( (i-1)\hbox{ mod } 4 = 0 \)</td> <td align="center">\( (i-2)\hbox{ mod } 4 = 0 \)</td> <td align="center">\( (i-3)\hbox{ mod } 4 = 0 \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( -1 -0 \)                  </td> <td align="center">   \( 1 - (-1) \)                   </td> <td align="center">   \( -1 - 0 \)                     </td> <td align="center">   \( 1-1 \)                        </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-12 -->
<p>
The following function computes the approximate solution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sine_solution</span>(x, N):
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    s <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># u[i] is the solution for N=i</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            cos_min_cos <span style="color: #666666">=</span> <span style="color: #666666">-1</span>
        <span style="color: #008000; font-weight: bold">elif</span> (i<span style="color: #666666">-1</span>) <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            cos_min_cos <span style="color: #666666">=</span> <span style="color: #666666">2</span>
        <span style="color: #008000; font-weight: bold">elif</span> (i<span style="color: #666666">-2</span>) <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            cos_min_cos <span style="color: #666666">=</span> <span style="color: #666666">-1</span>
        <span style="color: #008000; font-weight: bold">elif</span> (i<span style="color: #666666">-1</span>) <span style="color: #666666">%</span> <span style="color: #666666">4</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            cos_min_cos <span style="color: #666666">=</span> <span style="color: #666666">0</span>

        b_i <span style="color: #666666">=</span> <span style="color: #666666">2/</span>(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>))<span style="color: #666666">*</span>cos_min_cos
        A_ii <span style="color: #666666">=</span> (i<span style="color: #666666">+1</span>)<span style="color: #666666">**2*</span>pi<span style="color: #666666">**2/4</span>
        c_i <span style="color: #666666">=</span> b_i<span style="color: #666666">/</span>A_ii
        s <span style="color: #666666">+=</span> c_i<span style="color: #666666">*</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x<span style="color: #666666">*</span>pi<span style="color: #666666">/2</span>)
        u<span style="color: #666666">.</span>append(s<span style="color: #666666">.</span>copy())
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
The exact solution is a function defined in a piecewise way. Below we make an implementation that works both for array and scalar arguments:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_solution</span>(x):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(x, np<span style="color: #666666">.</span>ndarray):
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span>, <span style="color: #666666">-1./4*</span>x, <span style="color: #666666">0.5*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">5./4*</span>x <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-1./4*</span>x <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">0.5*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">5./4*</span>x <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>
</pre></div>
<p>
Now we can make a plot of the exact solution and approximate solutions for
various \( N \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_sine_solution</span>():
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">101</span>)
    u <span style="color: #666666">=</span> sine_solution(x, N<span style="color: #666666">=20</span>)
    plt<span style="color: #666666">.</span>figure()
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">101</span>)
    plt<span style="color: #666666">.</span>plot(x, exact_solution(x), <span style="color: #BA2121">&#39;--&#39;</span>)
    N_values <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">5</span>
    <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">5</span>, <span style="color: #666666">10</span>:
        plt<span style="color: #666666">.</span>plot(x, u[N])
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;exact&#39;</span>] <span style="color: #666666">+</span> [<span style="color: #BA2121">&#39;N=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> N <span style="color: #008000; font-weight: bold">for</span> N <span style="color: #AA22FF; font-weight: bold">in</span> N_values])
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)
</pre></div>
<p>
<center><p><img src="fig-varform/cable_discont_load_sines.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Solve the problem with P1 finite elements.
Plot the solution for \( N_e=2,4,8 \) elements.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_4">

<p>
The element matrices and vectors are as for the well-known model
problem \( u''=1 \), except that the element vectors vanish for all
elements in \( [0,1] \). The following function defines a uniform mesh
of P1 elements and runs a finite element algorithm where we use
ready-made/known formulas for the element matrix and vector:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">P1_solution</span>():
    plt<span style="color: #666666">.</span>figure()
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe1D</span> <span style="color: #008000; font-weight: bold">import</span> mesh_uniform, u_glob
    N_e_values <span style="color: #666666">=</span> [<span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">8</span>]
    d <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    legends <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> N_e <span style="color: #AA22FF; font-weight: bold">in</span> N_e_values:
        vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(
            N_e<span style="color: #666666">=</span>N_e, d<span style="color: #666666">=</span>d, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">2</span>], symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        h <span style="color: #666666">=</span> vertices[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> vertices[<span style="color: #666666">0</span>]
        Ae <span style="color: #666666">=</span> <span style="color: #666666">1./</span>h<span style="color: #666666">*</span>np<span style="color: #666666">.</span>array(
            [[<span style="color: #666666">1</span>, <span style="color: #666666">-1</span>],
             [<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>]])
        N <span style="color: #666666">=</span> N_e <span style="color: #666666">+</span> <span style="color: #666666">1</span>
        A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N, N))
        b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
        <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e):
            <span style="color: #008000; font-weight: bold">if</span> vertices[e] <span style="color: #666666">&gt;=</span> <span style="color: #666666">1</span>:
                be <span style="color: #666666">=</span> <span style="color: #666666">-</span>h<span style="color: #666666">/2.*</span>np<span style="color: #666666">.</span>array(
                    [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>])
            <span style="color: #008000; font-weight: bold">else</span>:
                be <span style="color: #666666">=</span> h<span style="color: #666666">/2.*</span>np<span style="color: #666666">.</span>array(
                    [<span style="color: #666666">0</span>, <span style="color: #666666">0</span>])
            <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>):
                <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>):
                    A[dof_map[e][r], dof_map[e][s]] <span style="color: #666666">+=</span> Ae[r,s]
                b[dof_map[e][r]] <span style="color: #666666">+=</span> be[r]
        <span style="color: #408080; font-style: italic"># Enforce boundary conditions</span>
        A[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>; A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>; b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        A[<span style="color: #666666">-1</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>; A[<span style="color: #666666">-1</span>,<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>; b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

        <span style="color: #408080; font-style: italic"># Plot solution</span>
        xc, u, nodes <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map)
        plt<span style="color: #666666">.</span>plot(xc, u)
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;$N_e=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">$&#39;</span> <span style="color: #666666">%</span> N_e)
    plt<span style="color: #666666">.</span>plot(xc, exact_solution(xc), <span style="color: #BA2121">&#39;--&#39;</span>)
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;exact&#39;</span>)
    plt<span style="color: #666666">.</span>legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower left&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)
</pre></div>
<p>
<center><p><img src="fig-varform/cable_discont_load_P1.png" align="bottom" width=500></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>cable_discont_load</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:1D:mesh:nonuniform">Exercise 8: Compute with a non-uniform mesh</h2>

<p>
<b>a)</b>
Derive the linear system for the problem \( -u''=2 \) on \( [0,1] \), with
\( u(0)=0 \) and \( u(1)=1 \), using P1 elements and a <em>non-uniform</em> mesh. The
vertices have coordinates \( \xno{0}=0 < \xno{1} < \cdots < 
\xno{N_n-1}=1 \), and the length of cell number \( e \) is \( h_e = \xno{e+1}
-\xno{e} \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_1">

<p>
The element matrix and vector for this problem is given by
<a href="._varform-sol003.html#mjx-eqn-61">(61)</a>. The change in this exercise is that
\( h \) is not a constant element length, but varying with the element
number \( e \). We therefore write

$$
\tilde A^{(e)} =\frac{1}{h_e}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h_e\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\tp
$$

Assembling such element matrices yields

$$
\left(
\begin{array}{ccccccccc}
h_0^{-1} & -h_0^{-1} & 0 &\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
-h_0^{-1} & h_0^{-1}+h_1^{-1} & -h_1^{-1} & \ddots &   & &  & &  \vdots \\ 
0 & -h_1^{-1} & h_1^{-1} + h_2^{-1} & -h_2^{-1} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -h_{i-1}^{-1} & h_{i-1}^{-1} + h_i^{-1} & -h_i^{-1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -h_{N_e}^{-1} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -h_{N_e}^{-1} & h_{N_e}^{-1}
\end{array}
\right)
$$

The element vectors assemble to

$$
\left(
\begin{array}{c}
h_0 \\ 
h_0 + h_1\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
h_{i-1} + h_i\\ 
\vdots \\ 
\vdots\\ 
h_{N_e}
\end{array}
\right)
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
It is of interest to compare the discrete equations for the finite
element method in a non-uniform mesh with the corresponding discrete
equations arising from a finite difference method. Go through the
derivation of the finite difference formula \( u''(x_i) \approx [D_x D_x
u]_i \) and modify it to find a natural discretization of \( u''(x_i) \) on
a non-uniform mesh. Compare the finite element and difference
discretizations

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_2">

<p>
Using the definition of the centered, 2nd-order finite difference approximation
to \( u'' \) we can set up

$$ [D_xD_x u]_i = [D_x(D_x u)]_i = \frac{\frac{u_{i+1}-u_i}{x_{i+1}-x_i} -
\frac{u_{i}-u_{i-1}}{x_{i}-x_{i-1}}}{x_{i+1/2} - x_{i-1/2}}\tp$$

Now,

$$ x_{i+1/2} - x_{i-1/2} = \half (x_i - x_{i-1}) + \half(x_{i+1}-x_i) = \half(x_{i+1}-x_{i-1})\tp$$

We then get the difference equation

$$ u''(x_i)\approx \frac{2}{h_i + h_{i-1}}\left(
\frac{u_{i+1}-u_i}{h_{i}} - \frac{u_{i}-u_{i-1}}{h_{i-1}}\right) = 2\tp$$

The factor 2 on either side cancels.

<p>
Looking at the finite element equations in a), the equation for a general
row \( i \) reads

$$ -\frac{1}{h_{i-1}}c_{i-1} + (\frac{1}{h_{i-1}} - \frac{1}{h_{i}})c_i
+ \frac{1}{h_{i}}c_{i+1} = h_{i-1} + h_i\tp$$

Replacing \( c_i \) by \( u_i \) (assuming we keep unknowns at all nodes) and
rearranging gives

$$ \frac{1}{h_{i-1}}(u_i - u_{i-1}) - \frac{1}{h_{i}}(u_{i+1}-u_i)
 = h_{i-1} + h_i\tp$$

Dividing by the right-hand side gives

$$ \frac{1}{h_{i-1} + h_i}\left(\frac{1}{h_{i-1}}(u_i - u_{i-1}) - \frac{1}{h_{i}}(u_{i+1}-u_i)\right) = 1\tp$$

This is the same difference equation as we have in the finite difference
method.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>nonuniform_P1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:1D:gen:problem1">Problem 9: Solve a 1D finite element problem by hand</h2>

<p>
The following scaled 1D problem is a very simple, yet relevant, model
for convective transport in fluids:

$$
\begin{equation}
u' = \epsilon u'' ,\quad u(0)=0,\ u(1)=1,\ x\in [0,1]
\tp
\tag{97}
\end{equation}
$$

<p>
<b>a)</b>
Find the analytical solution to this problem.
(Introduce \( w=u' \), solve the first-order differential equation for \( w(x) \),
and integrate once more.)

<p>
<b>b)</b>
Derive the variational form of this problem.

<p>
<b>c)</b>
Introduce a finite element mesh with uniform partitioning.
Use P1 elements and compute the element matrix and vector for
a general element.

<p>
<b>d)</b>
Incorporate the boundary conditions and
assemble the element contributions.

<p>
<b>e)</b>
Identify the resulting linear system as a finite difference discretization
of the differential equation using

$$ [D_{2x}u = \epsilon D_xD_x u]_i \tp  $$

<p>
<b>f)</b>
Compute the numerical solution and plot it together with the exact solution
for a mesh with 20 elements and
\( \epsilon=10, 1, 0.1, 0.01 \).

<p>
Filename: <code>convdiff1D_P1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:1D:exact_numerics">Exercise 10: Investigate exact finite element solutions</h2>

<p>
Consider

$$ -u''(x)=x^m,\quad x\in (0,L),\quad u'(0)=C,\ u(L)=D,$$

where \( m\geq 0 \) is an integer, and \( L \), \( C \), and \( D \) are given numbers.
Utilize a mesh with two (non-uniform) elements: \( \Omega^{(0)}=[0,3] \) and
\( \Omega^{(0)}=[3,4] \).
Plot the exact solution and the finite element solution for
\( d=1,2,3,4 \) and \( m=0, 1, 2, 3, 4 \). Find values of \( d \) and \( m \)
that make the finite element solution exact at the nodes in the mesh.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_1">

<p>
Use the <code>mesh_uniform</code>, <code>finite_element1D</code>, and <code>u_glob2</code> functions
from the <code>fe1D.py</code> module.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_2">

<p>
The <code>model2</code> function from the section <a href="._varform-sol001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>
can find the exact solution by <code>model2(x**m, L, C, D)</code>.
We fix, for simplicity, the values of \( L \), \( C \), and \( D \) as
\( L=4 \), \( C=5 \), and \( D=2 \).
After calculating a symbolic solution, we can convert the expression
to a Python function with <code>sympy.lambdify</code>.
For each \( d \) value we then create a uniform mesh and displace the
vertex with number 1 to the value 3.
The various functions for specifying the element matrix and vector
entries are as given in the section <a href="._varform-sol006.html#fem:deq:1D:code:fe_sparse">Utilizing a sparse matrix</a>,
since the model problem is the same. Our code then becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">u_xx_f_sympy</span> <span style="color: #008000; font-weight: bold">import</span> model2, x
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe1D</span> <span style="color: #008000; font-weight: bold">import</span> finite_element1D, mesh_uniform, u_glob
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

C <span style="color: #666666">=</span> <span style="color: #666666">5</span>
D <span style="color: #666666">=</span> <span style="color: #666666">2</span>
L <span style="color: #666666">=</span> <span style="color: #666666">4</span>

m_values <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]
d_values <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]
<span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> m_values:
    u <span style="color: #666666">=</span> model2(x<span style="color: #666666">**</span>m, L, C, D)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">m=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, u: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (m, u)
    u_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], u)

    <span style="color: #008000; font-weight: bold">for</span> d <span style="color: #AA22FF; font-weight: bold">in</span> d_values:
        vertices, cells, dof_map <span style="color: #666666">=</span> mesh_uniform(
            N_e<span style="color: #666666">=2</span>, d<span style="color: #666666">=</span>d, Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,L], symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        vertices[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #408080; font-style: italic"># displace vertex</span>
        essbc <span style="color: #666666">=</span> {}
        essbc[dof_map[<span style="color: #666666">-1</span>][<span style="color: #666666">-1</span>]] <span style="color: #666666">=</span> D

        c, A, b, timing <span style="color: #666666">=</span> finite_element1D(
            vertices, cells, dof_map,
            essbc,
            ilhs<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> e, phi, r, s, X, x, h:
            phi[<span style="color: #666666">1</span>][r](X, h)<span style="color: #666666">*</span>phi[<span style="color: #666666">1</span>][s](X, h),
            irhs<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> e, phi, r, X, x, h:
            x<span style="color: #666666">**</span>m<span style="color: #666666">*</span>phi[<span style="color: #666666">0</span>][r](X),
            blhs<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> e, phi, r, s, X, x, h: <span style="color: #666666">0</span>,
            brhs<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> e, phi, r, X, x, h:
            <span style="color: #666666">-</span>C<span style="color: #666666">*</span>phi[<span style="color: #666666">0</span>][r](<span style="color: #666666">-1</span>) <span style="color: #008000; font-weight: bold">if</span> e <span style="color: #666666">==</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">0</span>,
            intrule<span style="color: #666666">=</span><span style="color: #BA2121">&#39;GaussLegendre&#39;</span>)

        <span style="color: #408080; font-style: italic"># Visualize</span>
        <span style="color: #408080; font-style: italic"># (Recall that x is a symbol, use xc for coordinates)</span>
        xc, u, nodes <span style="color: #666666">=</span> u_glob(c, vertices, cells, dof_map)
        u_e <span style="color: #666666">=</span> u_exact(xc)
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Max diff at nodes, d=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">:&#39;</span> <span style="color: #666666">%</span> d, \ 
              np<span style="color: #666666">.</span>abs(u_exact(nodes) <span style="color: #666666">-</span> c)<span style="color: #666666">.</span>max()
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(xc, u, <span style="color: #BA2121">&#39;b-&#39;</span>, xc, u_e, <span style="color: #BA2121">&#39;r--&#39;</span>)
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;finite elements, d=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span>d, <span style="color: #BA2121">&#39;exact&#39;</span>],
                   loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower left&#39;</span>)
        figname <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (m, d)
        plt<span style="color: #666666">.</span>savefig(figname <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(figname <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pdf&#39;</span>)
</pre></div>
<p>
First we look at the numerical solution at the nodes:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m=0, u: -x**2/2 + 5*x - 10
Max diff at nodes, d=1: 2.22044604925e-16
Max diff at nodes, d=2: 3.5527136788e-15
Max diff at nodes, d=3: 1.7763568394e-15
Max diff at nodes, d=4: 2.46913600677e-13

m=1, u: -x**3/6 + 5*x - 22/3
Max diff at nodes, d=1: 8.881784197e-16
Max diff at nodes, d=2: 1.7763568394e-15
Max diff at nodes, d=3: 7.9936057773e-15
Max diff at nodes, d=4: 3.01092484278e-13

m=2, u: -x**4/12 + 5*x + 10/3
Max diff at nodes, d=1: 3.10862446895e-15
Max diff at nodes, d=2: 0.084375
Max diff at nodes, d=3: 0.0333333333333
Max diff at nodes, d=4: 5.20472553944e-13

m=3, u: -x**5/20 + 5*x + 166/5
Max diff at nodes, d=1: 1.35555555556
Max diff at nodes, d=2: 0.3796875
Max diff at nodes, d=3: 0.185714285714
Max diff at nodes, d=4: 0.0254255022334

m=4, u: -x**6/30 + 5*x + 1778/15
Max diff at nodes, d=1: 4.8
Max diff at nodes, d=2: 1.4428125
Max diff at nodes, d=3: 0.719047619047
Max diff at nodes, d=4: 0.16865583147
</pre></div>
<p>
We observe that all elements are capable of computing the exact values
at the nodes for \( m=0 \) and \( m=1 \). With \( m=0 \), the solution is quadratic
in \( x \), and P2, P3, and P4 will be exact. It is more of a surprise that
also the P1 elements are exact in this case.
A peculiar feature is that P1
elements are also exact at the nodes \( m=2 \), but not P2 and P3 elements
(the solution goes like \( x^4 \) so it is not surprising that P2 and P3
elements give a numerical error also at the nodes).
Clearly, P4 elements produce the exact solution for \( m=4 \) since \( u \)
is a polynomial of degree 4. For larger \( m \) values we have
discrepancy between the numerical and exact values at the nodes.

<h3 id="___sec104">Plots for m=0 </h3>

<p>
<center><p><img src="fig-varform/u_xx_xm0_P1to4.png" align="bottom" width=800></p></center>

<h3 id="___sec105">Plots for m=1 </h3>

<p>
<center><p><img src="fig-varform/u_xx_xm1_P1to4.png" align="bottom" width=800></p></center>

<h3 id="___sec106">Plots for m=2 </h3>

<p>
<center><p><img src="fig-varform/u_xx_xm2_P1to4.png" align="bottom" width=800></p></center>

<h3 id="___sec107">Plots for m=3 </h3>

<p>
<center><p><img src="fig-varform/u_xx_xm3_P1to4.png" align="bottom" width=800></p></center>

<h3 id="___sec108">Plots for m=4 </h3>

<p>
<center><p><img src="fig-varform/u_xx_xm4_P1to4.png" align="bottom" width=800></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>u_xx_xm_P1to4</code>.

<p>
<!-- Could have shooting method as a project -->
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:1D:Poisson:polar">Exercise 11: Compare finite elements and differences for a radially symmetric Poisson equation</h2>

<p>
We consider the Poisson problem in a disk with radius \( R \) with
Dirichlet conditions at the boundary.
Given that the solution is radially symmetric and hence dependent only on
the radial coordinate (\( r=\sqrt{x^2+y^2} \)), we can reduce the problem
to a 1D Poisson equation

$$
\begin{equation}
-\frac{1}{r}\frac{d}{dr}\left( r\frac{du}{dr}\right) = f(r),\quad r\in (0,R),\ 
u'(0)=0,\ u(R)=U_R
\tp
\tag{98}
\end{equation}
$$

<p>
<b>a)</b>
Derive a variational form of <a href="#mjx-eqn-98">(98)</a>
by integrating over the whole disk, or posed equivalently: use
a weighting function \( 2\pi r v(r) \) and integrate \( r \) from \( 0 \) to \( R \).

<p>
<b>b)</b>
Use a uniform mesh partition with P1 elements and show what the
resulting set of equations becomes. Integrate the matrix entries
exact by hand, but use a Trapezoidal rule to integrate the \( f \) term.

<p>
<b>c)</b>
Explain that an intuitive
finite difference method applied to <a href="#mjx-eqn-98">(98)</a>
gives

$$
\frac{1}{r_i}\frac{1}{h^2}\left( r_{i+\half}(u_{i+1}-u_i) -
r_{i-\half}(u_{i}-u_{i-1})\right) = f_i,\quad i=rh
\tp
$$

<p>
For \( i=0 \) the factor \( 1/r_i \) seemingly becomes problematic. One must always
have \( u'(0)=0 \), because of the radial symmetry, which implies
\( u_{-1}=u_1 \), if we allow introduction of a fictitious value \( u_{-1} \).
Using this \( u_{-1} \) in the difference equation for \( i=0 \) gives

$$
\begin{align*}
&\frac{1}{r_0}\frac{1}{h^2}\left( r_{\half}(u_{1}-u_0) -
r_{-\half}(u_{0}-u_{1})\right) = \\ 
& \qquad
\frac{1}{r_0}\frac{1}{2h^2}\left( (r_0 + r_1)(u_{1}-u_0) -
(r_{-1} + r_0)(u_{0}-u_{1})\right) \approx
2(u_1-u_0),
\end{align*}
$$

if we use \( r_{-1}+r_1\approx 2r_0 \).

<p>
Set up the complete set of equations for the finite difference method
and compare to the finite element method in case a Trapezoidal rule
is used to integrate the \( f \) term in the latter method.

<p>
Filename: <code>radial_Poisson1D_P1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:1D:gen:problem2">Exercise 12: Compute with variable coefficients and P1 elements by hand</h2>

<p>
Consider the problem
$$
\begin{equation}
-\frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) + \gamma u = f(x),
\quad x\in\Omega=[0,L],\quad u(0)=\dfc,\ u'(L)=\beta\tp
\tag{99}
\end{equation}
$$

We choose \( \dfc(x)=1+x^2 \). Then
$$
\begin{equation} u(x) = \dfc + \beta(1+L^2)\tan^{-1}(x),
\tag{100}
\end{equation}
$$

is an exact solution if \( f(x) = \gamma u \).

<p>
Derive a variational formulation and compute general expressions for the
element matrix and vector in an arbitrary element, using P1 elements
and a uniform partitioning of \( [0,L] \). The right-hand side
integral is challenging and can be computed by a numerical integration
rule. The Trapezoidal rule \eqref{fem:approx:fe:numint1:trapez}
gives particularly simple expressions.
Filename: <code>atan1D_P1</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:deq:exer:2D:torsion:xy:sin">Exercise 13: Solve a 2D Poisson equation using polynomials and sines</h2>

<p>
The classical problem of applying a torque to the ends of a rod
can be modeled by a Poisson equation defined in the cross section \( \Omega \):

$$ -\nabla^2 u = 2,\quad (x,y)\in\Omega,$$

with \( u=0 \) on \( \partial\Omega \). Exactly the same problem arises for
the deflection of a membrane with shape \( \Omega \) under a constant load.

<p>
For a circular cross section one can readily
find an analytical solution. For a rectangular cross section the analytical
approach ends up with a sine series. The idea in this exercise is to
use a single basis function to obtain an approximate answer.

<p>
We assume for simplicity that the cross section is the unit square:
\( \Omega = [0,1]\times [0,1] \).

<p>
<b>a)</b>
We consider the basis
\( \baspsi_{p,q}(x,y) = \sin((p+1)\pi x)\sin (q\pi y) \), \( p,q=0,\ldots,n \).
These basis functions fulfill the Dirichlet condition.
Use a Galerkin method and \( n=0 \).

<p>
<b>b)</b>
The basis function involving sine functions are orthogonal.
Use this property in the Galerkin method
to derive the coefficients \( c_{p,q} \) in a
formula \( u=\sum_p\sum_q c_{p,q}\baspsi_{p,q}(x,y) \).

<p>
<b>c)</b>
Another possible basis is
\( \baspsi_i(x,y) = (x(1-x)y(1-y))^{i+1} \), \( i=0,\ldots,N \).
Use the Galerkin method to compute the solution for \( N=0 \).
Which choice of a single basis function is best,
\( u\sim x(1-x)y(1-y) \) or \( u\sim \sin(\pi x)\sin(\pi y) \)?
In order to answer the question,
it is necessary to search the web or the literature for an accurate
estimate of the maximum \( u \) value at \( x=y=1/2 \).

<p>
Filename: <code>torsion_sin_xy</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._varform-sol008.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._varform-sol010.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

