<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Stationary variational forms">
<meta name="keywords" content="residual,weighted residuals,method of weighted residuals,variational formulation,weak formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition">

<title>Stationary variational forms</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Basic principles for approximating differential equations',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              ('Differential equation models',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              ('Simple model problems and their solutions',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              ('Forming the residual',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              ('The least squares method', 2, None, '___sec4'),
              ('The Galerkin method', 2, None, '___sec5'),
              ('The Method of Weighted Residuals', 2, None, '___sec6'),
              ('Test and Trial Functions', 2, None, '___sec7'),
              ('The collocation method', 2, None, '___sec8'),
              ('The subdomain collocation method', 3, None, '___sec9'),
              ('Examples on using the principles',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              ('The model problem', 3, None, '___sec11'),
              ('Basis functions', 3, None, '___sec12'),
              ('The residual', 3, None, '___sec13'),
              ('The least squares method', 3, None, '___sec14'),
              ('The Galerkin method', 3, None, '___sec15'),
              ('The collocation method', 3, None, '___sec16'),
              ('Comparison', 3, None, '___sec17'),
              ('Integration by parts',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              ('Weak form', 3, None, '___sec19'),
              ('Boundary function',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              ('Abstract notation for variational formulations',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              ('Variational problems and minimization of functionals',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              ('Example', 3, None, '___sec23'),
              ('The general minimization problem', 3, None, '___sec24'),
              ('Derivation', 3, None, '___sec25'),
              ('Minimization of the discretized functional',
               3,
               None,
               '___sec26'),
              ('Calculus of variations', 3, None, '___sec27'),
              ('Examples on variational formulations',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              ('Variable coefficient', 2, None, '___sec29'),
              ('First-order derivative in the equation and boundary condition',
               2,
               None,
               '___sec30'),
              ('Nonlinear coefficient', 2, None, '___sec31'),
              ('Computing with Dirichlet and Neumann conditions',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              ('When the numerical method is exact', 2, None, '___sec33'),
              ('Computing with finite elements',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              ('Finite element mesh and basis functions',
               2,
               None,
               '___sec35'),
              ('Computation in the global physical domain',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              ('Comparison with a finite difference discretization',
               2,
               'fem:deq:1D:fdm_vs_fem',
               'fem:deq:1D:fdm_vs_fem'),
              ('Cellwise computations',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              ('The integral for the element matrix', 3, None, '___sec39'),
              ('The integral for the element vector', 3, None, '___sec40'),
              ('Detailed calculations of the element matrix and vector',
               3,
               None,
               '___sec41'),
              ('Contributions from the first and last cell',
               3,
               None,
               '___sec42'),
              ('Assembly', 3, None, '___sec43'),
              ('Boundary conditions: specified nonzero value',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              ('General construction of a boundary function',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              ('Example on computing with a finite element-based boundary function',
               2,
               None,
               '___sec46'),
              ('Computations in physical coordinates', 3, None, '___sec47'),
              ('Cellwise computations on the reference element',
               3,
               None,
               '___sec48'),
              ('Modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              ('Computations in the physical system', 3, None, '___sec50'),
              ('Symmetric modification of the linear system',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              ('Modification of the element matrix and vector',
               2,
               None,
               '___sec52'),
              ('Boundary conditions: specified derivative',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              ('The variational formulation', 2, None, '___sec54'),
              ('Boundary term vanishes because of the test functions',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              ('Boundary term vanishes because of linear system modifications',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              ('Direct computation of the global linear system',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              ('Cellwise computations', 2, None, '___sec58'),
              ('Implementation', 1, 'fem:deq:1D:code', 'fem:deq:1D:code'),
              ('Global basis functions',
               2,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              ('Example: constant right-hand side', 2, None, '___sec61'),
              ('Finite elements',
               2,
               'fem:deq:1D:code:fe',
               'fem:deq:1D:code:fe'),
              ('Utilizing a sparse matrix',
               2,
               'fem:deq:1D:code:fe_sparse',
               'fem:deq:1D:code:fe_sparse'),
              ('Example', 3, None, '___sec64'),
              ('Variational formulations in 2D and 3D',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              ('Integration by parts', 2, None, '___sec66'),
              ('Example on a multi-dimensional variational problem',
               2,
               None,
               '___sec67'),
              ('Transformation to a reference cell in 2D and 3D',
               2,
               None,
               '___sec68'),
              ('Numerical integration', 2, None, '___sec69'),
              ('Convenient formulas for P1 elements in 2D',
               2,
               None,
               '___sec70'),
              ('A glimpse of the mathematical theory of the finite element method',
               2,
               None,
               '___sec71'),
              ('Abstract variational forms', 3, None, '___sec72'),
              ('Example on an abstract variational form and associated spaces',
               3,
               None,
               '___sec73'),
              ('Assumptions', 3, None, '___sec74'),
              ('Existence and uniqueness', 3, None, '___sec75'),
              ('Stability', 3, None, '___sec76'),
              ('Equivalent minimization problem', 3, None, '___sec77'),
              ('Best approximation principle', 3, None, '___sec78'),
              ('Best approximation property in the norm of the space',
               3,
               None,
               '___sec79'),
              ('Symmetric, positive definite coefficient matrix',
               3,
               None,
               '___sec80'),
              ('Equivalent matrix minimization problem', 3, None, '___sec81'),
              ('A priori error estimate for the derivative',
               3,
               None,
               '___sec82'),
              ('A priori error estimate for the solution',
               3,
               None,
               '___sec83'),
              ('Summary', 1, None, '___sec84'),
              ('Exercises', 1, None, '___sec85'),
              ('Exercise 1: Refactor functions into a more general class',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              ('Exercise 2: Compute the deflection of a cable with sine functions',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              ('Least squares method', 3, None, '___sec88'),
              ("Galerkin's method", 3, None, '___sec89'),
              ('Decay of coefficients', 3, None, '___sec90'),
              ('Error in one-term solution', 3, None, '___sec91'),
              ('Exercise 3: Compute the deflection of a cable with power functions',
               2,
               'fem:deq:exer:tension:cable_xn',
               'fem:deq:exer:tension:cable_xn'),
              ('Exercise 4: Check integration by parts',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 5: Compute the deflection of a cable with 2 P1 elements',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Method 1: Excluding the unknown at $x=0$',
               3,
               None,
               '___sec95'),
              ('Method 2: Modifying the linear system', 3, None, '___sec96'),
              ('Exercise 6: Compute the deflection of a cable with 1 P2 element',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Method 1: Excluding the unknown at $x=0$',
               3,
               None,
               '___sec98'),
              ('Method 2: Modifying the linear system', 3, None, '___sec99'),
              ('Exercise 7: Compute the deflection of a cable with a step load',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              ('Exercise 8: Compute with a non-uniform mesh',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              ('Problem 9: Solve a 1D finite element problem by hand',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              ('Exercise 10: Investigate exact finite element solutions',
               2,
               'fem:deq:exer:1D:exact_numerics',
               'fem:deq:exer:1D:exact_numerics'),
              ('Plots for m=0', 3, None, '___sec104'),
              ('Plots for m=1', 3, None, '___sec105'),
              ('Plots for m=2', 3, None, '___sec106'),
              ('Plots for m=3', 3, None, '___sec107'),
              ('Plots for m=4', 3, None, '___sec108'),
              ('Exercise 11: Compare finite elements and differences for a radially symmetric Poisson equation',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              ('Exercise 12: Compute with variable coefficients and P1 elements by hand',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              ('Exercise 13: Solve a 2D Poisson equation using polynomials and sines',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              ('Bibliography', 1, None, '___sec112')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\sequencej}[1]{\left\{ {#1}_j \right\}_{j\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="fem:deq:1D:code">Implementation</h1>

<p>
At this point, it is sensible to create a
program with symbolic calculations to perform all the steps in the
computational machinery,
both for automating the work and for documenting the complete algorithms.
As we have seen, there are quite many details involved with
finite element computations and incorporation of boundary conditions.
An implementation will also act as a structured summary of all these details.

<h2 id="fem:deq:1D:code:global">Global basis functions</h2>

<p>
We first consider implementations when \( \baspsi_i \) are global functions
are hence different from zero on most of \( \Omega =[0,L] \) so all integrals
need integration over the entire domain. (Finite element basis functions,
where we utilize their local support and perform integrations over
cells, will be treated later.) Since the expressions for
the entries in the linear system depend on the differential equation
problem being solved, the user must supply the necessary formulas via
Python functions. The implementations here attempt to perform symbolic
calculations, but fall back on numerical computations if the symbolic
ones fail.

<p>
The user must prepare a function
<code>integrand_lhs(psi, i, j)</code> for returning the integrand of the
integral that contributes to matrix entry \( (i,j) \).
The <code>psi</code> variable is a Python dictionary holding the basis
functions and their derivatives in symbolic form. More precisely,
<code>psi[q]</code> is a list of

$$
\begin{equation*}
\{\frac{d^q\baspsi_0}{dx^q},\ldots,\frac{d^q\baspsi_{N_n-1}}{dx^q}\}
\tp
\end{equation*}
$$

Similarly, <code>integrand_rhs(psi, i)</code> returns the integrand
for entry number \( i \) in the right-hand side vector.

<p>
Since we also have contributions to the right-hand side vector
(and potentially also the
matrix) from boundary terms without any integral, we introduce two
additional functions, <code>boundary_lhs(psi, i, j)</code> and
<code>boundary_rhs(psi, i)</code> for returning terms in the variational
formulation that are not to be integrated over the domain \( \Omega \).
Examples, to be shown later, will explain in more detail how these
user-supplied function may look like.

<p>
The linear system can be computed and solved symbolically by
the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(integrand_lhs, integrand_rhs, psi, Omega,
           boundary_lhs=<span style="color: #658b00">None</span>, boundary_rhs=<span style="color: #658b00">None</span>):
    N = <span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>]) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            integrand = integrand_lhs(psi, i, j)
            I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            <span style="color: #8B008B; font-weight: bold">if</span> boundary_lhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I   <span style="color: #228B22"># assume symmetry</span>
        integrand = integrand_rhs(psi, i)
        I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
        <span style="color: #8B008B; font-weight: bold">if</span> boundary_rhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            I += boundary_rhs(psi, i)
        b[i,<span style="color: #B452CD">0</span>] = I
    c = A.LUsolve(b)
    u = <span style="color: #658b00">sum</span>(c[i,<span style="color: #B452CD">0</span>]*psi[<span style="color: #B452CD">0</span>][i] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>])))
    <span style="color: #8B008B; font-weight: bold">return</span> u, c
</pre></div>
<p>
Not surprisingly, symbolic solution of differential
equations, discretized by a Galerkin or least squares method
with global basis functions,
is of limited interest beyond the simplest problems, because
symbolic integration might be very time consuming or impossible, not
only in <code>sympy</code> but also in
<a href="http://wolframalpha.com" target="_self">WolframAlpha</a>
(which applies the perhaps most powerful symbolic integration
software available today: Mathematica). Numerical integration
as an option is therefore desirable.

<p>
The extended <code>solver</code> function below tries to combine symbolic and
numerical integration.  The latter can be enforced by the user, or it
can be invoked after a non-successful symbolic integration (being
detected by an <code>Integral</code> object as the result of the integration
in <code>sympy</code>).
<!-- see the section ref{fem:approx:global:Lagrange}). -->
Note that for a
numerical integration, symbolic expressions must be converted to
Python functions (using <code>lambdify</code>), and the expressions cannot contain
other symbols than <code>x</code>. The real <code>solver</code> routine in the
<a href="http://tinyurl.com/nm5587k/varform/varform1D.py" target="_self"><tt>varform1D.py</tt></a>
file has error checking and meaningful error messages in such cases.
The <code>solver</code> code below is a condensed version of the real one, with
the purpose of showing how to automate the Galerkin or least squares
method for solving differential equations in 1D with global basis functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(integrand_lhs, integrand_rhs, psi, Omega,
           boundary_lhs=<span style="color: #658b00">None</span>, boundary_rhs=<span style="color: #658b00">None</span>, symbolic=<span style="color: #658b00">True</span>):
    N = <span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>]) - <span style="color: #B452CD">1</span>
    A = sym.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sym.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sym.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            integrand = integrand_lhs(psi, i, j)
            <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
                I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
                <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
                    symbolic = <span style="color: #658b00">False</span>  <span style="color: #228B22"># force num.int. hereafter</span>
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic:
                integrand = sym.lambdify([x], integrand)
                I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
            <span style="color: #8B008B; font-weight: bold">if</span> boundary_lhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
                I += boundary_lhs(psi, i, j)
            A[i,j] = A[j,i] = I
        integrand = integrand_rhs(psi, i)
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sym.integrate(integrand, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sym.Integral):
                symbolic = <span style="color: #658b00">False</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic:
            integrand = sym.lambdify([x], integrand)
            I = sym.mpmath.quad(integrand, [Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]])
        <span style="color: #8B008B; font-weight: bold">if</span> boundary_rhs <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            I += boundary_rhs(psi, i)
        b[i,<span style="color: #B452CD">0</span>] = I
    c = A.LUsolve(b)
    u = <span style="color: #658b00">sum</span>(c[i,<span style="color: #B452CD">0</span>]*psi[<span style="color: #B452CD">0</span>][i] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(psi[<span style="color: #B452CD">0</span>])))
    <span style="color: #8B008B; font-weight: bold">return</span> u, c
</pre></div>

<h2 id="___sec61">Example: constant right-hand side </h2>

<p>
To demonstrate the code above, we address

$$
\begin{equation*} -u''(x)=b,\quad x\in\Omega=[0,1],\quad u(0)=1,\ u(1)=0,\end{equation*}
$$

with \( b \) as a (symbolic) constant. A possible basis for the space \( V \)
is \( \baspsi_i(x) = x^{i+1}(1-x) \), \( i\in\If \). Note that
\( \baspsi_i(0)=\baspsi_i(1)=0 \) as required by the Dirichlet conditions.
We need a \( B(x) \) function to take care of the known boundary
values of \( u \). Any function \( B(x)=1-x^p \), \( p\in\Real \), is a candidate,
and one arbitrary choice from this family
is \( B(x)=1-x^3 \). The unknown function is then written as

$$
\begin{equation*}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x)\tp
\end{equation*}
$$

<p>
Let us use the Galerkin method to derive the variational formulation.
Multiplying the differential
equation by \( v \) and integrating by parts yield

$$
\begin{equation*}
\int_0^1 u'v' \dx = \int_0^1 fv \dx\quad\forall v\in V,
\end{equation*}
$$

and with \( u=B + \sum_jc_j\baspsi_j \) we get the linear system

$$
\begin{equation}
\sum_{j\in\If}\left(\int_0^1\baspsi_i'\baspsi_j' \dx\right)c_j =
\int_0^1(f\baspsi_i-B'\baspsi_i') \dx,
\quad i\in\If\tp
\tag{81}
\end{equation}
$$

<p>
The application can be coded as follows with <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
x, b = sym.symbols(<span style="color: #CD5555">&#39;x b&#39;</span>)
f = b
B = <span style="color: #B452CD">1</span> - x**<span style="color: #B452CD">3</span>
dBdx = sym.diff(B, x)

<span style="color: #228B22"># Compute basis functions and their derivatives</span>
N = <span style="color: #B452CD">3</span>
psi = {<span style="color: #B452CD">0</span>: [x**(i+<span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">1</span>-x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]}
psi[<span style="color: #B452CD">1</span>] = [sym.diff(psi_i, x) <span style="color: #8B008B; font-weight: bold">for</span> psi_i <span style="color: #8B008B">in</span> psi[<span style="color: #B452CD">0</span>]]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">integrand_lhs</span>(psi, i, j):
    <span style="color: #8B008B; font-weight: bold">return</span> psi[<span style="color: #B452CD">1</span>][i]*psi[<span style="color: #B452CD">1</span>][j]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">integrand_rhs</span>(psi, i):
    <span style="color: #8B008B; font-weight: bold">return</span> f*psi[<span style="color: #B452CD">0</span>][i] - dBdx*psi[<span style="color: #B452CD">1</span>][i]

Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]

<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">varform1D</span> <span style="color: #8B008B; font-weight: bold">import</span> solver
u_bar, c = solver(integrand_lhs, integrand_rhs, psi, Omega,
                  verbose=<span style="color: #658b00">True</span>, symbolic=<span style="color: #658b00">True</span>)
u = B + u_bar
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;solution u:&#39;</span>, sym.simplify(sym.expand(u))
</pre></div>
<p>
The printout of <code>u</code> reads <code>-b*x**2/2 + b*x/2 - x + 1</code>.
Note that expanding <code>u</code>, before simplifying, is necessary
in the present case
to get a compact, final expression with <code>sympy</code>. Doing <code>expand</code> before
<code>simplify</code> is a common strategy for simplifying expressions in
<code>sympy</code>. However,
a non-expanded <code>u</code> might be preferable in other cases - this depends on
the problem in question.

<p>
The exact solution \( \uex(x) \) can be derived by
some <code>sympy</code> code that closely follows the examples in
the section <a href="._varform-solarized001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>. The idea is to integrate
\( -u''=b \) twice and determine the integration constants from
the boundary conditions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">C1, C2 = sym.symbols(<span style="color: #CD5555">&#39;C1 C2&#39;</span>)    <span style="color: #228B22"># integration constants</span>
f1 = sym.integrate(f, x) + C1
f2 = sym.integrate(f1, x) + C2
<span style="color: #228B22"># Find C1 and C2 from the boundary conditions u(0)=0, u(1)=1</span>
s = sym.solve([u_e.subs(x,<span style="color: #B452CD">0</span>) - <span style="color: #B452CD">1</span>, u_e.subs(x,<span style="color: #B452CD">1</span>) - <span style="color: #B452CD">0</span>], [C1, C2])
<span style="color: #228B22"># Form the exact solution</span>
u_e = -f2 + s[C1]*x + s[C2]
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;analytical solution:&#39;</span>, u_e
<span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;error:&#39;</span>, sym.simplify(sym.expand(u - u_e))
</pre></div>
<p>
The last line prints <code>0</code>, which is not surprising when
\( \uex(x) \) is a parabola and our approximate \( u \) contains polynomials up to
degree 4. It suffices to have \( N=1 \), i.e., polynomials of degree
2, to recover the exact solution.

<p>
We can play around with the code and test that with \( f=Kx^p \), for
some constants \( K \) and \( p \),
the solution is a polynomial of degree \( p+2 \), and \( N=p+1 \) guarantees
that the approximate solution is exact.

<p>
Although the symbolic code is capable of integrating many choices of \( f(x) \),
the symbolic expressions for \( u \) quickly become lengthy and non-informative,
so numerical integration in the code, and hence numerical answers,
have the greatest application potential.

<h2 id="fem:deq:1D:code:fe">Finite elements</h2>

<p>
Implementation of the finite element algorithms for differential
equations follows closely the algorithm for approximation of functions.
The new additional ingredients are

<ol>
<li> other types of integrands (as implied by the variational formulation)</li>
<li> additional boundary terms in the variational formulation for
   Neumann boundary conditions</li>
<li> modification of element matrices and vectors due to Dirichlet
   boundary conditions</li>
</ol>

Point 1 and 2 can be taken care of by letting the user supply
functions defining the integrands and boundary terms on the
left- and right-hand side of the equation system:

<ul>
 <li> Integrand on the left-hand side: <code>ilhs(e, phi, r, s, X, x, h)</code></li>
 <li> Integrand on the right-hand side: <code>irhs(e, phi, r, X, x, h)</code></li>
 <li> Boundary term on the left-hand side: <code>blhs (e, phi, r, s, X, x, h)</code></li>
 <li> Boundary term on the right-hand side: <code>brhs (e, phi, r, s, X, x, h)</code></li>
</ul>

Here, <code>phi</code> is a dictionary where <code>phi[q]</code> holds a list of the
derivatives of order <code>q</code> of the basis functions with respect to the
physical coordinate \( x \).  The derivatives are available as Python
functions of <code>X</code>.  For example, <code>phi[0][r](X)</code> means \( \refphi_r(X) \),
and <code>phi[1][s](X, h)</code> means \( d\refphi_s (X)/dx \) (we refer to
the file <a href="http://tinyurl.com/nm5587k/varform/fe1D.py" target="_self"><tt>fe1D.py</tt></a> for details
regarding the function <code>basis</code> that computes the <code>phi</code>
dictionary).  The <code>r</code> and <code>s</code>
arguments in the above functions correspond to the index in the
integrand contribution from an integration point to \( \tilde
A^{(e)}_{r,s} \) and \( \tilde b^{(e)}_r \). The variables <code>e</code> and <code>h</code> are
the current element number and the length of the cell, respectively.
Specific examples below will make it clear how to construction these
Python functions.

<p>
Given a mesh represented by <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> as
explained before, we can write a pseudo Python code to list all
the steps in the computational algorithm for finite element solution
of a differential equation.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&lt;Declare <span style="color: #8B008B; font-weight: bold">global</span> matrix <span style="color: #8B008B">and</span> rhs: A, b&gt;

<span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(cells)):

    <span style="color: #228B22"># Compute element matrix and vector</span>
    n = <span style="color: #658b00">len</span>(dof_map[e])  <span style="color: #228B22"># no of dofs in this element</span>
    h = vertices[cells[e][<span style="color: #B452CD">1</span>]] - vertices[cells[e][<span style="color: #B452CD">1</span>]]
    &lt;Initialize element matrix <span style="color: #8B008B">and</span> vector: A_e, b_e&gt;

    <span style="color: #228B22"># Integrate over the reference cell</span>
    points, weights = &lt;numerical integration rule&gt;
    <span style="color: #8B008B; font-weight: bold">for</span> X, w <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(points, weights):
        phi = &lt;basis functions <span style="color: #8B008B">and</span> derivatives at X&gt;
        detJ = h/<span style="color: #B452CD">2</span>
        dX = detJ*w

        x = &lt;affine mapping <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">X</span>&gt;
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A_e[r,s] += ilhs(e, phi, r, s, X, x, h)*dX
            b_e[r] += irhs(e, phi, r, X, x, h)*dX

    <span style="color: #228B22"># Add boundary terms</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A_e[r,s] += blhs(e, phi, r, s, X, x)*dX
        b_e[r] += brhs(e, phi, r, X, x, h)*dX

    <span style="color: #228B22"># Incorporate essential boundary conditions</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        global_dof = dof_map[e][r]
        <span style="color: #8B008B; font-weight: bold">if</span> global_dof <span style="color: #8B008B">in</span> essbc:
            <span style="color: #228B22"># local dof r is subject to an essential condition</span>
            value = essbc[global_dof]
            <span style="color: #228B22"># Symmetric modification</span>
            b_e -= value*A_e[:,r]
            A_e[r,:] = <span style="color: #B452CD">0</span>
            A_e[:,r] = <span style="color: #B452CD">0</span>
            A_e[r,r] = <span style="color: #B452CD">1</span>
            b_e[r] = value

    <span style="color: #228B22"># Assemble</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A[dof_map[e][r], dof_map[e][s]] += A_e[r,s]
        b[dof_map[e][r] += b_e[r]

&lt;solve linear system&gt;
</pre></div>
<p>
A complete function <code>finite_element1D_naive</code>
for the 1D finite algorithm above, is found in the file
<a href="http://tinyurl.com/nm5587k/varform/fe1D.py" target="_self"><tt>fe1D.py</tt></a>. The term &quot;naive&quot; refers
to a version of the algorithm where we use a standard dense square matrix
as global matrix <code>A</code>. The implementation also has a verbose mode for
printing out the element matrices and vectors as they are computed.
Below is the complete function without the print statements.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">finite_element1D_naive</span>(
    vertices, cells, dof_map,     <span style="color: #228B22"># mesh</span>
    essbc,                        <span style="color: #228B22"># essbc[globdof]=value</span>
    ilhs,                         <span style="color: #228B22"># integrand left-hand side</span>
    irhs,                         <span style="color: #228B22"># integrand right-hand side</span>
    blhs=<span style="color: #8B008B; font-weight: bold">lambda</span> e, phi, r, s, X, x, h: <span style="color: #B452CD">0</span>,
    brhs=<span style="color: #8B008B; font-weight: bold">lambda</span> e, phi, r, X, x, h: <span style="color: #B452CD">0</span>,
    intrule=<span style="color: #CD5555">&#39;GaussLegendre&#39;</span>,      <span style="color: #228B22"># integration rule class</span>
    verbose=<span style="color: #658b00">False</span>,                <span style="color: #228B22"># print intermediate results?</span>
    ):
    N_e = <span style="color: #658b00">len</span>(cells)
    N_n = np.array(dof_map).max() + <span style="color: #B452CD">1</span>

    A = np.zeros((N_n, N_n))
    b = np.zeros(N_n)

    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [vertices[cells[e][<span style="color: #B452CD">0</span>]], vertices[cells[e][<span style="color: #B452CD">1</span>]]]
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]

        d = <span style="color: #658b00">len</span>(dof_map[e]) - <span style="color: #B452CD">1</span>  <span style="color: #228B22"># Polynomial degree</span>
        <span style="color: #228B22"># Compute all element basis functions and their derivatives</span>
        phi = basis(d)

        <span style="color: #228B22"># Element matrix and vector</span>
        n = d+<span style="color: #B452CD">1</span>  <span style="color: #228B22"># No of dofs per element</span>
        A_e = np.zeros((n, n))
        b_e = np.zeros(n)

        <span style="color: #228B22"># Integrate over the reference cell</span>
        <span style="color: #8B008B; font-weight: bold">if</span> intrule == <span style="color: #CD5555">&#39;GaussLegendre&#39;</span>:
            points, weights = GaussLegendre(d+<span style="color: #B452CD">1</span>)
        <span style="color: #8B008B; font-weight: bold">elif</span> intrule == <span style="color: #CD5555">&#39;NewtonCotes&#39;</span>:
            points, weights = NewtonCotes(d+<span style="color: #B452CD">1</span>)

        <span style="color: #8B008B; font-weight: bold">for</span> X, w <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(points, weights):
            detJ = h/<span style="color: #B452CD">2</span>
            x = affine_mapping(X, Omega_e)
            dX = detJ*w

            <span style="color: #228B22"># Compute contribution to element matrix and vector</span>
            <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                    A_e[r,s] += ilhs(phi, r, s, X, x, h)*dX
                b_e[r] += irhs(phi, r, X, x, h)*dX

        <span style="color: #228B22"># Add boundary terms</span>
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A_e[r,s] += blhs(phi, r, s, X, x, h)
            b_e[r] += brhs(phi, r, X, x, h)

        <span style="color: #228B22"># Incorporate essential boundary conditions</span>
        modified = <span style="color: #658b00">False</span>
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            global_dof = dof_map[e][r]
            <span style="color: #8B008B; font-weight: bold">if</span> global_dof <span style="color: #8B008B">in</span> essbc:
                <span style="color: #228B22"># dof r is subject to an essential condition</span>
                value = essbc[global_dof]
                <span style="color: #228B22"># Symmetric modification</span>
                b_e -= value*A_e[:,r]
                A_e[r,:] = <span style="color: #B452CD">0</span>
                A_e[:,r] = <span style="color: #B452CD">0</span>
                A_e[r,r] = <span style="color: #B452CD">1</span>
                b_e[r] = value
                modified = <span style="color: #658b00">True</span>

        <span style="color: #228B22"># Assemble</span>
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A[dof_map[e][r], dof_map[e][s]] += A_e[r,s]
            b[dof_map[e][r]] += b_e[r]

    c = np.linalg.solve(A, b)
    <span style="color: #8B008B; font-weight: bold">return</span> c, A, b, timing
</pre></div>
<p>
The <code>timing</code> object is a dictionary holding the CPU spent on computing
<code>A</code> and the CPU time spent on solving the linear system. (We have
left out the timing statements.)

<h2 id="fem:deq:1D:code:fe_sparse">Utilizing a sparse matrix</h2>

<p>
A potential efficiency problem with the <code>finite_element1D_naive</code> function
is that it uses dense \( (N+1)\times (N+1) \) matrices, while we know that
only \( 2d+1 \) diagonals around the main diagonal are different from zero.
Switching to a sparse matrix is very easy. Using the DOK (dictionary of
keys) format, we declare <code>A</code> as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse</span>
A = scipy.sparse.dok_matrix((N_n, N_n))
</pre></div>
<p>
Assignments or in-place arithmetics are done as for a dense matrix,

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">A[i,j] += term
A[i,j]  = term
</pre></div>
<p>
but only the index pairs <code>(i,j)</code> we have used in assignments or
in-place arithmetics are actually stored.
A tailored solution algorithm is needed. The most reliable is
sparse Gaussian elimination:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse.linalg</span>
c = scipy.sparse.linalg.spsolve(A.tocsr(), b, use_umfpack=<span style="color: #658b00">True</span>)
</pre></div>
<p>
The declaration of <code>A</code> and the solve statement are the only
changes needed in the <code>finite_element1D_naive</code> to utilize
sparse matrices. The resulting modification is found in the
function <code>finite_element1D</code>.

<h3 id="___sec64">Example </h3>

<p>
Let us demonstrate the finite element software on

$$ -u''(x)=f(x),\quad x\in (0,L),\quad u'(0)=C,\ u(L)=D\tp$$

This problem can be analytically solved by the
<code>model2</code> function from the section <a href="._varform-solarized001.html#fem:deq:1D:models:simple">Simple model problems and their solutions</a>.
Let \( f(x)=x^2 \). Calling <code>model2(x**2, L, C, D)</code> gives

$$ u(x) = D + C(x-L) + \frac{1}{12}(L^4 - x^4) $$

<p>
The variational formulation reads

$$ (u', v) = (x^2, v) - Cv(0)\tp$$

The entries in the element matrix and vector,
which we need to set up the <code>ilhs</code>, <code>irhs</code>,
<code>blhs</code>, and <code>brhs</code> functions, becomes

$$
\begin{align*}
A^{(e)}_{r,s} &= \int_{-1}^1 \frac{d\refphi_r}{dx}\frac{\refphi_s}{dx}(\det J\dX),\\ 
b^{(e)} &= \int_{-1}^1 x^2\refphi_r\det J\dX - C\refphi_r(-1)I(e,0),
\end{align*}
$$

where \( I(e) \) is an indicator function: \( I(e,q)=1 \) if \( e=q \), otherwise \( I(e)=0 \).
We use this indicator function to formulate that the boundary term
\( Cv(0) \), which in the local element coordinate system becomes \( C\refphi_r(-1) \),
is only included for the element \( e=0 \).

<p>
The functions for specifying the element matrix and vector entries
must contain the integrand, but without the \( \det J\dX \) term, and
the derivatives \( d\refphi_r(X)/dx \)
with respect to the physical \( x \) coordinates are
contained in <code>phi[1][r](X)</code>, computed by the function <code>basis</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ilhs</span>(e, phi, r, s, X, x, h):
    <span style="color: #8B008B; font-weight: bold">return</span> phi[<span style="color: #B452CD">1</span>][r](X, h)*phi[<span style="color: #B452CD">1</span>][s](X, h)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">irhs</span>(e, phi, r, X, x, h):
    <span style="color: #8B008B; font-weight: bold">return</span> x**<span style="color: #B452CD">2</span>*phi[<span style="color: #B452CD">0</span>][r](X)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">blhs</span>(e, phi, r, s, X, x, h):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">brhs</span>(e, phi, r, X, x, h):
    <span style="color: #8B008B; font-weight: bold">return</span> -C*phi[<span style="color: #B452CD">0</span>][r](-<span style="color: #B452CD">1</span>) <span style="color: #8B008B; font-weight: bold">if</span> e == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>
</pre></div>
<p>
We can then make the call to <code>finite_element1D_naive</code> or <code>finite_element1D</code>
to solve the problem with two P1 elements:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe1D</span> <span style="color: #8B008B; font-weight: bold">import</span> finite_element1D_naive, mesh_uniform
C = <span style="color: #B452CD">5</span>;  D = <span style="color: #B452CD">2</span>;  L = <span style="color: #B452CD">4</span>
d = <span style="color: #B452CD">1</span>

vertices, cells, dof_map = mesh_uniform(
    N_e=<span style="color: #B452CD">2</span>, d=d, Omega=[<span style="color: #B452CD">0</span>,L], symbolic=<span style="color: #658b00">False</span>)
essbc = {}
essbc[dof_map[-<span style="color: #B452CD">1</span>][-<span style="color: #B452CD">1</span>]] = D

c, A, b, timing = finite_element1D(
    vertices, cells, dof_map, essbc,
    ilhs=ilhs, irhs=irhs, blhs=blhs, brhs=brhs,
    intrule=<span style="color: #CD5555">&#39;GaussLegendre&#39;</span>)
</pre></div>
<p>
It remains to plot the solution (with high resolution in each element).
To this end, we use the <code>u_glob</code> function imported from
<code>fe1D</code>, which imports it from <code>fe_approx1D_numit</code> (the
<code>u_glob</code> function in <code>fe_approx1D.py</code>
works with <code>elements</code> and <code>nodes</code>, while <code>u_glob</code> in
<code>fe_approx1D_numint</code> works with <code>cells</code>, <code>vertices</code>,
and <code>dof_map</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u_exact = <span style="color: #8B008B; font-weight: bold">lambda</span> x: D + C*(x-L) + (<span style="color: #B452CD">1.</span>/<span style="color: #B452CD">6</span>)*(L**<span style="color: #B452CD">3</span> - x**<span style="color: #B452CD">3</span>)
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe1D</span> <span style="color: #8B008B; font-weight: bold">import</span> u_glob
x, u, nodes = u_glob(c, cells, vertices, dof_map)
u_e = u_exact(x, C, D, L)
<span style="color: #8B008B; font-weight: bold">print</span> u_exact(nodes, C, D, L) - c  <span style="color: #228B22"># difference at the nodes</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
plt.plot(x, u, <span style="color: #CD5555">&#39;b-&#39;</span>, x, u_e, <span style="color: #CD5555">&#39;r--&#39;</span>)
plt.legend([<span style="color: #CD5555">&#39;finite elements, d=%d&#39;</span> %d, <span style="color: #CD5555">&#39;exact&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
plt.show()
</pre></div>
<p>
The result is shown in Figure <a href="#fem:deq:1D:code:fe:fig1">3</a>. We see
that the solution using P1 elements is exact at the nodes, but
feature considerable discrepancy between the nodes.
<a href="._varform-solarized009.html#fem:deq:exer:1D:exact_numerics">Exercise 10: Investigate exact finite element solutions</a> asks you to explore
this problem further using other \( m \) and \( d \) values.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Finite element and exact solution using two cells. <div id="fem:deq:1D:code:fe:fig1"></div> </p></center>
<p><img src="fig-varform/uxx_x2.png" align="bottom" width=500></p>
</center>

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._varform-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._varform-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

